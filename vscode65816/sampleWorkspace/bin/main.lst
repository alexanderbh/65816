ca65 V2.18 - Ubuntu 2.19-1
Main file   : src/main.asm
Current file: src/main.asm

000000r 1               .setcpu "65816"
000000r 1               .P816
000000r 1               .smart
000000r 1               .feature string_escapes
000000r 1               
000000r 1               .RODATA
000000r 1               
000000r 1  0A 2D 2D 2D  test_string: .asciiz "\n---\n"
000004r 1  0A 00        
000006r 1  31 33 35 37  testlen_string: .asciiz "1357abcdefgh78"
00000Ar 1  61 62 63 64  
00000Er 1  65 66 67 68  
000015r 1               
000015r 1               .code
000000r 1               .include "kernel/kernel.inc"
000000r 2               .A16
000000r 2               .I16
000000r 2               .macro write str_addr
000000r 2                   SEI
000000r 2                   pea str_addr
000000r 2                   JSL RA8875_WriteString16
000000r 2                   PLA
000000r 2                   CLI
000000r 2               .endmacro
000000r 2               
000000r 2               .A8
000000r 2               .I8
000000r 2               .macro write_char char
000000r 2                   PHA
000000r 2                   LDA char
000000r 2                   JSR RA8875_WriteStringChar
000000r 2                   PLA
000000r 2               .endmacro
000000r 2               
000000r 2               .RODATA
000015r 2               
000015r 2  0A 00        newline:                    .asciiz "\n"
000017r 2  4B 45 52 4E  init_kernel_done:           .asciiz "KERNEL - OK\n"
00001Br 2  45 4C 20 2D  
00001Fr 2  20 4F 4B 0A  
000024r 2  4B 45 52 4E  init_kernel_streams_done:   .asciiz "KERNEL: Streams - OK\n"
000028r 2  45 4C 3A 20  
00002Cr 2  53 74 72 65  
00003Ar 2  4B 45 52 4E  init_kernel_tasks_done:     .asciiz "KERNEL: Tasks - OK\n"
00003Er 2  45 4C 3A 20  
000042r 2  54 61 73 6B  
00004Er 2  4B 45 52 4E  init_kernel_scheduler_done: .asciiz "KERNEL: Scheduler - OK\n"
000052r 2  45 4C 3A 20  
000056r 2  53 63 68 65  
000066r 2               .code
000000r 2               
000000r 1               .include "macros/macros.inc"
000000r 2               ; bmn
000000r 2               ;       Block move macro
000000r 2               
000000r 2               .macro  bmn     len,from,to
000000r 2                       lda     #len-1
000000r 2                       ldx     #(from & $FFFF)
000000r 2                       ldy     #(to   & $FFFF)
000000r 2                       mvn     (from & $FF0000),(to & $FF0000)
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ;   Register Size Macros
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;   These macros are a convenient way to change the MPU's register sizes
000000r 2               ;   without having to remember the correct bit pattern for the REP & SEP
000000r 2               ;   instructions.  The assembler itself has no awareness of whether 8 or
000000r 2               ;   16 bit immediate mode operands are to be used.   Therefore, it is up
000000r 2               ;   to the programmer to use the appropriate instructions, & to be aware
000000r 2               ;   at all times of the MPU's register sizes.
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;
000000r 2               .macro  longa                ;16 bit accumulator & memory
000000r 2                       rep #$20
000000r 2               .A16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longr                ;16 bit all registers
000000r 2                       rep #$30
000000r 2               .A16
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longi              ;16 bit index registers
000000r 2                       rep #$10
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorta                ;8 bit accumulator & memory
000000r 2                       sep #$20
000000r 2               .A8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorti                ;8 bit index registers
000000r 2                       sep #$10
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shortr                ;8 bit all registers
000000r 2                       sep #$30
000000r 2               .A8
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               
000000r 1               
000000r 1               .include "bios/bios.asm"
000000r 2               .include "bios.inc"                         ; include BIOS includes
000000r 3               .RODATA
000066r 3               
000066r 3  42 49 4F 53  bios_init: .asciiz "BIOS Initialized"
00006Ar 3  20 49 6E 69  
00006Er 3  74 69 61 6C  
000077r 3  20 2D 20 4F  ok_string: .asciiz " - OK\n"
00007Br 3  4B 0A 00     
00007Er 3               
00007Er 3               
00007Er 3  43 4F 4C 4F  ansi_string: .byte "COLOR: ", $1B, $5B, "32mGREEN", $1B, $5B, "37m WHITE\n", $00
000082r 3  52 3A 20 1B  
000086r 3  5B 33 32 6D  
00009Cr 3               
00009Cr 3  49 4E 49 54  test_bios: .asciiz "INIT...\n"
0000A0r 3  2E 2E 2E 0A  
0000A4r 3  00           
0000A5r 3  20 2D 20 46  fail_string: .asciiz " - FAIL\n"
0000A9r 3  41 49 4C 0A  
0000ADr 3  00           
0000AEr 3               
0000AEr 3  20 5F 5F 5F  welcome_logo1: .asciiz " ______   ______   ______     ____     ______       ______   ______\n"
0000B2r 3  5F 5F 5F 20  
0000B6r 3  20 20 5F 5F  
0000F3r 3  2F 5F 5F 5F  welcome_logo2: .asciiz "/_____/\\ /_____/\\ /_____/\\   /___/\\   /_____/\\     /_____/\\ /_____/\\\n"
0000F7r 3  5F 5F 2F 5C  
0000FBr 3  20 2F 5F 5F  
000139r 3  5C 3A 3A 3A  welcome_logo3: .asciiz "\\:::__\\/ \\::::_\\/_\\:::_:\\ \\  \\_::\\ \\  \\:::__\\/     \\:::_ \\ \\\\::::_\\/_\n"
00013Dr 3  5F 5F 5C 2F  
000141r 3  20 5C 3A 3A  
000180r 3  20 5C 3A 5C  welcome_logo4: .asciiz " \\:\\ \\____\\:\\/___/\\\\:\\_\\:\\ \\   \\::\\ \\  \\:\\ \\____    \\:\\ \\ \\ \\\\:\\/___/\\\n"
000184r 3  20 5C 5F 5F  
000188r 3  5F 5F 5C 3A  
0001C8r 3  20 20 5C 3A  welcome_logo5: .asciiz "  \\::__::/\\\\_::._\\:\\\\::__:\\ \\  _\\: \\ \\__\\::__::/\\    \\:\\ \\ \\ \\\\_::._\\:\\\n"
0001CCr 3  3A 5F 5F 3A  
0001D0r 3  3A 2F 5C 5C  
000211r 3  20 20 20 5C  welcome_logo6: .asciiz "   \\:\\_\\:\\ \\/_____\\/ \\:\\_\\:\\ \\/__\\: \\__/\\\\:\\_\\:\\ \\    \\:\\_\\ \\ \\ /____\\:\\\n"
000215r 3  3A 5C 5F 5C  
000219r 3  3A 5C 20 5C  
00025Br 3  20 20 20 20  welcome_logo7: .asciiz "    \\_____\\/\\_____/   \\_____\\/\\________\\/ \\_____\\/     \\_____\\/ \\_____\\/\n"
00025Fr 3  5C 5F 5F 5F  
000263r 3  5F 5F 5C 2F  
0002A5r 3               
0002A5r 3               .code
000000r 3               
000000r 2               .include "via.inc"                          ; include VIA labels
000000r 3               
000000r 3                   .import __VIA1_START__
000000r 3                   .import __VIA2_START__
000000r 3               
000000r 3                   VIA1B = __VIA1_START__                            ; VIA PORT B input/output register
000000r 3                   VIA1A = __VIA1_START__ + 1                        ; VIA PORT A input/output register
000000r 3                   VIA1B_DIRECTION = __VIA1_START__ + 2              ; VIA PORT B direction register is $6002
000000r 3                   VIA1A_DIRECTION = __VIA1_START__ + 3              ; VIA PORT A direction register is $6003
000000r 3                   VIA1_T1CL = __VIA1_START__ + 4                    ; Timer 1 Low order latches
000000r 3                   VIA1_T1CH = __VIA1_START__ + 5                    ; Timer 1 High order counter
000000r 3                   VIA1_ACR = __VIA1_START__ + 11                    ; Auxillary Control Register
000000r 3                   VIA1_PCR = __VIA1_START__ + 12                    ; Peripheral Control Register
000000r 3                   VIA1_IFR = __VIA1_START__ + 13                    ; Interupt Flag Register
000000r 3                   VIA1_IER = __VIA1_START__ + 14                    ; Interupt Enable Register
000000r 3               
000000r 3                   VIA2B = __VIA2_START__                            ; VIA2 PORT B input/output register
000000r 3                   VIA2A = __VIA2_START__ + 1                        ; VIA2 PORT A input/output register
000000r 3                   VIA2B_DIRECTION = __VIA2_START__ + 2              ; VIA2 PORT B direction register is $5002
000000r 3                   VIA2A_DIRECTION = __VIA2_START__ + 3              ; VIA2 PORT A direction register is $5003
000000r 3               
000000r 2               .include "drivers/spi/spi.asm"           ; include SPI code
000000r 3               .SEGMENT "KERNEL"
000000r 3  xx               spi_byte_out:               .res 1
000001r 3  xx               spi_byte_in:                .res 1
000002r 3  xx               spi_selected_device:        .res 1
000003r 3               
000003r 3               .code
000000r 3               .A8
000000r 3               .I8
000000r 3               SPI_VIA = VIA1B
000000r 3               
000000r 3               ; prepares spi VIA PORT A for input output
000000r 3               InitSPI:
000000r 3  A9 47            LDA #$47
000002r 3  8D rr rr         STA VIA1B_DIRECTION
000005r 3  A9 00            LDA #$00
000007r 3  8D rr rr         STA SPI_VIA
00000Ar 3  60               RTS
00000Br 3               
00000Br 3               ; select device for spi communication
00000Br 3               SpiDeviceSelect:
00000Br 3  8D rr rr         STA spi_selected_device
00000Er 3  AD rr rr         LDA SPI_VIA
000011r 3  60               RTS
000012r 3               
000012r 3               ; deselect spi device
000012r 3               SpiDeviceDeselect:
000012r 3  9C rr rr         STZ spi_selected_device
000015r 3  9C rr rr         STZ SPI_VIA
000018r 3  60               RTS
000019r 3               
000019r 3               
000019r 3               ; Transmit one byte SPI data. Remember to select SPI device with SpiDeviceSelect
000019r 3               ; in:
000019r 3               ;   A - byte to send over SPI
000019r 3               ; out:
000019r 3               ;   A - byte received over SPI
000019r 3               
000019r 3               SpiByte:
000019r 3  78               SEI
00001Ar 3  8D rr rr         STA spi_byte_out                            ; store
00001Dr 3  9C rr rr         STZ spi_byte_in
000020r 3  A2 08            LDX #8
000022r 3  AD rr rr         LDA spi_selected_device
000025r 3               spibytelp:
000025r 3  0E rr rr         ASL spi_byte_out	                        ; (5) shift MSB in to carry
000028r 3  90 02            BCC spibyte1
00002Ar 3  09 40            ORA #$40                                    ; set MOSI if MSB set
00002Cr 3               spibyte1:
00002Cr 3  8D rr rr         STA SPI_VIA	                                ; output (MOSI    SCS low   SCLK low)
00002Fr 3               
00002Fr 3  AD rr rr         LDA spi_selected_device                     ; set A to selected device bit (Do it here for delay reasons)
000032r 3  EE rr rr         INC SPI_VIA                                 ; toggle clock high (SCLK is bit 0)
000035r 3               
000035r 3  18               CLC                                         ; clear C (Not affected by bit)
000036r 3  2C rr rr         BIT SPI_VIA                                 ; copy MISO (bit 7) in to N (and MOSI in to V)
000039r 3  10 01            BPL spibyte2
00003Br 3  38               SEC		                                    ; set C is MISO bit is set (i.e. N)
00003Cr 3               spibyte2:
00003Cr 3  2E rr rr         ROL spi_byte_in		                        ; copy C (i.e. MISO bit) in to bit 0 of result
00003Fr 3  CE rr rr         DEC SPI_VIA                                 ; toggle clock low (SCLK is bit 0)
000042r 3               
000042r 3  CA               DEX
000043r 3  D0 E0            BNE spibytelp;
000045r 3  AD rr rr         LDA spi_byte_in	                            ; load result into A
000048r 3  58               CLI
000049r 3  60               RTS
00004Ar 3               
00004Ar 2               .include "drivers/keyboard/keyboard.asm" ; include Keyboard driver
00004Ar 3               KB_CONTROL_RELEASE      = %00000001
00004Ar 3               KB_CONTROL_RELEASE_INV  = %11111110
00004Ar 3               KB_CONTROL_EXTENDED     = %00000010
00004Ar 3               KB_CONTROL_EXTENDED_INV = %11111101
00004Ar 3               KB_CONTROL_SHIFTED      = %10000000
00004Ar 3               KB_CONTROL_SHIFTED_INV  = %01111111
00004Ar 3               
00004Ar 3               .include "keyboard_layout_iso.inc"
00004Ar 4               
00004Ar 4               .rodata
0002A5r 4               ASCIITBL:
0002A5r 4  00                          .byte $00               ; 00 no key pressed
0002A6r 4  89                          .byte $89               ; 01 F9
0002A7r 4  87                          .byte $87               ; 02 relocated F7
0002A8r 4  85                          .byte $85               ; 03 F5
0002A9r 4  83                          .byte $83               ; 04 F3
0002AAr 4  81                          .byte $81               ; 05 F1
0002ABr 4  82                          .byte $82               ; 06 F2
0002ACr 4  8C                          .byte $8C               ; 07 F12
0002ADr 4  00                          .byte $00               ; 08
0002AEr 4  8A                          .byte $8A               ; 09 F10
0002AFr 4  88                          .byte $88               ; 0A F8
0002B0r 4  86                          .byte $86               ; 0B F6
0002B1r 4  84                          .byte $84               ; 0C F4
0002B2r 4  09                          .byte $09               ; 0D tab
0002B3r 4  60                          .byte $60               ; 0E `~
0002B4r 4  8F                          .byte $8F               ; 0F relocated Print Screen key
0002B5r 4  03                          .byte $03               ; 10 relocated Pause/Break key
0002B6r 4  A0                          .byte $A0               ; 11 left alt (right alt too)
0002B7r 4  00                          .byte $00               ; 12 left shift
0002B8r 4  E0                          .byte $E0               ; 13 relocated Alt release code
0002B9r 4  00                          .byte $00               ; 14 left ctrl (right ctrl too)
0002BAr 4  71                          .byte $71               ; 15 qQ
0002BBr 4  31                          .byte $31               ; 16 1!
0002BCr 4  00                          .byte $00               ; 17
0002BDr 4  00                          .byte $00               ; 18
0002BEr 4  00                          .byte $00               ; 19
0002BFr 4  7A                          .byte $7A               ; 1A zZ
0002C0r 4  73                          .byte $73               ; 1B sS
0002C1r 4  61                          .byte $61               ; 1C aA
0002C2r 4  77                          .byte $77               ; 1D wW
0002C3r 4  32                          .byte $32               ; 1E 2@
0002C4r 4  A1                          .byte $A1               ; 1F Windows 98 menu key (left side)
0002C5r 4  02                          .byte $02               ; 20 relocated ctrl-break key
0002C6r 4  63                          .byte $63               ; 21 cC
0002C7r 4  78                          .byte $78               ; 22 xX
0002C8r 4  64                          .byte $64               ; 23 dD
0002C9r 4  65                          .byte $65               ; 24 eE
0002CAr 4  34                          .byte $34               ; 25 4$
0002CBr 4  33                          .byte $33               ; 26 3#
0002CCr 4  A2                          .byte $A2               ; 27 Windows 98 menu key (right side)
0002CDr 4  00                          .byte $00               ; 28
0002CEr 4  20                          .byte $20               ; 29 space
0002CFr 4  76                          .byte $76               ; 2A vV
0002D0r 4  66                          .byte $66               ; 2B fF
0002D1r 4  74                          .byte $74               ; 2C tT
0002D2r 4  72                          .byte $72               ; 2D rR
0002D3r 4  35                          .byte $35               ; 2E 5%
0002D4r 4  A3                          .byte $A3               ; 2F Windows 98 option key (right click, right side)
0002D5r 4  00                          .byte $00               ; 30
0002D6r 4  6E                          .byte $6E               ; 31 nN
0002D7r 4  62                          .byte $62               ; 32 bB
0002D8r 4  68                          .byte $68               ; 33 hH
0002D9r 4  67                          .byte $67               ; 34 gG
0002DAr 4  79                          .byte $79               ; 35 yY
0002DBr 4  36                          .byte $36               ; 36 6^
0002DCr 4  00                          .byte $00               ; 37
0002DDr 4  00                          .byte $00               ; 38
0002DEr 4  00                          .byte $00               ; 39
0002DFr 4  6D                          .byte $6D               ; 3A mM
0002E0r 4  6A                          .byte $6A               ; 3B jJ
0002E1r 4  75                          .byte $75               ; 3C uU
0002E2r 4  37                          .byte $37               ; 3D 7/
0002E3r 4  38                          .byte $38               ; 3E 8(
0002E4r 4  00                          .byte $00               ; 3F
0002E5r 4  00                          .byte $00               ; 40
0002E6r 4  2C                          .byte $2C               ; 41 ,<
0002E7r 4  6B                          .byte $6B               ; 42 kK
0002E8r 4  69                          .byte $69               ; 43 iI
0002E9r 4  6F                          .byte $6F               ; 44 oO
0002EAr 4  30                          .byte $30               ; 45 0=
0002EBr 4  39                          .byte $39               ; 46 9)
0002ECr 4  00                          .byte $00               ; 47
0002EDr 4  00                          .byte $00               ; 48
0002EEr 4  2E                          .byte $2E               ; 49 .>
0002EFr 4  2D                          .byte $2D               ; 4A -_
0002F0r 4  6C                          .byte $6C               ; 4B lL
0002F1r 4  3B                          .byte $3B               ; 4C ;:
0002F2r 4  70                          .byte $70               ; 4D pP
0002F3r 4  2B                          .byte $2B               ; 4E +?
0002F4r 4  00                          .byte $00               ; 4F
0002F5r 4  00                          .byte $00               ; 50
0002F6r 4  00                          .byte $00               ; 51
0002F7r 4  27                          .byte $27               ; 52 '"
0002F8r 4  00                          .byte $00               ; 53
0002F9r 4  5B                          .byte $5B               ; 54 [{
0002FAr 4  3D                          .byte $3D               ; 55 =+
0002FBr 4  00                          .byte $00               ; 56
0002FCr 4  00                          .byte $00               ; 57
0002FDr 4  00                          .byte $00               ; 58 caps
0002FEr 4  00                          .byte $00               ; 59 r shift
0002FFr 4  0A                          .byte $0A               ; 5A <Enter>
000300r 4  5D                          .byte $5D               ; 5B ]}
000301r 4  00                          .byte $00               ; 5C
000302r 4  27                          .byte $27               ; 5D '*
000303r 4  00                          .byte $00               ; 5E
000304r 4  00                          .byte $00               ; 5F
000305r 4  00                          .byte $00               ; 60
000306r 4  00                          .byte $00               ; 61
000307r 4  00                          .byte $00               ; 62
000308r 4  00                          .byte $00               ; 63
000309r 4  00                          .byte $00               ; 64
00030Ar 4  00                          .byte $00               ; 65
00030Br 4  08                          .byte $08               ; 66 bkspace
00030Cr 4  00                          .byte $00               ; 67
00030Dr 4  00                          .byte $00               ; 68
00030Er 4  31                          .byte $31               ; 69 kp 1
00030Fr 4  2F                          .byte $2f               ; 6A kp / converted from E04A in code
000310r 4  34                          .byte $34               ; 6B kp 4
000311r 4  37                          .byte $37               ; 6C kp 7
000312r 4  00                          .byte $00               ; 6D
000313r 4  00                          .byte $00               ; 6E
000314r 4  00                          .byte $00               ; 6F
000315r 4  30                          .byte $30               ; 70 kp 0
000316r 4  2E                          .byte $2E               ; 71 kp .
000317r 4  32                          .byte $32               ; 72 kp 2
000318r 4  35                          .byte $35               ; 73 kp 5
000319r 4  36                          .byte $36               ; 74 kp 6
00031Ar 4  38                          .byte $38               ; 75 kp 8
00031Br 4  1B                          .byte $1B               ; 76 esc
00031Cr 4  00                          .byte $00               ; 77 num lock
00031Dr 4  8B                          .byte $8B               ; 78 F11
00031Er 4  2B                          .byte $2B               ; 79 kp +
00031Fr 4  33                          .byte $33               ; 7A kp 3
000320r 4  2D                          .byte $2D               ; 7B kp -
000321r 4  2A                          .byte $2A               ; 7C kp *
000322r 4  39                          .byte $39               ; 7D kp 9
000323r 4  8D                          .byte $8D               ; 7E scroll lock
000324r 4  00                          .byte $00               ; 7F
000325r 4               ;
000325r 4               ; Table for shifted scancodes
000325r 4               ;
000325r 4  00                          .byte $00               ; 80
000326r 4  C9                          .byte $C9               ; 81 F9
000327r 4  C7                          .byte $C7               ; 82 relocated F7
000328r 4  C5                          .byte $C5               ; 83 F5 (F7 actual scancode=83)
000329r 4  C3                          .byte $C3               ; 84 F3
00032Ar 4  C1                          .byte $C1               ; 85 F1
00032Br 4  C2                          .byte $C2               ; 86 F2
00032Cr 4  CC                          .byte $CC               ; 87 F12
00032Dr 4  00                          .byte $00               ; 88
00032Er 4  CA                          .byte $CA               ; 89 F10
00032Fr 4  C8                          .byte $C8               ; 8A F8
000330r 4  C6                          .byte $C6               ; 8B F6
000331r 4  C4                          .byte $C4               ; 8C F4
000332r 4  09                          .byte $09               ; 8D tab
000333r 4  7E                          .byte $7E               ; 8E `~
000334r 4  CF                          .byte $CF               ; 8F relocated Print Screen key
000335r 4  03                          .byte $03               ; 90 relocated Pause/Break key
000336r 4  A0                          .byte $A0               ; 91 left alt (right alt)
000337r 4  00                          .byte $00               ; 92 left shift
000338r 4  E0                          .byte $E0               ; 93 relocated Alt release code
000339r 4  00                          .byte $00               ; 94 left ctrl (and right ctrl)
00033Ar 4  51                          .byte $51               ; 95 qQ
00033Br 4  21                          .byte $21               ; 96 1!
00033Cr 4  00                          .byte $00               ; 97
00033Dr 4  00                          .byte $00               ; 98
00033Er 4  00                          .byte $00               ; 99
00033Fr 4  5A                          .byte $5A               ; 9A zZ
000340r 4  53                          .byte $53               ; 9B sS
000341r 4  41                          .byte $41               ; 9C aA
000342r 4  57                          .byte $57               ; 9D wW
000343r 4  22                          .byte $22               ; 9E 2"
000344r 4  E1                          .byte $E1               ; 9F Windows 98 menu key (left side)
000345r 4  02                          .byte $02               ; A0 relocated ctrl-break key
000346r 4  43                          .byte $43               ; A1 cC
000347r 4  58                          .byte $58               ; A2 xX
000348r 4  44                          .byte $44               ; A3 dD
000349r 4  45                          .byte $45               ; A4 eE
00034Ar 4  24                          .byte $24               ; A5 4$
00034Br 4  23                          .byte $23               ; A6 3#
00034Cr 4  E2                          .byte $E2               ; A7 Windows 98 menu key (right side)
00034Dr 4  00                          .byte $00               ; A8
00034Er 4  20                          .byte $20               ; A9 space
00034Fr 4  56                          .byte $56               ; AA vV
000350r 4  46                          .byte $46               ; AB fF
000351r 4  54                          .byte $54               ; AC tT
000352r 4  52                          .byte $52               ; AD rR
000353r 4  25                          .byte $25               ; AE 5%
000354r 4  E3                          .byte $E3               ; AF Windows 98 option key (right click, right side)
000355r 4  00                          .byte $00               ; B0
000356r 4  4E                          .byte $4E               ; B1 nN
000357r 4  42                          .byte $42               ; B2 bB
000358r 4  48                          .byte $48               ; B3 hH
000359r 4  47                          .byte $47               ; B4 gG
00035Ar 4  59                          .byte $59               ; B5 yY
00035Br 4  5E                          .byte $5E               ; B6 6^
00035Cr 4  00                          .byte $00               ; B7
00035Dr 4  00                          .byte $00               ; B8
00035Er 4  00                          .byte $00               ; B9
00035Fr 4  4D                          .byte $4D               ; BA mM
000360r 4  4A                          .byte $4A               ; BB jJ
000361r 4  55                          .byte $55               ; BC uU
000362r 4  2F                          .byte $2F               ; BD 7/
000363r 4  28                          .byte $28               ; BE 8(
000364r 4  00                          .byte $00               ; BF
000365r 4  00                          .byte $00               ; C0
000366r 4  3B                          .byte $3B               ; C1 ,;
000367r 4  4B                          .byte $4B               ; C2 kK
000368r 4  49                          .byte $49               ; C3 iI
000369r 4  4F                          .byte $4F               ; C4 oO
00036Ar 4  3D                          .byte $3D               ; C5 0=
00036Br 4  29                          .byte $29               ; C6 9)
00036Cr 4  00                          .byte $00               ; C7
00036Dr 4  00                          .byte $00               ; C8
00036Er 4  3A                          .byte $3A               ; C9 .:
00036Fr 4  5F                          .byte $5F               ; CA -_
000370r 4  4C                          .byte $4C               ; CB lL
000371r 4  3A                          .byte $3A               ; CC ;:
000372r 4  50                          .byte $50               ; CD pP
000373r 4  3F                          .byte $3F               ; CE +?
000374r 4  00                          .byte $00               ; CF
000375r 4  00                          .byte $00               ; D0
000376r 4  00                          .byte $00               ; D1
000377r 4  22                          .byte $22               ; D2 '"
000378r 4  00                          .byte $00               ; D3
000379r 4  7B                          .byte $7B               ; D4 [{
00037Ar 4  2B                          .byte $2B               ; D5 =+
00037Br 4  00                          .byte $00               ; D6
00037Cr 4  00                          .byte $00               ; D7
00037Dr 4  00                          .byte $00               ; D8 caps
00037Er 4  00                          .byte $00               ; D9 r shift
00037Fr 4  0D                          .byte $0D               ; DA <Enter>
000380r 4  7D                          .byte $7D               ; DB ]}
000381r 4  00                          .byte $00               ; DC
000382r 4  2A                          .byte $2A               ; DD '*
000383r 4  00                          .byte $00               ; DE
000384r 4  00                          .byte $00               ; DF
000385r 4  00                          .byte $00               ; E0
000386r 4  00                          .byte $00               ; E1
000387r 4  00                          .byte $00               ; E2
000388r 4  00                          .byte $00               ; E3
000389r 4  00                          .byte $00               ; E4
00038Ar 4  00                          .byte $00               ; E5
00038Br 4  08                          .byte $08               ; E6 bkspace
00038Cr 4  00                          .byte $00               ; E7
00038Dr 4  00                          .byte $00               ; E8
00038Er 4  91                          .byte $91               ; E9 kp 1
00038Fr 4  2F                          .byte $2f               ; EA kp / converted from E04A in code
000390r 4  94                          .byte $94               ; EB kp 4
000391r 4  97                          .byte $97               ; EC kp 7
000392r 4  00                          .byte $00               ; ED
000393r 4  00                          .byte $00               ; EE
000394r 4  00                          .byte $00               ; EF
000395r 4  90                          .byte $90               ; F0 kp 0
000396r 4  7F                          .byte $7F               ; F1 kp .
000397r 4  92                          .byte $92               ; F2 kp 2
000398r 4  95                          .byte $95               ; F3 kp 5
000399r 4  96                          .byte $96               ; F4 kp 6
00039Ar 4  98                          .byte $98               ; F5 kp 8
00039Br 4  1B                          .byte $1B               ; F6 esc
00039Cr 4  00                          .byte $00               ; F7 num lock
00039Dr 4  CB                          .byte $CB               ; F8 F11
00039Er 4  2B                          .byte $2B               ; F9 kp +
00039Fr 4  93                          .byte $93               ; FA kp 3
0003A0r 4  2D                          .byte $2D               ; FB kp -
0003A1r 4  2A                          .byte $2A               ; FC kp *
0003A2r 4  99                          .byte $99               ; FD kp 9
0003A3r 4  CD                          .byte $CD               ; FE scroll lock
0003A4r 4               ; NOT USED     .byte $00               ; FF
0003A4r 4               ; end
0003A4r 4               
0003A4r 3               
0003A4r 3               .SEGMENT "RAM"
000000r 3  xx               kb_byte:                            .res 1
000001r 3                   ; control byte:
000001r 3                   ; bit 0         - release
000001r 3                   ; bit 1         - extended
000001r 3                   ; bit 7         - shifted
000001r 3  xx               kb_control_byte:                    .res 1
000002r 3               
000002r 3               .code
00004Ar 3               
00004Ar 3               InterruptKeyboard:
00004Ar 3               
00004Ar 3  E2 30            shortr
00004Cr 3  AD rr rr         lda VIA1A                               ; read byte from VIA
00004Fr 3  8D rr rr         sta kb_byte
000052r 3               
000052r 3               ; DEBUG SCANCODE
000052r 3                   ; lda #'['
000052r 3                   ; jsl RA8875_WriteChar
000052r 3                   ; lda kb_byte
000052r 3                   ; jsl RA8875_WriteHex
000052r 3                   ; lda #']'
000052r 3                   ; jsl RA8875_WriteChar
000052r 3               
000052r 3                   ; Check control byte first
000052r 3  AD rr rr         lda kb_control_byte
000055r 3  29 01            and #KB_CONTROL_RELEASE
000057r 3  D0 5F            bne keyboardHandleRelease               ; Is release control set?
000059r 3  AD rr rr         lda kb_control_byte
00005Cr 3  29 02            and #KB_CONTROL_EXTENDED
00005Er 3  D0 79            bne keyboardHandleExtended              ; Is extended control set?
000060r 3               
000060r 3               
000060r 3  AD rr rr         lda kb_byte
000063r 3               
000063r 3  20 rr rr         jsr keyboardCommandTest                 ; Test for non printable scan codes
000066r 3  F0 03            beq InterruptKeyboardReturn             ; 0 means key is handled as command
000068r 3               
000068r 3               
000068r 3  20 rr rr         jsr keyboardHandleAscii                 ; Handle as ASCII
00006Br 3               
00006Br 3               InterruptKeyboardReturn:
00006Br 3  2C rr rr         bit VIA1A
00006Er 3               
00006Er 3  60               rts
00006Fr 3               
00006Fr 3               .A8
00006Fr 3               .I8
00006Fr 3               keyboardHandleAscii:
00006Fr 3  AD rr rr         lda kb_control_byte
000072r 3  29 80            and #KB_CONTROL_SHIFTED                 ; Set bit 7 is shifted
000074r 3  0D rr rr         ora kb_byte
000077r 3               
000077r 3  AA               tax
000078r 3  BD rr rr         lda ASCIITBL,x
00007Br 3               
00007Br 3  A2 00            ldx #STREAM_STDIN
00007Dr 3                   ;jsl RA8875_WriteChar                    ; TODO: Do not print here
00007Dr 3  22 rr rr rr      jsl StreamPutC                          ; Put in standard in stream
000081r 3               
000081r 3               
000081r 3               ; DEBUG SINGLE KEY COMMANDS. TODO REMOVE THIS
000081r 3  C9 69            cmp #$69
000083r 3  D0 0E            bne @next1
000085r 3  AD rr rr         lda TaskSwitches+1
000088r 3  22 rr rr rr      jsl RA8875_WriteHex
00008Cr 3  AD rr rr         lda TaskSwitches
00008Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000093r 3               @next1:
000093r 3  C9 6A            cmp #$6A
000095r 3  D0 0E            bne @next2
000097r 3  AD rr rr         lda TimerCounter+1
00009Ar 3  22 rr rr rr      jsl RA8875_WriteHex
00009Er 3  AD rr rr         lda TimerCounter
0000A1r 3  22 rr rr rr      jsl RA8875_WriteHex
0000A5r 3               
0000A5r 3               
0000A5r 3               @next2:
0000A5r 3  C9 6B            cmp #$6B
0000A7r 3  D0 0E            bne @return
0000A9r 3  AD rr rr         lda ClockCounter+1
0000ACr 3  22 rr rr rr      jsl RA8875_WriteHex
0000B0r 3  AD rr rr         lda ClockCounter
0000B3r 3  22 rr rr rr      jsl RA8875_WriteHex
0000B7r 3               ; END DEBUG
0000B7r 3               
0000B7r 3               @return:
0000B7r 3  60               rts
0000B8r 3               
0000B8r 3               keyboardHandleRelease:
0000B8r 3  AD rr rr         lda kb_control_byte
0000BBr 3  29 FE            and #KB_CONTROL_RELEASE_INV
0000BDr 3  8D rr rr         sta kb_control_byte
0000C0r 3                   ; TODO: Toggle released key
0000C0r 3                   ;       Have a map of which keys are pressed
0000C0r 3               
0000C0r 3                   ; TODO Handle control release
0000C0r 3  AD rr rr         lda kb_byte
0000C3r 3  C9 12            cmp #$12                                ; left shift released
0000C5r 3  F0 07            beq kbClearShifted
0000C7r 3  C9 59            cmp #$59                                ; right shift released
0000C9r 3  F0 03            beq kbClearShifted
0000CBr 3               keyboardHandleReleaseCont1:
0000CBr 3  4C rr rr         jmp InterruptKeyboardReturn
0000CEr 3               
0000CEr 3               kbClearShifted:
0000CEr 3  AD rr rr         lda kb_control_byte
0000D1r 3  29 7F            and #KB_CONTROL_SHIFTED_INV
0000D3r 3  8D rr rr         sta kb_control_byte
0000D6r 3  4C rr rr         jmp keyboardHandleReleaseCont1
0000D9r 3               
0000D9r 3               keyboardHandleExtended:
0000D9r 3  AD rr rr         lda kb_control_byte
0000DCr 3  29 FD            and #KB_CONTROL_EXTENDED_INV
0000DEr 3  8D rr rr         sta kb_control_byte
0000E1r 3                   ; TODO: Handle extended key
0000E1r 3  4C rr rr         jmp InterruptKeyboardReturn
0000E4r 3               
0000E4r 3               keyboardCommandTest:
0000E4r 3  A2 04            ldx #$04
0000E6r 3               keyboardCommandTestLoop:
0000E6r 3  DD rr rr         cmp kbcommands,x
0000E9r 3  F0 04            beq keyboardCommandRun
0000EBr 3  CA               dex
0000ECr 3  10 F8            bpl keyboardCommandTestLoop
0000EEr 3  60               rts
0000EFr 3               
0000EFr 3               keyboardCommandRun:
0000EFr 3  8A               txa
0000F0r 3  0A               asl                                 ; *2 to get address from lookup table
0000F1r 3  AA               tax
0000F2r 3  7C rr rr         jmp (kbCommandRoutines,x)           ; Jmp to the command routine
0000F5r 3               
0000F5r 3               kbcommands:
0000F5r 3  12               .byte $12       ; left shift
0000F6r 3  59               .byte $59       ; right shift
0000F7r 3  14               .byte $14       ; left ctrl
0000F8r 3  E0               .byte $E0       ; extended
0000F9r 3  F0               .byte $F0       ; break
0000FAr 3                   ; TODO: Add right control
0000FAr 3               
0000FAr 3               kbCommandRoutines:
0000FAr 3  rr rr            .word kbSetShifted
0000FCr 3  rr rr            .word kbSetShifted
0000FEr 3  rr rr            .word kbnull                        ; TODO: Handle left control
000100r 3  rr rr            .word kbSetExtended
000102r 3  rr rr            .word kbSetBreak
000104r 3               
000104r 3               kbSetExtended:
000104r 3  AD rr rr         lda kb_control_byte
000107r 3  09 02            ora #KB_CONTROL_EXTENDED
000109r 3  8D rr rr         sta kb_control_byte
00010Cr 3  4C rr rr         jmp kbnull
00010Fr 3               
00010Fr 3               kbSetShifted:
00010Fr 3  AD rr rr         lda kb_control_byte
000112r 3  09 80            ora #KB_CONTROL_SHIFTED
000114r 3  8D rr rr         sta kb_control_byte
000117r 3  4C rr rr         jmp kbnull
00011Ar 3               
00011Ar 3               kbSetBreak:
00011Ar 3  AD rr rr         lda kb_control_byte
00011Dr 3  09 01            ora #KB_CONTROL_RELEASE
00011Fr 3  8D rr rr         sta kb_control_byte
000122r 3  4C rr rr         jmp kbnull
000125r 3               
000125r 3               kbnull:
000125r 3  A9 00            lda #$00
000127r 3  60               rts
000128r 3               
000128r 3               ; Initialize Keyboard driver
000128r 3               InitKeyboard:
000128r 3  E2 30            shortr
00012Ar 3  9C rr rr         stz kb_control_byte
00012Dr 3  9C rr rr         stz kb_byte
000130r 3               
000130r 3  9C rr rr         stz VIA1A_DIRECTION             ; read input
000133r 3  A9 82            lda #%10000010
000135r 3  8D rr rr         sta VIA1_IER
000138r 3               
000138r 3  A9 00            lda #$00
00013Ar 3  8D rr rr         sta VIA1_PCR
00013Dr 3  C2 30            longr
00013Fr 3               
00013Fr 3  60               rts
000140r 3               
000140r 3               
000140r 3               
000140r 2               .include "drivers/ra8875/ra8875.asm"     ; include Driver for RA8875
000140r 3               .SEGMENT "KERNEL"
000003r 3  xx xx            string_ptr:                 .res 2
000005r 3  xx xx            cursor_x:                   .res 2
000007r 3  xx xx            cursor_y:                   .res 2
000009r 3               
000009r 3  xx               control_sequence_param_1:   .res 1
00000Ar 3  xx               control_sequence_param_2:   .res 1
00000Br 3               
00000Br 3               .code
000140r 3               .A8
000140r 3               .I8
000140r 3                   .include "ra8875.inc"
000140r 4               SPI_DEVICE_RA8875 = $04
000140r 4               
000140r 4               RA8875_DATAWRITE = $00
000140r 4               RA8875_DATAREAD = $40
000140r 4               RA8875_CMDWRITE = $80
000140r 4               
000140r 4               RA8875_SYSR = $10
000140r 4               RA8875_SYSR_8BPP = $00
000140r 4               RA8875_SYSR_16BPP = $0C
000140r 4               RA8875_SYSR_MCU8 = $00
000140r 4               
000140r 4               RA8875_PLLC1 = $88
000140r 4               RA8875_PLLC1_PLLDIV2 = $80
000140r 4               RA8875_PLLC1_PLLDIV1 = $00
000140r 4               
000140r 4               RA8875_PLLC2 = $89
000140r 4               RA8875_PLLC2_DIV4 = $02
000140r 4               
000140r 4               RA8875_PCSR = $04
000140r 4               RA8875_PCSR_PDATL = $80
000140r 4               RA8875_PCSR_2CLK = $01
000140r 4               
000140r 4               RA8875_HDWR = $14
000140r 4               RA8875_HNDFTR = $15
000140r 4               RA8875_HNDFTR_DE_HIGH = $00
000140r 4               RA8875_HNDR = $16
000140r 4               RA8875_HSTR = $17
000140r 4               RA8875_HPWR = $18
000140r 4               RA8875_HPWR_LOW = $00
000140r 4               
000140r 4               RA8875_VDHR0 = $19
000140r 4               RA8875_VDHR1 = $1A
000140r 4               RA8875_VNDR0 = $1B
000140r 4               RA8875_VNDR1 = $1C
000140r 4               RA8875_VSTR0 = $1D
000140r 4               RA8875_VSTR1 = $1E
000140r 4               RA8875_VPWR = $1F
000140r 4               RA8875_VPWR_LOW = $00
000140r 4               
000140r 4               RA8875_HSAW0 = $30
000140r 4               RA8875_HSAW1 = $31
000140r 4               RA8875_HEAW0 = $34
000140r 4               RA8875_HEAW1 = $35
000140r 4               
000140r 4               RA8875_VSAW0 = $32
000140r 4               RA8875_VSAW1 = $33
000140r 4               RA8875_VEAW0 = $36
000140r 4               RA8875_VEAW1 = $37
000140r 4               
000140r 4               RA8875_FGCR0 = $63
000140r 4               RA8875_FGCR1 = $64
000140r 4               RA8875_FGCR2 = $65
000140r 4               
000140r 4               RA8875_MCLR = $8E
000140r 4               RA8875_MCLR_START = $80
000140r 4               RA8875_MCLR_FULL = $00
000140r 4               
000140r 4               RA8875_PWRR = $01
000140r 4               RA8875_PWRR_NORMAL = $00
000140r 4               RA8875_PWRR_DISPON = $80
000140r 4               
000140r 4               RA8875_P1CR = $8A
000140r 4               RA8875_P1CR_ENABLE = $80
000140r 4               RA8875_PWM_CLK_DIV1024 = $0A
000140r 4               RA8875_PWM_CLK_DIV8 = $03
000140r 4               
000140r 4               RA8875_P1DCR = $8B
000140r 4               
000140r 4               RA8875_MWCR0 = $40
000140r 4               RA8875_MWCR0_TXTMODE = $80
000140r 4               
000140r 4               RA8875_MWCR0_CURSOR = $40
000140r 4               RA8875_MWCR0_BLINK = $20
000140r 4               
000140r 4               RA8875_F_CURXL = $2A
000140r 4               RA8875_F_CURXH = $2B
000140r 4               RA8875_F_CURYL = $2C
000140r 4               RA8875_F_CURYH = $2D
000140r 4               
000140r 4               RA8875_BTCR = $44
000140r 4               
000140r 4               RA8875_FNCR0 = $21
000140r 4               
000140r 4               RA8875_MRWC = $02
000140r 4               
000140r 4               RA8875_GPIOX = $C7
000140r 4               
000140r 4               
000140r 4               RA8875_WIDTH = 800
000140r 4               RA8875_HEIGHT = 480
000140r 4               RA8875_hsync_nondisp = 26
000140r 4               RA8875_hsync_start = 32
000140r 4               RA8875_hsync_pw = 96
000140r 4               RA8875_hsync_finetune = 0
000140r 4               RA8875_vsync_nondisp = 32
000140r 4               RA8875_vsync_start = 23
000140r 4               RA8875_vsync_pw = 2
000140r 4               
000140r 4               RA_1 = $20
000140r 4               RA_2 = $21
000140r 4               
000140r 3               
000140r 3               ; Write Data  destroy A
000140r 3               ; in
000140r 3               ;   A - Data
000140r 3               RA8875WriteData:
000140r 3  48               PHA
000141r 3  A9 04            LDA #SPI_DEVICE_RA8875
000143r 3  20 rr rr         JSR SpiDeviceSelect
000146r 3  A9 00            LDA #RA8875_DATAWRITE
000148r 3  20 rr rr         JSR SpiByte
00014Br 3  68               PLA
00014Cr 3  20 rr rr         JSR SpiByte
00014Fr 3  20 rr rr         JSR SpiDeviceDeselect
000152r 3  60               RTS
000153r 3               
000153r 3               ; Write Command  destroy A
000153r 3               ; in
000153r 3               ;   A - Data
000153r 3               RA8875WriteCommand:
000153r 3  48               PHA
000154r 3  A9 04            LDA #SPI_DEVICE_RA8875
000156r 3  20 rr rr         JSR SpiDeviceSelect
000159r 3  A9 80            LDA #RA8875_CMDWRITE
00015Br 3  20 rr rr         JSR SpiByte
00015Er 3  68               PLA
00015Fr 3  20 rr rr         JSR SpiByte
000162r 3  20 rr rr         JSR SpiDeviceDeselect
000165r 3  60               RTS
000166r 3               
000166r 3               ; Read Command  destroy A
000166r 3               ; in
000166r 3               ;   A - Register to read
000166r 3               ; out
000166r 3               ;   A - Data from register
000166r 3               RA8875ReadCommand:
000166r 3  20 rr rr         JSR RA8875WriteCommand
000169r 3  A9 04            LDA #SPI_DEVICE_RA8875
00016Br 3  20 rr rr         JSR SpiDeviceSelect
00016Er 3  A9 40            LDA #RA8875_DATAREAD
000170r 3  20 rr rr         JSR SpiByte
000173r 3  20 rr rr         JSR SpiByte
000176r 3  20 rr rr         JSR SpiDeviceDeselect
000179r 3  60               RTS
00017Ar 3               
00017Ar 3               ; Initialize the RA8875  destroy AX
00017Ar 3               InitRA8875:
00017Ar 3               
00017Ar 3               ; PLL settings
00017Ar 3  A9 88            LDA #RA8875_PLLC1
00017Cr 3  20 rr rr         JSR RA8875WriteCommand
00017Fr 3  A9 0A            LDA #(RA8875_PLLC1_PLLDIV1+10)
000181r 3  20 rr rr         JSR RA8875WriteData
000184r 3               
000184r 3  20 rr rr         JSR LongDelay
000187r 3               
000187r 3  A9 89            LDA #RA8875_PLLC2
000189r 3  20 rr rr         JSR RA8875WriteCommand
00018Cr 3  A9 02            LDA #RA8875_PLLC2_DIV4
00018Er 3  20 rr rr         JSR RA8875WriteData
000191r 3               
000191r 3  20 rr rr         JSR LongDelay
000194r 3               ; Color mode  MCU size
000194r 3  A9 10            LDA #RA8875_SYSR
000196r 3  20 rr rr         JSR RA8875WriteCommand
000199r 3                   ; For 16 bit color
000199r 3                   ; LDA #(RA8875_SYSR_16BPP | RA8875_SYSR_MCU8)
000199r 3  A9 00            LDA #(RA8875_SYSR_8BPP | RA8875_SYSR_MCU8)
00019Br 3  20 rr rr         JSR RA8875WriteData
00019Er 3               
00019Er 3  20 rr rr         JSR LongDelay
0001A1r 3               
0001A1r 3               ; Pixel clock
0001A1r 3  A9 04            LDA #RA8875_PCSR
0001A3r 3  20 rr rr         JSR RA8875WriteCommand
0001A6r 3  A9 81            LDA #(RA8875_PCSR_PDATL | RA8875_PCSR_2CLK)
0001A8r 3  20 rr rr         JSR RA8875WriteData
0001ABr 3               
0001ABr 3  20 rr rr         JSR LongDelay
0001AEr 3               
0001AEr 3               ; Horizontal settings
0001AEr 3  A9 14            LDA #RA8875_HDWR
0001B0r 3  20 rr rr         JSR RA8875WriteCommand
0001B3r 3  A9 63            LDA #((RA8875_WIDTH / 8) - 1)
0001B5r 3  20 rr rr         JSR RA8875WriteData
0001B8r 3               
0001B8r 3  A9 15            LDA #RA8875_HNDFTR
0001BAr 3  20 rr rr         JSR RA8875WriteCommand
0001BDr 3  A9 00            LDA #(RA8875_HNDFTR_DE_HIGH + RA8875_hsync_finetune)
0001BFr 3  20 rr rr         JSR RA8875WriteData
0001C2r 3               
0001C2r 3  A9 16            LDA #RA8875_HNDR
0001C4r 3  20 rr rr         JSR RA8875WriteCommand
0001C7r 3  A9 03            LDA #((RA8875_hsync_nondisp - RA8875_hsync_finetune - 2) / 8)
0001C9r 3  20 rr rr         JSR RA8875WriteData
0001CCr 3               
0001CCr 3  A9 17            LDA #RA8875_HSTR
0001CEr 3  20 rr rr         JSR RA8875WriteCommand
0001D1r 3  A9 03            LDA #((RA8875_hsync_start / 8) - 1)
0001D3r 3  20 rr rr         JSR RA8875WriteData
0001D6r 3               
0001D6r 3  A9 18            LDA #RA8875_HPWR
0001D8r 3  20 rr rr         JSR RA8875WriteCommand
0001DBr 3  A9 0B            LDA #(RA8875_HPWR_LOW + ((RA8875_hsync_pw / 8) - 1))
0001DDr 3  20 rr rr         JSR RA8875WriteData
0001E0r 3               
0001E0r 3               ; Vertical settings
0001E0r 3  A9 19            LDA #RA8875_VDHR0
0001E2r 3  20 rr rr         JSR RA8875WriteCommand
0001E5r 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
0001E7r 3  20 rr rr         JSR RA8875WriteData
0001EAr 3               
0001EAr 3  A9 1A            LDA #RA8875_VDHR1
0001ECr 3  20 rr rr         JSR RA8875WriteCommand
0001EFr 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
0001F1r 3  20 rr rr         JSR RA8875WriteData
0001F4r 3               
0001F4r 3  A9 1B            LDA #RA8875_VNDR0
0001F6r 3  20 rr rr         JSR RA8875WriteCommand
0001F9r 3  A9 1F            LDA #(RA8875_vsync_nondisp - 1)
0001FBr 3  20 rr rr         JSR RA8875WriteData
0001FEr 3               
0001FEr 3  A9 1C            LDA #RA8875_VNDR1
000200r 3  20 rr rr         JSR RA8875WriteCommand
000203r 3  A9 00            LDA #(RA8875_vsync_nondisp >> 8)
000205r 3  20 rr rr         JSR RA8875WriteData
000208r 3               
000208r 3  A9 1D            LDA #RA8875_VSTR0
00020Ar 3  20 rr rr         JSR RA8875WriteCommand
00020Dr 3  A9 16            LDA #(RA8875_vsync_start - 1)
00020Fr 3  20 rr rr         JSR RA8875WriteData
000212r 3               
000212r 3  A9 1E            LDA #RA8875_VSTR1
000214r 3  20 rr rr         JSR RA8875WriteCommand
000217r 3  A9 00            LDA #(RA8875_vsync_start >> 8)
000219r 3  20 rr rr         JSR RA8875WriteData
00021Cr 3               
00021Cr 3  A9 1F            LDA #RA8875_VPWR
00021Er 3  20 rr rr         JSR RA8875WriteCommand
000221r 3  A9 01            LDA #(RA8875_VPWR_LOW + RA8875_vsync_pw - 1)
000223r 3  20 rr rr         JSR RA8875WriteData
000226r 3               
000226r 3               ; Set active window X
000226r 3               
000226r 3  A9 30            LDA #RA8875_HSAW0
000228r 3  20 rr rr         JSR RA8875WriteCommand
00022Br 3  A9 00            LDA #0
00022Dr 3  20 rr rr         JSR RA8875WriteData
000230r 3               
000230r 3  A9 31            LDA #RA8875_HSAW1
000232r 3  20 rr rr         JSR RA8875WriteCommand
000235r 3  A9 00            LDA #0
000237r 3  20 rr rr         JSR RA8875WriteData
00023Ar 3               
00023Ar 3  A9 34            LDA #RA8875_HEAW0
00023Cr 3  20 rr rr         JSR RA8875WriteCommand
00023Fr 3  A9 1F            LDA #((RA8875_WIDTH - 1) & $FF)
000241r 3  20 rr rr         JSR RA8875WriteData
000244r 3               
000244r 3  A9 35            LDA #RA8875_HEAW1
000246r 3  20 rr rr         JSR RA8875WriteCommand
000249r 3  A9 03            LDA #((RA8875_WIDTH - 1) >> 8)
00024Br 3  20 rr rr         JSR RA8875WriteData
00024Er 3               
00024Er 3               ; Set active window Y
00024Er 3               
00024Er 3  A9 32            LDA #RA8875_VSAW0
000250r 3  20 rr rr         JSR RA8875WriteCommand
000253r 3  A9 00            LDA #0
000255r 3  20 rr rr         JSR RA8875WriteData
000258r 3               
000258r 3  A9 33            LDA #RA8875_VSAW1
00025Ar 3  20 rr rr         JSR RA8875WriteCommand
00025Dr 3  A9 00            LDA #0
00025Fr 3  20 rr rr         JSR RA8875WriteData
000262r 3               
000262r 3  A9 36            LDA #RA8875_VEAW0
000264r 3  20 rr rr         JSR RA8875WriteCommand
000267r 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
000269r 3  20 rr rr         JSR RA8875WriteData
00026Cr 3               
00026Cr 3  A9 37            LDA #RA8875_VEAW1
00026Er 3  20 rr rr         JSR RA8875WriteCommand
000271r 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
000273r 3  20 rr rr         JSR RA8875WriteData
000276r 3               
000276r 3               ; Clear entire screen
000276r 3               
000276r 3  A9 8E            LDA #RA8875_MCLR
000278r 3  20 rr rr         JSR RA8875WriteCommand
00027Br 3  A9 80            LDA #(RA8875_MCLR_START | RA8875_MCLR_FULL)
00027Dr 3  20 rr rr         JSR RA8875WriteData
000280r 3               
000280r 3  20 rr rr         JSR LongDelay
000283r 3               
000283r 3               ; Display on
000283r 3  A9 01            LDA #RA8875_PWRR
000285r 3  20 rr rr         JSR RA8875WriteCommand
000288r 3               
000288r 3  A9 80            LDA #(RA8875_PWRR_NORMAL | RA8875_PWRR_DISPON)
00028Ar 3  20 rr rr         JSR RA8875WriteData
00028Dr 3               
00028Dr 3               ; GPIOX on    enable tft
00028Dr 3  A9 C7            LDA #RA8875_GPIOX
00028Fr 3  20 rr rr         JSR RA8875WriteCommand
000292r 3  A9 01            LDA #1
000294r 3  20 rr rr         JSR RA8875WriteData
000297r 3               
000297r 3               
000297r 3               ; PWM1 Config backlight
000297r 3  A9 8A            LDA #RA8875_P1CR
000299r 3  20 rr rr         JSR RA8875WriteCommand
00029Cr 3  A9 8A            LDA #(RA8875_P1CR_ENABLE | (RA8875_PWM_CLK_DIV1024 & $F))
00029Er 3  20 rr rr         JSR RA8875WriteData
0002A1r 3               
0002A1r 3               ; Backlight clock
0002A1r 3  A9 8B            LDA #RA8875_P1DCR
0002A3r 3  20 rr rr         JSR RA8875WriteCommand
0002A6r 3  A9 FF            LDA #255
0002A8r 3  20 rr rr         JSR RA8875WriteData
0002ABr 3               
0002ABr 3               ; Set text mode
0002ABr 3  20 rr rr         JSR RA8875_TextMode
0002AEr 3               
0002AEr 3  9C rr rr         STZ cursor_x
0002B1r 3               
0002B1r 3  9C rr rr         STZ cursor_x + 1
0002B4r 3               
0002B4r 3  9C rr rr         STZ cursor_y
0002B7r 3               
0002B7r 3  9C rr rr         STZ cursor_y + 1
0002BAr 3               
0002BAr 3  20 rr rr         JSR RA8875_SetTextCursor
0002BDr 3               
0002BDr 3  A9 FF            LDA #$FF
0002BFr 3  20 rr rr         JSR RA8875_SetForegroundColor
0002C2r 3               
0002C2r 3  60               RTS
0002C3r 3               
0002C3r 3               RA8875_CursorBlink:
0002C3r 3               
0002C3r 3  A9 40            LDA #RA8875_MWCR0
0002C5r 3  20 rr rr         JSR RA8875WriteCommand
0002C8r 3               
0002C8r 3  A9 C0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR)
0002CAr 3  20 rr rr         JSR RA8875WriteData
0002CDr 3               
0002CDr 3  A9 40            LDA #RA8875_MWCR0
0002CFr 3  20 rr rr         JSR RA8875WriteCommand
0002D2r 3               
0002D2r 3  A9 E0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR | RA8875_MWCR0_BLINK)
0002D4r 3  20 rr rr         JSR RA8875WriteData
0002D7r 3               
0002D7r 3  A9 44            LDA #RA8875_BTCR
0002D9r 3  20 rr rr         JSR RA8875WriteCommand
0002DCr 3               
0002DCr 3  A9 20            LDA #32                        ; Blink rate 1-255 1 is fast
0002DEr 3  20 rr rr         JSR RA8875WriteData
0002E1r 3               
0002E1r 3  60               RTS
0002E2r 3               
0002E2r 3               RA8875_CursorHide:
0002E2r 3               
0002E2r 3  A9 40            LDA #RA8875_MWCR0
0002E4r 3  20 rr rr         JSR RA8875WriteCommand
0002E7r 3               
0002E7r 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
0002E9r 3  20 rr rr         JSR RA8875WriteData
0002ECr 3               
0002ECr 3  60               RTS
0002EDr 3               
0002EDr 3               RA8875_GetTextCursorX:
0002EDr 3  A9 2B            LDA #RA8875_F_CURXH
0002EFr 3  20 rr rr         JSR RA8875ReadCommand
0002F2r 3  8D rr rr         STA cursor_x+1
0002F5r 3               
0002F5r 3  A9 2A            LDA #RA8875_F_CURXL
0002F7r 3  20 rr rr         JSR RA8875ReadCommand
0002FAr 3  8D rr rr         STA cursor_x
0002FDr 3               
0002FDr 3  60               RTS
0002FEr 3               
0002FEr 3               RA8875_GetTextCursorY:
0002FEr 3  A9 2D            LDA #RA8875_F_CURYH
000300r 3  20 rr rr         JSR RA8875ReadCommand
000303r 3  8D rr rr         STA cursor_y+1
000306r 3               
000306r 3  A9 2C            LDA #RA8875_F_CURYL
000308r 3  20 rr rr         JSR RA8875ReadCommand
00030Br 3  8D rr rr         STA cursor_y
00030Er 3               
00030Er 3  60               RTS
00030Fr 3               
00030Fr 3               RA8875_SetTextCursor:
00030Fr 3  A9 2A            LDA #RA8875_F_CURXL
000311r 3  20 rr rr         JSR RA8875WriteCommand
000314r 3  AD rr rr         LDA cursor_x
000317r 3  20 rr rr         JSR RA8875WriteData
00031Ar 3               
00031Ar 3  A9 2B            LDA #RA8875_F_CURXH
00031Cr 3  20 rr rr         JSR RA8875WriteCommand
00031Fr 3  AD rr rr         LDA cursor_x+1
000322r 3  20 rr rr         JSR RA8875WriteData
000325r 3               
000325r 3               
000325r 3  A9 2C            LDA #RA8875_F_CURYL
000327r 3  20 rr rr         JSR RA8875WriteCommand
00032Ar 3  AD rr rr         LDA cursor_y
00032Dr 3  20 rr rr         JSR RA8875WriteData
000330r 3               
000330r 3  A9 2D            LDA #RA8875_F_CURYH
000332r 3  20 rr rr         JSR RA8875WriteCommand
000335r 3  AD rr rr         LDA cursor_y+1
000338r 3  20 rr rr         JSR RA8875WriteData
00033Br 3               
00033Br 3  60               RTS
00033Cr 3               
00033Cr 3               .A8
00033Cr 3               .I8
00033Cr 3               RA8875_TextMode:
00033Cr 3  A9 40            LDA #RA8875_MWCR0
00033Er 3  20 rr rr         JSR RA8875WriteCommand
000341r 3               
000341r 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
000343r 3  20 rr rr         JSR RA8875WriteData
000346r 3               
000346r 3               ; select internal font
000346r 3  A9 21            LDA #RA8875_FNCR0
000348r 3  20 rr rr         JSR RA8875WriteCommand
00034Br 3               
00034Br 3  A9 00            LDA #0
00034Dr 3  20 rr rr         JSR RA8875WriteData
000350r 3               
000350r 3  60               RTS
000351r 3               
000351r 3               RA8875_SetForegroundColor:
000351r 3  48               PHA
000352r 3  48               PHA
000353r 3                       ; writeCommand(0x63);
000353r 3                       ; writeData((foreColor & 0xf800) >> 11);
000353r 3                       ; writeCommand(0x64);
000353r 3                       ; writeData((foreColor & 0x07e0) >> 5);
000353r 3                       ; writeCommand(0x65);
000353r 3                       ; writeData((foreColor & 0x001f));
000353r 3  A9 65            LDA #RA8875_FGCR2
000355r 3  20 rr rr         JSR RA8875WriteCommand
000358r 3               
000358r 3  68               PLA
000359r 3  20 rr rr         JSR RA8875WriteData
00035Cr 3               
00035Cr 3  A9 64            LDA #RA8875_FGCR1
00035Er 3  20 rr rr         JSR RA8875WriteCommand
000361r 3               
000361r 3  68               PLA
000362r 3  4A               lsr
000363r 3  4A               lsr
000364r 3  48               PHA
000365r 3               
000365r 3  20 rr rr         JSR RA8875WriteData
000368r 3               
000368r 3  A9 63            LDA #RA8875_FGCR0
00036Ar 3  20 rr rr         JSR RA8875WriteCommand
00036Dr 3               
00036Dr 3  68               PLA
00036Er 3               
00036Er 3  4A               lsr
00036Fr 3  4A               lsr
000370r 3  4A               lsr
000371r 3               
000371r 3  20 rr rr         JSR RA8875WriteData
000374r 3  60               RTS
000375r 3               
000375r 3               ; Handle a single char
000375r 3               RA8875_SingleChar:
000375r 3  C9 20            CMP #$20                        ; $20 or greater
000377r 3  B0 18            BCS RA8875_WriteStringChar      ; then print character
000379r 3  C9 0A            CMP #$0A                        ; Compare to 0x0A   line feed
00037Br 3  D0 04            BNE @check_1                    ; != 0x0A
00037Dr 3  20 rr rr         JSR RA8875_ControlLineFeed      ; Handle as line feed
000380r 3  60               rts                             ; Do not print
000381r 3               @check_1:
000381r 3  C9 0D            CMP #$0D                         ; Compare to 0D   carriage return
000383r 3  D0 04            BNE @check_2                      ; != 0x0D
000385r 3  20 rr rr         JSR RA8875_ControlCarriageReturn ; handle as carriage return
000388r 3  60               rts                             ; Do not print
000389r 3               @check_2:
000389r 3  C9 1B            CMP #$1B                         ; Compare to 1B   escape
00038Br 3  D0 04            BNE RA8875_WriteStringChar       ; != 0x1B
00038Dr 3  20 rr rr         JSR RA8875_ControlEscape         ; handle as escape sequence
000390r 3  60               rts                             ; Do not print
000391r 3               
000391r 3               RA8875_WriteStringChar:
000391r 3  20 rr rr         JSR RA8875WriteData
000394r 3  60               RTS
000395r 3               
000395r 3               RA8875_ControlLineFeed:
000395r 3  9C rr rr         STZ cursor_x                    ; Control char LINE FEED
000398r 3  9C rr rr         STZ cursor_x+1
00039Br 3  20 rr rr         JSR RA8875_GetTextCursorY
00039Er 3  18               CLC
00039Fr 3  69 10            ADC #16
0003A1r 3  8D rr rr         STA cursor_y
0003A4r 3  AD rr rr         LDA cursor_y+1
0003A7r 3  69 00            ADC #$00
0003A9r 3  8D rr rr         STA cursor_y+1
0003ACr 3                   ; TODO: It overflows here. Needs two bytes to handle cursor value
0003ACr 3  20 rr rr         JSR RA8875_SetTextCursor
0003AFr 3  A9 02            LDA #RA8875_MRWC
0003B1r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
0003B4r 3  60               RTS
0003B5r 3               
0003B5r 3               RA8875_ControlCarriageReturn:
0003B5r 3  9C rr rr         STZ cursor_x                    ; Control char LINE FEED
0003B8r 3  9C rr rr         STZ cursor_x+1
0003BBr 3  20 rr rr         JSR RA8875_GetTextCursorY
0003BEr 3  20 rr rr         JSR RA8875_SetTextCursor
0003C1r 3  A9 02            LDA #RA8875_MRWC
0003C3r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
0003C6r 3  60               RTS
0003C7r 3               
0003C7r 3               RA8875_ControlEscape:
0003C7r 3  C8               INY                             ; Look at next character
0003C8r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003CAr 3  F0 2C            BEQ SkipControl
0003CCr 3  C9 5B            CMP #$5B                        ; CSI look for [
0003CEr 3  D0 28            BNE SkipControl
0003D0r 3  C8               INY                             ; Next char
0003D1r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003D3r 3               
0003D3r 3  C9 33            CMP #$33
0003D5r 3  D0 1B            BNE @not_foreground
0003D7r 3  C8               INY                             ; Next char
0003D8r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003DAr 3  C9 37            CMP #$37
0003DCr 3  D0 08            BNE @nextcol1
0003DEr 3  A9 FF            LDA #%11111111
0003E0r 3  20 rr rr         jsr RA8875_SetForegroundColor
0003E3r 3  4C rr rr         jmp @done
0003E6r 3               @nextcol1:
0003E6r 3  C9 32            CMP #$32
0003E8r 3  D0 08            BNE @nextcol2
0003EAr 3  A9 1C            LDA #%00011100
0003ECr 3  20 rr rr         jsr RA8875_SetForegroundColor
0003EFr 3  4C rr rr         jmp @done
0003F2r 3               @nextcol2:
0003F2r 3               
0003F2r 3               @not_foreground:
0003F2r 3               
0003F2r 3               
0003F2r 3               @done:
0003F2r 3  C8               INY
0003F3r 3               
0003F3r 3  98               tya
0003F4r 3  22 rr rr rr      jsl RA8875_WriteHex
0003F8r 3               
0003F8r 3               
0003F8r 3               SkipControl:
0003F8r 3  60               RTS
0003F9r 3               
0003F9r 2               .include "drivers/ra8875/ra8875_api.asm" ; include API for RA8875
0003F9r 3               .A16
0003F9r 3               .I16
0003F9r 3               RA8875_WriteString16_ARG = 8
0003F9r 3               RA8875_WriteString16:
0003F9r 3  5A               PHY
0003FAr 3  DA               PHX
0003FBr 3  E2 30            shortr
0003FDr 3  A0 00            LDY #$00
0003FFr 3  A9 02            LDA #RA8875_MRWC
000401r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
000404r 3               RA8875_WriteString16_0:
000404r 3  B3 08            LDA (RA8875_WriteString16_ARG,s),Y
000406r 3  F0 06            BEQ RA8875_WriteStringEnd16       ; Is char 0 then end write
000408r 3               
000408r 3  20 rr rr         JSR RA8875_SingleChar           ; Handle single character
00040Br 3               
00040Br 3  C8               INY
00040Cr 3  D0 F6            BNE RA8875_WriteString16_0
00040Er 3               RA8875_WriteStringEnd16:
00040Er 3  C2 30            longr
000410r 3  FA               PLX
000411r 3  7A               PLY
000412r 3  6B               RTL
000413r 3               
000413r 3               .A8
000413r 3               .I8
000413r 3               RA8875_WriteChar:
000413r 3  DA               PHX
000414r 3  F0 0A            BEQ RA8875_WriteCharEnd         ; Is char 0 then end write
000416r 3  48               PHA
000417r 3  A9 02            LDA #RA8875_MRWC
000419r 3  20 rr rr         JSR RA8875WriteCommand
00041Cr 3  68               PLA
00041Dr 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
000420r 3               RA8875_WriteCharEnd:
000420r 3  FA               PLX
000421r 3  6B               RTL
000422r 3               
000422r 3               .A16
000422r 3               .I16
000422r 3               RA8875_WriteChar16:
000422r 3  F0 12            BEQ RA8875_WriteChar16End         ; Is char 0 then end write
000424r 3  48               PHA
000425r 3  E2 30            shortr
000427r 3  A9 02            LDA #RA8875_MRWC
000429r 3  20 rr rr         JSR RA8875WriteCommand
00042Cr 3  C2 30            longr
00042Er 3  68               PLA
00042Fr 3  E2 30            shortr
000431r 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
000434r 3  C2 30            longr
000436r 3               RA8875_WriteChar16End:
000436r 3  6B               RTL
000437r 3               
000437r 3               .A8
000437r 3               .I8
000437r 3               RA8875_WriteNumber:
000437r 3  A2 FF            LDX #$FF
000439r 3  38               SEC                             ; Prepare for subtraction
00043Ar 3               RA8875_WriteNumber100:
00043Ar 3  E8               INX
00043Br 3  E9 64            SBC #100
00043Dr 3  B0 FB            BCS RA8875_WriteNumber100       ; Count how many 100s
00043Fr 3  69 64            ADC #100
000441r 3  20 rr rr         JSR RA8875_WriteDigit           ; Print the 100s
000444r 3  A2 FF            LDX #$FF
000446r 3  38               SEC                             ; Prepare for subtraction
000447r 3               RA8875_WriteNumber10:
000447r 3  E8               INX
000448r 3  E9 0A            SBC #10
00044Ar 3  B0 FB            BCS RA8875_WriteNumber10         ; Count how many 10s
00044Cr 3  69 0A            ADC #10
00044Er 3  20 rr rr         JSR RA8875_WriteDigit            ; Print the 10s
000451r 3  AA               TAX                              ; Pass 1s into X
000452r 3               RA8875_WriteDigit:
000452r 3  48               PHA
000453r 3  8A               TXA                             ; Save A pass digit to A
000454r 3  09 30            ORA #$30                        ; ASCII 0
000456r 3  22 rr rr rr      JSL RA8875_WriteChar            ; Convert to character and print it
00045Ar 3  68               PLA
00045Br 3  60               RTS                             ; Restore A and return
00045Cr 3               
00045Cr 3               .A8
00045Cr 3               .I8
00045Cr 3               RA8875_WriteHex:
00045Cr 3  48               PHA                     ; Save A for LSD.
00045Dr 3  4A               LSR
00045Er 3  4A               LSR
00045Fr 3  4A               LSR                     ; MSD to LSD position.
000460r 3  4A               LSR
000461r 3  22 rr rr rr      JSL RA8875_WriteHex1    ; Output hex digit.
000465r 3  68               PLA                     ; Restore A.
000466r 3               RA8875_WriteHex1:
000466r 3  DA               PHX
000467r 3  48               PHA
000468r 3  18               CLC
000469r 3  29 0F            AND #$0F                ; Mask LSD for hex print.
00046Br 3  09 30            ORA #$30                ; Add "0".
00046Dr 3  C9 3A            CMP #$3A                ; Digit?
00046Fr 3  90 02            BCC RA8875_WriteHex2    ; Yes, output it.
000471r 3  69 06            ADC #$06                ; Add offset for letter.
000473r 3               RA8875_WriteHex2:
000473r 3  22 rr rr rr      JSL RA8875_WriteChar
000477r 3  68               PLA
000478r 3  FA               PLX
000479r 3  6B               RTL                    ; Return.
00047Ar 3               
00047Ar 3               .A16
00047Ar 3               .I16
00047Ar 3               RA8875_WriteHex16:
00047Ar 3  E2 30            shortr
00047Cr 3  EB               xba                     ; switch high and low A
00047Dr 3  22 rr rr rr      jsl RA8875_WriteHex     ; print first byte
000481r 3  EB               xba                     ; switch high and low A
000482r 3  22 rr rr rr      jsl RA8875_WriteHex     ; print second byte
000486r 3  C2 30            longr
000488r 3  6B               RTL
000489r 3               
000489r 3               
000489r 3               
000489r 3               ; CURSOR
000489r 3               
000489r 3               
000489r 3               .A16
000489r 3               .I16
000489r 3               ; takes 16 bit value in A and sets as cursor X
000489r 3               RA8875_SetTextCursorX:
000489r 3  78               SEI
00048Ar 3  48               PHA
00048Br 3  48               PHA
00048Cr 3  E2 30        shortr
00048Er 3  A9 2A            LDA #RA8875_F_CURXL
000490r 3  20 rr rr         JSR RA8875WriteCommand
000493r 3  C2 30        longr
000495r 3  68               PLA
000496r 3  E2 30        shortr
000498r 3  20 rr rr         JSR RA8875WriteData
00049Br 3               
00049Br 3  A9 2B            LDA #RA8875_F_CURXH
00049Dr 3  20 rr rr         JSR RA8875WriteCommand
0004A0r 3  C2 30        longr
0004A2r 3  68               PLA
0004A3r 3  EB               XBA
0004A4r 3  E2 30        shortr
0004A6r 3  20 rr rr         JSR RA8875WriteData
0004A9r 3  C2 30        longr
0004ABr 3  58               CLI
0004ACr 3  6B               RTL
0004ADr 3               
0004ADr 3               
0004ADr 3               .A16
0004ADr 3               .I16
0004ADr 3               RA8875_SetTextCursorY:
0004ADr 3  78               SEI
0004AEr 3  48               PHA
0004AFr 3  48               PHA
0004B0r 3  E2 30        shortr
0004B2r 3  A9 2C            LDA #RA8875_F_CURYL
0004B4r 3  20 rr rr         JSR RA8875WriteCommand
0004B7r 3  C2 30        longr
0004B9r 3  68               PLA
0004BAr 3  E2 30        shortr
0004BCr 3  20 rr rr         JSR RA8875WriteData
0004BFr 3               
0004BFr 3  A9 2D            LDA #RA8875_F_CURYH
0004C1r 3  20 rr rr         JSR RA8875WriteCommand
0004C4r 3  C2 30        longr
0004C6r 3  68               PLA
0004C7r 3  EB               XBA
0004C8r 3  E2 30        shortr
0004CAr 3  20 rr rr         JSR RA8875WriteData
0004CDr 3  C2 30        longr
0004CFr 3  58               CLI
0004D0r 3  6B               RTL
0004D1r 3               
0004D1r 2               
0004D1r 2               .include "ramtest.asm"
0004D1r 3               .RODATA
0003A4r 3               
0003A4r 3  52 75 6E 6E  ram_test_start: .asciiz "Running ram test"
0003A8r 3  69 6E 67 20  
0003ACr 3  72 61 6D 20  
0003B5r 3               
0003B5r 3               
0003B5r 3               .code
0004D1r 3               .A16
0004D1r 3               .I16
0004D1r 3               RamTestRun:
0004D1r 3  78 F4 rr rr      write ram_test_start
0004D5r 3  22 rr rr rr  
0004D9r 3  68 58        
0004DBr 3               
0004DBr 3  E2 30            shortr
0004DDr 3               ; Single cell at $0300
0004DDr 3  A9 42            LDA #$42
0004DFr 3  8D 00 03         STA $0300
0004E2r 3  A9 00            LDA #$00
0004E4r 3  AD 00 03         LDA $0300
0004E7r 3  C9 42            CMP #$42
0004E9r 3  D0 40            BNE RamTestFail
0004EBr 3               ; Single cell at $0300
0004EBr 3  A9 66            LDA #$66
0004EDr 3  8D 98 98         STA $9898
0004F0r 3  A9 00            LDA #$00
0004F2r 3  AD 98 98         LDA $9898
0004F5r 3  C9 66            CMP #$66
0004F7r 3  D0 32            BNE RamTestFail
0004F9r 3               
0004F9r 3               ; All of zero page
0004F9r 3  A2 00            ldx #0                ;ZP location index
0004FBr 3  8A               txa                   ;initialize
0004FCr 3  38               sec                   ;test "bit"
0004FDr 3               
0004FDr 3               loop0010:
0004FDr 3  95 00            sta $00,x             ;clear test cell
0004FFr 3  A0 09            ldy #9                ;bit shift iterations
000501r 3               
000501r 3               loop0020:
000501r 3  36 00            rol $00,x             ;rotate away
000503r 3  88               dey                   ;step counter
000504r 3  D0 FB            bne loop0020          ;not done
000506r 3               
000506r 3  90 23            bcc RamTestFail       ;RAM defective...abort
000508r 3               
000508r 3  B5 00            lda $0,x              ;any "stuck" bits?
00050Ar 3  D0 1F            bne RamTestFail       ;yes, bad RAM...abort
00050Cr 3               
00050Cr 3  E8               inx                   ;we done?
00050Dr 3  D0 EE            bne loop0010          ;no, do next
00050Fr 3               
00050Fr 3  C2 30            longr
000511r 3  78 F4 rr rr      write ok_string
000515r 3  22 rr rr rr  
000519r 3  68 58        
00051Br 3               
00051Br 3  A9 00 00         lda #$00
00051Er 3  A2 00 00         ldx #$0000
000521r 3               @loop:
000521r 3  9D 00 A0         sta $A000,x
000524r 3               
000524r 3  E8               inx
000525r 3  E0 00 10         cpx #$1000
000528r 3  D0 F7            bne @loop
00052Ar 3               
00052Ar 3  6B               RTL
00052Br 3               
00052Br 3               
00052Br 3               RamTestFail:
00052Br 3  C2 30            longr
00052Dr 3  78 F4 rr rr      write fail_string
000531r 3  22 rr rr rr  
000535r 3  68 58        
000537r 3  6B               RTL
000538r 3               
000538r 2               .include "ramtest_wide.asm"
000538r 3               .RODATA
0003B5r 3               
0003B5r 3  52 75 6E 6E  ram_test_start_wide: .asciiz "Running wide ram test"
0003B9r 3  69 6E 67 20  
0003BDr 3  77 69 64 65  
0003CBr 3  2E 00        ram_test_progress: .asciiz "."
0003CDr 3  31 36 20 62  bit16_registers: .asciiz "16 bit registers"
0003D1r 3  69 74 20 72  
0003D5r 3  65 67 69 73  
0003DEr 3               
0003DEr 3               .code
000538r 3               .A16
000538r 3               .I16
000538r 3               RamTestWideRun:
000538r 3               
000538r 3  78 F4 rr rr      write ram_test_start_wide
00053Cr 3  22 rr rr rr  
000540r 3  68 58        
000542r 3               
000542r 3  E2 30            shortr
000544r 3  A9 42            LDA #$42
000546r 3  8F 34 12 01      STA $011234
00054Ar 3  A9 11            LDA #$11
00054Cr 3  AF 34 12 01      LDA $011234
000550r 3  C9 42            CMP #$42
000552r 3  D0 31            BNE RamTestFailWide
000554r 3  A9 F6            LDA #$F6
000556r 3  8F 34 12 02      STA $021234
00055Ar 3  AF 34 12 01      LDA $011234
00055Er 3  C9 42            CMP #$42
000560r 3  D0 23            BNE RamTestFailWide
000562r 3  AF 34 12 02      LDA $021234
000566r 3  C9 F6            CMP #$F6
000568r 3  D0 1B            BNE RamTestFailWide
00056Ar 3  A9 55            LDA #$55
00056Cr 3  8F 34 12 03      STA $031234
000570r 3  AF 34 12 01      LDA $011234
000574r 3  C9 42            CMP #$42
000576r 3  D0 0D            BNE RamTestFailWide
000578r 3               
000578r 3  C2 30            longr
00057Ar 3  78 F4 rr rr      write ok_string
00057Er 3  22 rr rr rr  
000582r 3  68 58        
000584r 3  60               rts
000585r 3               
000585r 3               RamTestFailWide:
000585r 3  C2 30            longr
000587r 3  78 F4 rr rr      write fail_string
00058Br 3  22 rr rr rr  
00058Fr 3  68 58        
000591r 3  60               rts
000592r 3               
000592r 3               .A16
000592r 3               .I16
000592r 3               RamTestWideRegistersRun:
000592r 3               
000592r 3  78 F4 rr rr      write bit16_registers
000596r 3  22 rr rr rr  
00059Ar 3  68 58        
00059Cr 3               
00059Cr 3  A9 34 12         LDA #$1234
00059Fr 3  8F 00 04 04      STA $040400
0005A3r 3  A9 76 98         LDA #$9876
0005A6r 3  AF 00 04 04      LDA $040400
0005AAr 3  C9 34 12         CMP #$1234
0005ADr 3  D0 D6            BNE RamTestFailWide
0005AFr 3               
0005AFr 3  78 F4 rr rr      write ok_string
0005B3r 3  22 rr rr rr  
0005B7r 3  68 58        
0005B9r 3               
0005B9r 3  60               rts
0005BAr 3               
0005BAr 2               
0005BAr 2               .A8
0005BAr 2               .I8
0005BAr 2               InitBIOS:
0005BAr 2  20 rr rr         JSR InitSPI
0005BDr 2  20 rr rr         JSR InitRA8875
0005C0r 2  20 rr rr         JSR InitKeyboard
0005C3r 2               
0005C3r 2               
0005C3r 2               ; switch out of emulation mode
0005C3r 2  18               clc
0005C4r 2  FB               xce
0005C5r 2               
0005C5r 2  C2 30            longr
0005C7r 2                   ;pea test_bios
0005C7r 2                   ;jsl RA8875_WriteString16
0005C7r 2                   ;pla
0005C7r 2               
0005C7r 2                   ;shortr
0005C7r 2                   ;LDA #%01101111
0005C7r 2                   ;jsr RA8875_SetForegroundColor
0005C7r 2                   ;longr
0005C7r 2               
0005C7r 2               
0005C7r 2                   ;write welcome_logo1
0005C7r 2                   ;write welcome_logo2
0005C7r 2                   ;write welcome_logo3
0005C7r 2                   ;write welcome_logo4
0005C7r 2                   ;write welcome_logo5
0005C7r 2                   ;write welcome_logo6
0005C7r 2                   ;write welcome_logo7
0005C7r 2               
0005C7r 2                   ;lda #$0A
0005C7r 2                   ;jsl RA8875_WriteChar16
0005C7r 2               
0005C7r 2                   ;shortr
0005C7r 2                   ;LDA #%11111111
0005C7r 2                   ;jsr RA8875_SetForegroundColor
0005C7r 2                   ;longr
0005C7r 2               
0005C7r 2  22 rr rr rr      JSL RamTestRun
0005CBr 2               
0005CBr 2               
0005CBr 2               
0005CBr 2                   ; jsr RamTestWideRegistersRun
0005CBr 2                   ; jsr RamTestWideRun
0005CBr 2               
0005CBr 2                   ;shortr
0005CBr 2                   ;LDA #%00011100
0005CBr 2                   ;jsr RA8875_SetForegroundColor
0005CBr 2  C2 30            longr
0005CDr 2               
0005CDr 2  78 F4 rr rr      write bios_init
0005D1r 2  22 rr rr rr  
0005D5r 2  68 58        
0005D7r 2  78 F4 rr rr      write ok_string
0005DBr 2  22 rr rr rr  
0005DFr 2  68 58        
0005E1r 2               
0005E1r 2                   ;shortr
0005E1r 2                   ;LDA #%11111111
0005E1r 2                   ;jsr RA8875_SetForegroundColor
0005E1r 2                   ;longr
0005E1r 2               
0005E1r 2  78 F4 rr rr      write ansi_string
0005E5r 2  22 rr rr rr  
0005E9r 2  68 58        
0005EBr 2               
0005EBr 2  E2 30            shortr
0005EDr 2  60               RTS
0005EEr 2               
0005EEr 1               .include "kernel/kernel.asm"
0005EEr 2               
0005EEr 2               .include "tasks.asm"
0005EEr 3               NUMBER_OF_TASKS = 16
0005EEr 3               
0005EEr 3               TASK_STATUS_NONE = 0
0005EEr 3               TASK_STATUS_RUNNING = 1
0005EEr 3               TASK_STATUS_RUNNABLE = 2
0005EEr 3               TASK_STATUS_EXITED = 6          ; everything above this can be taken by a new task
0005EEr 3               TASK_STATUS_KILLED = 7
0005EEr 3               
0005EEr 3               TASK_EXIT_CODE_KILLED = 7
0005EEr 3               
0005EEr 3               .include "scheduler.asm"
0005EEr 4               ; IRQ steps
0005EEr 4               ; Push to the stack:
0005EEr 4               ;
0005EEr 4               ;   PB  - Program Bank           - 1 byte
0005EEr 4               ;   PCH - Program Counter High   - 1 byte
0005EEr 4               ;   PCL - Program Counter Low    - 1 byte
0005EEr 4               ;   SR  - Status Register        - 1 byte
0005EEr 4               ;
0005EEr 4               ; PB set to $00
0005EEr 4               
0005EEr 4               
0005EEr 4               ; Stacks and direct page
0005EEr 4               ; 0000-00FF : kernel direct page
0005EEr 4               ; 0100-01FF : kernel stack
0005EEr 4               
0005EEr 4               ; 9000-90FF : task 0  - direct
0005EEr 4               ; A000-A0FF : task 0  - stack
0005EEr 4               ; 9F00-9FFF : task 16 - direct
0005EEr 4               ; AF00-AFFF : task 16 - stack
0005EEr 4               
0005EEr 4               
0005EEr 4               ; NOT USED! THIS IS A TEST:
0005EEr 4               ; 0000-00FF : kernel direct page
0005EEr 4               ; 0100-01FF : kernel stack
0005EEr 4               ; 0200-02FF : task 1 DP
0005EEr 4               ; 0300-03FF : task 1 stack
0005EEr 4               
0005EEr 4               ; B000-C000 : I/O
0005EEr 4               InterruptStackY = 3+1
0005EEr 4               InterruptStackX = InterruptStackY+2
0005EEr 4               InterruptStackA = InterruptStackX+2
0005EEr 4               InterruptDP = InterruptStackA+2
0005EEr 4               InterruptDB = InterruptDP+2
0005EEr 4               InterruptStatusRegister = InterruptDB+1
0005EEr 4               InterruptPC = InterruptStatusRegister+1
0005EEr 4               InterruptPB = InterruptPC+2
0005EEr 4               
0005EEr 4               .SEGMENT "KERNEL"
00000Br 4               
00000Br 4  xx           SchedulerCount: .res 1
00000Cr 4               
00000Cr 4  xx xx        TimerCounter: .res 2
00000Er 4  xx xx        TaskSwitches: .res 2
000010r 4               
000010r 4  xx           TempStackReturnBank: .res 1
000011r 4  xx xx        TempStackReturnPC: .res 2
000013r 4               
000013r 4               .code
0005EEr 4               
0005EEr 4               
0005EEr 4               
0005EEr 4               .A8
0005EEr 4               .I8
0005EEr 4               Scheduler_NextTask:
0005EEr 4  78               sei
0005EFr 4               
0005EFr 4  AE rr rr         ldx ActiveTask
0005F2r 4               
0005F2r 4  BD rr rr         lda TaskStatus,x
0005F5r 4  C9 01            cmp #TASK_STATUS_RUNNING
0005F7r 4  D0 4E            bne @loop
0005F9r 4               
0005F9r 4  A9 02            lda #TASK_STATUS_RUNNABLE               ; if running then set to runnable
0005FBr 4  9D rr rr         sta TaskStatus,x
0005FEr 4               
0005FEr 4               ; save current task stage
0005FEr 4                   ;longr
0005FEr 4                   ;write task_save_old
0005FEr 4                   ;write test_string
0005FEr 4                   ;shortr
0005FEr 4               
0005FEr 4                   ;ldx ActiveTask
0005FEr 4                   ;txa
0005FEr 4                   ;jsl RA8875_WriteHex
0005FEr 4                   ;lda #' '
0005FEr 4                   ;jsl RA8875_WriteChar
0005FEr 4                   ;lda #$A
0005FEr 4                   ;jsl RA8875_WriteChar
0005FEr 4                   ;lda #'o'
0005FEr 4                   ;jsl RA8875_WriteChar
0005FEr 4                   ;longr
0005FEr 4                   ;jsl DumpStack
0005FEr 4                   ;shortr
0005FEr 4                   ;ldx ActiveTask
0005FEr 4               
0005FEr 4  A3 0C            lda InterruptDB,s
000600r 4  9D rr rr         sta TaskDataBank,x
000603r 4               
000603r 4  A3 10            lda InterruptPB,s
000605r 4  9D rr rr         sta TaskProgramBank,x
000608r 4               
000608r 4  A3 0D            lda InterruptStatusRegister,s
00060Ar 4  9D rr rr         sta TaskStatusRegister,x
00060Dr 4               
00060Dr 4               
00060Dr 4               
00060Dr 4                   ;ldx ActiveTask
00060Dr 4  8A               txa
00060Er 4  0A               asl
00060Fr 4  AA               tax
000610r 4               
000610r 4               ; SAVE STACK POINTER
000610r 4  C2 20            longa
000612r 4  3B               tsc                                 ; A = stack pointer
000613r 4  18               clc
000614r 4  69 10 00         adc #InterruptPB                 ; A = stack pointer - ...
000617r 4  9D rr rr         sta TaskStackPointer,x
00061Ar 4  E2 20            shorta
00061Cr 4               
00061Cr 4                   ; lda TaskStackPointer+1,x
00061Cr 4                   ; jsl RA8875_WriteHex
00061Cr 4                   ; lda #' '
00061Cr 4                   ; jsl RA8875_WriteChar
00061Cr 4                   ; lda TaskStackPointer,x
00061Cr 4                   ; jsl RA8875_WriteHex
00061Cr 4                   ; lda #' '
00061Cr 4                   ; jsl RA8875_WriteChar
00061Cr 4               
00061Cr 4  A3 08            lda InterruptStackA,s
00061Er 4  9D rr rr         sta TaskA,x
000621r 4  A3 09            lda InterruptStackA+1,s
000623r 4  9D rr rr         sta TaskA+1,x
000626r 4  A3 06            lda InterruptStackX,s
000628r 4  9D rr rr         sta TaskX,x
00062Br 4  A3 07            lda InterruptStackX+1,s
00062Dr 4  9D rr rr         sta TaskX+1,x
000630r 4  A3 04            lda InterruptStackY,s
000632r 4  9D rr rr         sta TaskY,x
000635r 4  A3 05            lda InterruptStackY+1,s
000637r 4  9D rr rr         sta TaskY+1,x
00063Ar 4               
00063Ar 4               
00063Ar 4  A3 0E            lda InterruptPC,s
00063Cr 4  9D rr rr         sta TaskProgramPointer,x
00063Fr 4               
00063Fr 4                   ;jsl RA8875_WriteHex
00063Fr 4                   ;lda #' '
00063Fr 4                   ;jsl RA8875_WriteChar
00063Fr 4               
00063Fr 4  A3 0F            lda InterruptPC+1,s
000641r 4  9D rr rr         sta TaskProgramPointer+1,x
000644r 4               
000644r 4                   ;jsl RA8875_WriteHex
000644r 4                   ;lda #$A
000644r 4                   ;jsl RA8875_WriteChar
000644r 4               
000644r 4  AE rr rr         ldx ActiveTask
000647r 4               @loop:
000647r 4  E8               inx
000648r 4  E0 10            cpx #NUMBER_OF_TASKS
00064Ar 4  D0 05            bne @fine
00064Cr 4  A2 FF            ldx #$FF     ; will roll to 0 on inx
00064Er 4  4C rr rr         jmp @loop
000651r 4               @fine:
000651r 4               
000651r 4  BD rr rr         lda TaskStatus,x
000654r 4               
000654r 4  F0 F1            beq @loop
000656r 4               
000656r 4  C9 02            cmp #TASK_STATUS_RUNNABLE
000658r 4  F0 1E            beq @task_switch
00065Ar 4  C9 01            cmp #TASK_STATUS_RUNNING
00065Cr 4  F0 17            beq @goreturn
00065Er 4               
00065Er 4  22 rr rr rr      jsl RA8875_WriteHex
000662r 4  8A               txa
000663r 4  22 rr rr rr      jsl RA8875_WriteHex
000667r 4  C2 30            longr
000669r 4  78 F4 rr rr      write task_unknown_status
00066Dr 4  22 rr rr rr  
000671r 4  68 58        
000673r 4  E2 30            shortr
000675r 4               @goreturn:
000675r 4  4C rr rr         jmp @return
000678r 4               
000678r 4               @task_switch:
000678r 4               
000678r 4               
000678r 4               ; SWITCH TO NEW TASK
000678r 4               
000678r 4  8E rr rr         stx ActiveTask
00067Br 4               
00067Br 4                ;   lda #$A
00067Br 4                ;   jsl RA8875_WriteChar
00067Br 4                ;   lda #'s'
00067Br 4               ;    jsl RA8875_WriteChar
00067Br 4               ;    longr
00067Br 4               ;    jsl DumpStack
00067Br 4               ;    shortr
00067Br 4               
00067Br 4               
00067Br 4                   ;longr
00067Br 4                   ;write task_switching_task
00067Br 4                   ;shortr
00067Br 4               
00067Br 4                   ;ldx ActiveTask
00067Br 4                   ;txa
00067Br 4                   ;jsl RA8875_WriteHex
00067Br 4                   ;lda #' '
00067Br 4                   ;jsl RA8875_WriteChar
00067Br 4               
00067Br 4                   ;ldx ActiveTask
00067Br 4               
00067Br 4  A9 01            lda #TASK_STATUS_RUNNING               ; if running then set to runnable
00067Dr 4  9D rr rr         sta TaskStatus,x
000680r 4               
000680r 4  A3 01            lda 1,s
000682r 4  8D rr rr         sta TempStackReturnPC+1
000685r 4  A3 02            lda 2,s
000687r 4  8D rr rr         sta TempStackReturnPC
00068Ar 4  A3 03            lda 3,s
00068Cr 4  8D rr rr         sta TempStackReturnBank
00068Fr 4               ; Set up stack
00068Fr 4  8A               txa
000690r 4  0A               asl
000691r 4  AA               tax
000692r 4  C2 30            longr
000694r 4  BD rr rr         lda TaskStackPointer,x
000697r 4  18               clc
000698r 4  E9 10 00         sbc #InterruptPB
00069Br 4  1B               tcs
00069Cr 4  E2 30            shortr
00069Er 4               
00069Er 4  AD rr rr         lda TempStackReturnPC+1
0006A1r 4  83 01            sta 1,s
0006A3r 4  AD rr rr         lda TempStackReturnPC
0006A6r 4  83 02            sta 2,s
0006A8r 4  AD rr rr         lda TempStackReturnBank
0006ABr 4  83 03            sta 3,s
0006ADr 4               
0006ADr 4  AE rr rr         ldx ActiveTask
0006B0r 4               
0006B0r 4  BD rr rr         lda TaskProgramBank,x
0006B3r 4  83 10            sta InterruptPB,s
0006B5r 4               
0006B5r 4  BD rr rr         lda TaskDataBank,x
0006B8r 4  83 0C            sta InterruptDB,s
0006BAr 4               
0006BAr 4  BD rr rr         lda TaskStatusRegister,x
0006BDr 4  83 0D            sta InterruptStatusRegister,s
0006BFr 4               
0006BFr 4  8A               txa
0006C0r 4  0A               asl
0006C1r 4  AA               tax
0006C2r 4               ; Set Direct Page to $9x00
0006C2r 4  AD rr rr         lda ActiveTask
0006C5r 4               
0006C5r 4  18               clc
0006C6r 4  69 90            adc #$90                                ; A = $9x
0006C8r 4               
0006C8r 4  83 0B            sta InterruptDP+1,s
0006CAr 4               
0006CAr 4               ; Set registers
0006CAr 4  BD rr rr         lda TaskA,x
0006CDr 4  83 08            sta InterruptStackA,s
0006CFr 4  BD rr rr         lda TaskA+1,x
0006D2r 4  83 09            sta InterruptStackA+1,s
0006D4r 4  BD rr rr         lda TaskY,x
0006D7r 4  83 04            sta InterruptStackY,s
0006D9r 4  BD rr rr         lda TaskY+1,x
0006DCr 4  83 05            sta InterruptStackY+1,s
0006DEr 4  BD rr rr         lda TaskX,x
0006E1r 4  83 06            sta InterruptStackX,s
0006E3r 4  BD rr rr         lda TaskX+1,x
0006E6r 4  83 07            sta InterruptStackX+1,s
0006E8r 4               
0006E8r 4               
0006E8r 4  BD rr rr         lda TaskProgramPointer+1,x
0006EBr 4  83 0F            sta InterruptPC+1,s
0006EDr 4                   ;jsl RA8875_WriteHex
0006EDr 4               
0006EDr 4  BD rr rr         lda TaskProgramPointer,x
0006F0r 4  83 0E            sta InterruptPC,s
0006F2r 4                   ;jsl RA8875_WriteHex
0006F2r 4               
0006F2r 4                   ;lda #$A
0006F2r 4                   ;jsl RA8875_WriteChar
0006F2r 4               
0006F2r 4                   ;lda #'n'
0006F2r 4                   ;jsl RA8875_WriteChar
0006F2r 4                   ;longr
0006F2r 4                   ;jsl DumpStack
0006F2r 4                   ;shortr
0006F2r 4                   ;lda #$A
0006F2r 4                   ;jsl RA8875_WriteChar
0006F2r 4  4C rr rr         jmp @return
0006F5r 4               
0006F5r 4               
0006F5r 4               @return:
0006F5r 4               
0006F5r 4               
0006F5r 4  58               cli
0006F6r 4  6B               rtl
0006F7r 4               
0006F7r 4               
0006F7r 4               .A16
0006F7r 4               .I16
0006F7r 4               InitScheduler:
0006F7r 4               
0006F7r 4  9C rr rr         stz TimerCounter        ; set interrupt timer counter to 0
0006FAr 4  9C rr rr         stz TaskSwitches        ; set task switch count to 0
0006FDr 4               
0006FDr 4               ; should be approx 256 times per second
0006FDr 4  A9 A8 26         lda #9896
000700r 4  8D rr rr         sta VIA1_T1CL
000703r 4               
000703r 4  E2 30            shortr
000705r 4  AD rr rr         lda  VIA1_ACR       ; Clear the ACR's bit that
000708r 4  29 7F            AND  #%01111111      ; tells T1 to toggle PB7 upon time-out, and
00070Ar 4  09 40            ORA  #%01000000      ; set the bit that tells T1 to automatically
00070Cr 4  8D rr rr         STA  VIA1_ACR       ; produce an interrupt at every time-out and
00070Fr 4                                       ; just reload from the latches and keep going.
00070Fr 4  A9 C0            LDA  #%11000000
000711r 4  8D rr rr         STA  VIA1_IER       ; Enable the T1 interrupt in the VIA.
000714r 4               
000714r 4  C2 30            longr
000716r 4  60               rts
000717r 4               
000717r 3               .include "tasks.inc"
000717r 4               
000717r 4               .RODATA
0003DEr 4               
0003DEr 4  4E 6F 20 66  task_no_free_slot:           .asciiz "No free task slot!\n"
0003E2r 4  72 65 65 20  
0003E6r 4  74 61 73 6B  
0003F2r 4  55 6E 6B 6E  task_unknown_status:           .asciiz "Unknown task status!\n"
0003F6r 4  6F 77 6E 20  
0003FAr 4  74 61 73 6B  
000408r 4  4E 65 77 3A  task_switching_task:           .asciiz "New: "
00040Cr 4  20 00        
00040Er 4  4F 6C 64 3A  task_save_old:               .asciiz "Old: "
000412r 4  20 00        
000414r 4               
000414r 3               
000414r 3               .SEGMENT "KERNEL"
000013r 3               
000013r 3  xx           KernelSp: .res 1
000014r 3  xx           ActiveTask: .res 1
000015r 3  xx xx xx xx  TaskStatus: .res NUMBER_OF_TASKS
000019r 3  xx xx xx xx  
00001Dr 3  xx xx xx xx  
000025r 3  xx xx xx xx  TaskExitCode: .res NUMBER_OF_TASKS
000029r 3  xx xx xx xx  
00002Dr 3  xx xx xx xx  
000035r 3  xx xx xx xx  TaskStackPointer: .res NUMBER_OF_TASKS * 2
000039r 3  xx xx xx xx  
00003Dr 3  xx xx xx xx  
000055r 3  xx xx xx xx  TaskDataBank: .res NUMBER_OF_TASKS
000059r 3  xx xx xx xx  
00005Dr 3  xx xx xx xx  
000065r 3  xx xx xx xx  TaskProgramBank: .res NUMBER_OF_TASKS
000069r 3  xx xx xx xx  
00006Dr 3  xx xx xx xx  
000075r 3  xx xx xx xx  TaskProgramPointer: .res NUMBER_OF_TASKS * 2
000079r 3  xx xx xx xx  
00007Dr 3  xx xx xx xx  
000095r 3  xx xx xx xx  TaskStatusRegister: .res NUMBER_OF_TASKS
000099r 3  xx xx xx xx  
00009Dr 3  xx xx xx xx  
0000A5r 3  xx xx xx xx  TaskA: .res NUMBER_OF_TASKS * 2
0000A9r 3  xx xx xx xx  
0000ADr 3  xx xx xx xx  
0000C5r 3  xx xx xx xx  TaskX: .res NUMBER_OF_TASKS * 2
0000C9r 3  xx xx xx xx  
0000CDr 3  xx xx xx xx  
0000E5r 3  xx xx xx xx  TaskY: .res NUMBER_OF_TASKS * 2
0000E9r 3  xx xx xx xx  
0000EDr 3  xx xx xx xx  
000105r 3               
000105r 3               
000105r 3               .code
000717r 3               
000717r 3               ; Initialize tasks
000717r 3               .A16
000717r 3               .I16
000717r 3               InitTasks:
000717r 3  E2 30                shortr
000719r 3  A2 10                ldx #NUMBER_OF_TASKS
00071Br 3                   @clrloop:
00071Br 3  CA                   dex
00071Cr 3  9E rr rr             stz TaskStatus,x
00071Fr 3  9E rr rr             stz TaskExitCode,x
000722r 3  9E rr rr             stz TaskStatusRegister,x
000725r 3  9E rr rr             stz TaskProgramBank,x
000728r 3  9E rr rr             stz TaskDataBank,x
00072Br 3  C2 30                longr
00072Dr 3  9E rr rr             stz TaskStackPointer, x
000730r 3  9E rr rr             stz TaskProgramPointer, x
000733r 3  9E rr rr             stz TaskA, x
000736r 3  9E rr rr             stz TaskX, x
000739r 3  9E rr rr             stz TaskY, x
00073Cr 3  E2 30                shortr
00073Er 3  D0 DB            bne @clrloop
000740r 3               
000740r 3  A9 FF                lda #$FF
000742r 3  8D rr rr             sta ActiveTask
000745r 3               
000745r 3  C2 30                longr
000747r 3  60                   rts
000748r 3               
000748r 3               
000748r 3               
000748r 3               ; Spawn a new task
000748r 3               TaskSpawnArg_Addr = 1+3+6      ; jsl 3 bytes return
000748r 3               .A16
000748r 3               .I16
000748r 3               TaskSpawn:
000748r 3  48                   pha
000749r 3  DA                   phx
00074Ar 3  5A                   phy
00074Br 3  E2 30                shortr
00074Dr 3  20 rr rr             jsr TaskFindUnusedTask
000750r 3  B0 3C                bcs @no_unused_tasks
000752r 3               
000752r 3                       ;txa
000752r 3                       ;jsl RA8875_WriteHex
000752r 3               
000752r 3  9E rr rr             stz TaskExitCode,x
000755r 3               
000755r 3  A9 02                lda #TASK_STATUS_RUNNABLE
000757r 3  9D rr rr             sta TaskStatus,x
00075Ar 3               
00075Ar 3  A3 0C                lda TaskSpawnArg_Addr+2,s
00075Cr 3  9D rr rr             sta TaskProgramBank,x
00075Fr 3               
00075Fr 3  8A                   txa
000760r 3  A8                   tay
000761r 3  0A                   asl
000762r 3  AA                   tax
000763r 3  98                   tya
000764r 3  18                   clc
000765r 3  69 A0                adc #$A0
000767r 3  9D rr rr             sta TaskStackPointer+1,x
00076Ar 3  A9 FF                lda #$FF
00076Cr 3  9D rr rr             sta TaskStackPointer,x            ; Stack pointer: $AxFF
00076Fr 3               
00076Fr 3               
00076Fr 3  A3 0A                lda TaskSpawnArg_Addr,s
000771r 3  9D rr rr             sta TaskProgramPointer,x
000774r 3               
000774r 3  A3 0B                lda TaskSpawnArg_Addr+1,s
000776r 3  9D rr rr             sta TaskProgramPointer+1,x
000779r 3               
000779r 3               
000779r 3  9E rr rr             stz TaskA,x
00077Cr 3  9E rr rr             stz TaskA+1,x
00077Fr 3  9E rr rr             stz TaskY,x
000782r 3  9E rr rr             stz TaskY+1,x
000785r 3  9E rr rr             stz TaskX,x
000788r 3  9E rr rr             stz TaskX+1,x
00078Br 3               
00078Br 3               
00078Br 3  4C rr rr             jmp @return
00078Er 3               
00078Er 3                   @no_unused_tasks:
00078Er 3  C2 30                longr
000790r 3  78 F4 rr rr          write task_no_free_slot
000794r 3  22 rr rr rr  
000798r 3  68 58        
00079Ar 3  4C rr rr             jmp @return
00079Dr 3                   @return:
00079Dr 3  C2 30                longr
00079Fr 3  7A                   ply
0007A0r 3  FA                   plx
0007A1r 3  68                   pla
0007A2r 3  6B                   rtl
0007A3r 3               
0007A3r 3               
0007A3r 3               
0007A3r 3               ; Find task slot not used. First try to find a slot with status 0
0007A3r 3               ; if none with status 0 is found then find a exited or killed slot
0007A3r 3               ; input: n/a
0007A3r 3               ; output:
0007A3r 3               ;   x - slot number that's empty
0007A3r 3               ;   carry set if error
0007A3r 3               .A8
0007A3r 3               .I8
0007A3r 3               TaskFindUnusedTask:
0007A3r 3  18                   clc
0007A4r 3  48                   pha
0007A5r 3  A2 00                ldx #0
0007A7r 3                   @loop:
0007A7r 3  BD rr rr             lda TaskStatus,x
0007AAr 3  F0 14                beq @return
0007ACr 3  E8                   inx
0007ADr 3  E0 10                cpx #NUMBER_OF_TASKS         ; Reach end of tasks list?
0007AFr 3  D0 F6                bne @loop
0007B1r 3                   ; No slot found. Try one killed or exited
0007B1r 3  A2 00                ldx #$0
0007B3r 3                   @loop2:
0007B3r 3  BD rr rr             lda TaskStatus,x
0007B6r 3  C9 06                cmp #TASK_STATUS_EXITED
0007B8r 3  B0 06                bcs @return
0007BAr 3  E8                   inx
0007BBr 3  E0 10                cpx #NUMBER_OF_TASKS
0007BDr 3  D0 F4                bne @loop2
0007BFr 3  38                   sec                         ; reached the end the second time.
0007C0r 3                                                   ; no slots available. return with carry set
0007C0r 3                   @return:
0007C0r 3  68                   pla
0007C1r 3  60                   rts
0007C2r 3               
0007C2r 3               
0007C2r 3               
0007C2r 3               ; Mark current task as exited. Go into nop-loop until
0007C2r 3               ; next task is chosen by scheduler
0007C2r 3               ; input:
0007C2r 3               ;   A - exit code
0007C2r 3               ; output: n/a
0007C2r 3               .A16
0007C2r 3               .I16
0007C2r 3               TaskExit:
0007C2r 3  AE rr rr             ldx ActiveTask
0007C5r 3               
0007C5r 3  9D rr rr             sta TaskExitCode,x              ; store the exit code
0007C8r 3               
0007C8r 3  A9 06 00             lda #TASK_STATUS_EXITED
0007CBr 3  9D rr rr             sta TaskStatus,x                ; mark the task as exited
0007CEr 3               
0007CEr 3                       @loop:                          ; go into infinite loop
0007CEr 3  EA                       nop                         ; until scheduler picks
0007CFr 3  4C rr rr                 jmp @loop                   ; the next task
0007D2r 3               
0007D2r 3               
0007D2r 3               
0007D2r 3               ; exit task from outside the task itself
0007D2r 3               ; input:
0007D2r 3               ;   x - task number to kill
0007D2r 3               ; output: n/a
0007D2r 3               .A16
0007D2r 3               .I16
0007D2r 3               TaskKill:
0007D2r 3  A9 07 00             lda #TASK_STATUS_KILLED
0007D5r 3  9D rr rr             sta TaskStatus,x
0007D8r 3  9D rr rr             sta TaskExitCode,x
0007DBr 3               
0007DBr 3  6B                   rtl
0007DCr 3               
0007DCr 2               .include "interrupt.asm"
0007DCr 3               .code
0007DCr 3               .A16
0007DCr 3               .I16
0007DCr 3               InterruptVector:
0007DCr 3  8B               phb                   ;save DB - data bank
0007DDr 3  0B               phd                   ;save DP - direct page
0007DEr 3  C2 30            longr                 ;select 16 bit registers
0007E0r 3  48               pha                   ;save .C
0007E1r 3  DA               phx                   ;save .X
0007E2r 3  5A               phy                   ;save .Y
0007E3r 3               
0007E3r 3  E2 30            shortr
0007E5r 3               
0007E5r 3  AD rr rr         lda VIA1_IFR
0007E8r 3  2D rr rr         and VIA1_IER            ; zero those that were not allowed to pull IRQ down.
0007EBr 3  0A               asl ; timer 1
0007ECr 3  30 0A            bmi  InterruptTimer1
0007EEr 3  0A               asl ; timer 2
0007EFr 3  0A               asl ; cb1
0007F0r 3  0A               asl ; cb2
0007F1r 3  0A               asl ; shift reg
0007F2r 3  0A               asl ; ca1
0007F3r 3               
0007F3r 3  30 2A            bmi InterruptKB
0007F5r 3               
0007F5r 3               
0007F5r 3               
0007F5r 3  4C rr rr         jmp crti
0007F8r 3               
0007F8r 3               InterruptTimer1:
0007F8r 3  2C rr rr         bit VIA1_T1CL
0007FBr 3  EE rr rr         inc TimerCounter
0007FEr 3  D0 03            BNE @lowcnt    ; Branch to end if the low byte didn't roll over to 00.
000800r 3  EE rr rr         inc TimerCounter+1
000803r 3               @lowcnt:
000803r 3  EE rr rr         inc SchedulerCount
000806r 3  AD rr rr         lda SchedulerCount
000809r 3  C9 06            cmp #$06
00080Br 3  D0 0F            bne @noschedule
00080Dr 3  9C rr rr         stz SchedulerCount
000810r 3  EE rr rr         inc TaskSwitches
000813r 3  D0 03            BNE @lowcntSwitch    ; Branch to end if the low byte didn't roll over to 00.
000815r 3  EE rr rr         inc TaskSwitches+1
000818r 3               @lowcntSwitch:
000818r 3  22 rr rr rr      jsl Scheduler_NextTask
00081Cr 3               @noschedule:
00081Cr 3               
00081Cr 3  4C rr rr         jmp crti
00081Fr 3               
00081Fr 3               InterruptKB:
00081Fr 3  20 rr rr         jsr InterruptKeyboard
000822r 3               
000822r 3               crti:
000822r 3  C2 30            longr
000824r 3  7A               ply                   ;restore .Y
000825r 3  FA               plx                   ;restore .X
000826r 3  68               pla                   ;restore .C
000827r 3  2B               pld                   ;restore DP
000828r 3  AB               plb                   ;restore DB
000829r 3  40               rti                   ;resume foreground task
00082Ar 3               
00082Ar 2               .include "streams.asm"
00082Ar 3               
00082Ar 3               NUMBER_OF_STREAMS = 3           ; Number of streams
00082Ar 3               SIZE_OF_STREAM = 16             ; Number of bytes per stream
00082Ar 3               
00082Ar 3               STREAM_STDIN = 0
00082Ar 3               
00082Ar 3               .SEGMENT "KERNEL"
000105r 3               
000105r 3               StreamLookupHead:
000105r 3  xx xx xx         .res NUMBER_OF_STREAMS
000108r 3               StreamLookupTail:
000108r 3  xx xx xx         .res NUMBER_OF_STREAMS
00010Br 3               StreamData:
00010Br 3  xx xx xx xx      .res SIZE_OF_STREAM * NUMBER_OF_STREAMS
00010Fr 3  xx xx xx xx  
000113r 3  xx xx xx xx  
00013Br 3               
00013Br 3               .code
00082Ar 3               
00082Ar 3               ; Initialize streams
00082Ar 3               ; Zeroes out head, tail, data
00082Ar 3               .A16
00082Ar 3               .I16
00082Ar 3               InitStreams:
00082Ar 3  E2 30            shortr
00082Cr 3  A2 03            ldx #NUMBER_OF_STREAMS
00082Er 3               @clrloop:
00082Er 3  CA               dex
00082Fr 3  9E rr rr         stz StreamLookupHead, x
000832r 3  9E rr rr         stz StreamLookupTail, x
000835r 3               
000835r 3  D0 F7            bne @clrloop
000837r 3  A2 10            ldx #SIZE_OF_STREAM
000839r 3               @clrloop2:
000839r 3  CA               dex
00083Ar 3  9E rr rr         stz StreamData, x
00083Dr 3  9E rr rr         stz StreamData+SIZE_OF_STREAM, x
000840r 3  9E rr rr         stz StreamData+SIZE_OF_STREAM+SIZE_OF_STREAM, x
000843r 3               
000843r 3               
000843r 3  D0 F4            bne @clrloop2
000845r 3               
000845r 3  C2 30            longr
000847r 3  60               rts
000848r 3               
000848r 3               ; Put byte to stream
000848r 3               ; in:
000848r 3               ;   A - byte to put
000848r 3               ;   X - stream id
000848r 3               ; out:
000848r 3               .A8
000848r 3               .I8
000848r 3               StreamPutC:
000848r 3  48               pha
000849r 3  78               sei
00084Ar 3  BC rr rr         ldy StreamLookupTail,x      ; fetch current tail
00084Dr 3  5A               phy                         ; stack: [tail]
00084Er 3               
00084Er 3  BC rr rr         ldy StreamLookupHead,x      ; fetch current head
000851r 3  5A               phy                         ; stack: [tail, head]
000852r 3               
000852r 3  DA               phx                         ; stack: [tail, head, stream id]
000853r 3  48               pha                         ; stack: [tail, head, stream id, A-byte]
000854r 3  8A               txa
000855r 3               
000855r 3  0A               asl                         ; *  2
000856r 3  0A               asl                         ; *  4
000857r 3  0A               asl                         ; *  8
000858r 3  0A               asl                         ; * 16
000859r 3  63 03            adc 3,s                     ; + head_offset
00085Br 3  AA               tax                         ; X = X * 16 + head_offset
00085Cr 3               
00085Cr 3  68               pla                         ; stack: [tail, head, stream id], a = A-byte
00085Dr 3               
00085Dr 3  9D rr rr         sta StreamData,x            ; Store byte in stream
000860r 3               
000860r 3               ; increment head_offset
000860r 3  FA               plx                         ; stack: [tail, head], x=stream id
000861r 3  7A               ply                         ; stack: [tail], y = head
000862r 3  C8               iny                         ; increment head
000863r 3  98               tya
000864r 3               
000864r 3  C9 10            cmp #SIZE_OF_STREAM         ; head overflow?
000866r 3  D0 02            bne @checktail
000868r 3  A9 00            lda #0
00086Ar 3               @checktail:
00086Ar 3  9D rr rr         sta StreamLookupHead,x      ; store head
00086Dr 3               
00086Dr 3               ; this is untested.
00086Dr 3               ; if the stream wraps around
00086Dr 3  C3 01            cmp 1,s                     ; is head == stack[1]/tail?
00086Fr 3  D0 09            bne @tailnothead
000871r 3  7A               ply                         ; if yes increment tail
000872r 3  C8               iny
000873r 3  98               tya
000874r 3  9D rr rr         sta StreamLookupTail,x
000877r 3  4C rr rr         jmp @done
00087Ar 3               
00087Ar 3               
00087Ar 3               @tailnothead:
00087Ar 3  FA               plx ; clear tail from stack. not used pt
00087Br 3               @done:
00087Br 3  58               cli
00087Cr 3  68               pla
00087Dr 3  6B               rtl
00087Er 3               
00087Er 3               ; Get byte from stream
00087Er 3               ; in:
00087Er 3               ;   X - stream id
00087Er 3               ; out:
00087Er 3               ;   A: read byte
00087Er 3               ;       0: nothing
00087Er 3               ;       x: read byte
00087Er 3               .A8
00087Er 3               .I8
00087Er 3               StreamGetC:
00087Er 3  78               sei
00087Fr 3  BD rr rr         lda StreamLookupTail,x
000882r 3  DD rr rr         cmp StreamLookupHead,x
000885r 3  D0 05            bne @readc                  ; tail !== head
000887r 3  A9 00            lda #0                      ; set A to 0 (nothing read)
000889r 3  4C rr rr         jmp @done
00088Cr 3               @readc:
00088Cr 3               
00088Cr 3  48               pha                         ; s:[tail]
00088Dr 3  18               clc
00088Er 3  69 01            adc #1                      ; tail = tail + 1
000890r 3  C9 10            cmp #SIZE_OF_STREAM         ; tail === 16?
000892r 3  D0 02            bne @savetail               ; if not skip next
000894r 3  A9 00            lda #0                      ; tail = 0
000896r 3               @savetail:
000896r 3  9D rr rr         sta StreamLookupTail,x      ; save tail
000899r 3               
000899r 3  8A               txa
00089Ar 3               
00089Ar 3  0A               asl                         ; *  2
00089Br 3  0A               asl                         ; *  4
00089Cr 3  0A               asl                         ; *  8
00089Dr 3  0A               asl                         ; * 16
00089Er 3  63 01            adc 1,s                     ; + tail_offset
0008A0r 3  AA               tax                         ; X = X * 16 + tail_offset
0008A1r 3  7A               ply                         ; s:[]
0008A2r 3               
0008A2r 3  BD rr rr         lda StreamData,x
0008A5r 3               
0008A5r 3               @done:
0008A5r 3  58               cli
0008A6r 3  6B               rtl
0008A7r 3               
0008A7r 2               .include "syscalls.asm"
0008A7r 3               .I8
0008A7r 3               .A8
0008A7r 3               Sys_GetPID:
0008A7r 3  AD rr rr         LDA ActiveTask
0008AAr 3  6B               RTL
0008ABr 3               
0008ABr 2               
0008ABr 2               .A16
0008ABr 2               .I16
0008ABr 2               InitKernel:
0008ABr 2  20 rr rr         jsr InitTasks
0008AEr 2                   ;write init_kernel_tasks_done
0008AEr 2  20 rr rr         jsr InitScheduler
0008B1r 2                   ;write init_kernel_scheduler_done
0008B1r 2  20 rr rr         jsr InitStreams
0008B4r 2                   ;write init_kernel_streams_done
0008B4r 2                   ;write init_kernel_done
0008B4r 2  60               rts
0008B5r 2               ;;;
0008B5r 2               ; Long Delay
0008B5r 2               ;;;
0008B5r 2               
0008B5r 2               .A8
0008B5r 2               .I8
0008B5r 2               LongDelay:
0008B5r 2  A2 FF            ldx #$FF
0008B7r 2               LongDelayLoop1:
0008B7r 2  A0 FF            ldy #$FF
0008B9r 2               LongDelayLoop2:
0008B9r 2  88               dey
0008BAr 2  D0 FD            bne LongDelayLoop2
0008BCr 2  CA               dex
0008BDr 2  D0 F8            bne LongDelayLoop1
0008BFr 2  60               rts
0008C0r 2               
0008C0r 2               ;;;
0008C0r 2               ; Delay
0008C0r 2               ;;;
0008C0r 2               .A8
0008C0r 2               .I8
0008C0r 2               Delay:
0008C0r 2  A2 FF            ldx #$FF
0008C2r 2               DelayLoop1:
0008C2r 2  A0 FF            ldy #$FF
0008C4r 2               DelayLoop2:
0008C4r 2  88               dey
0008C5r 2  D0 FD            bne DelayLoop2
0008C7r 2  CA               dex
0008C8r 2  D0 F8            bne DelayLoop1
0008CAr 2  60               rts
0008CBr 2               
0008CBr 2               ;;;
0008CBr 2               ; Short Delay
0008CBr 2               ;;;
0008CBr 2               .A8
0008CBr 2               .I8
0008CBr 2  A2 AA        DelayShort:	ldx #$aa
0008CDr 2               DelayShortLoop1:
0008CDr 2  CA           	dex
0008CEr 2  D0 FD            bne DelayShortLoop1
0008D0r 2  60               rts
0008D1r 2               
0008D1r 1               
0008D1r 1               
0008D1r 1               .include "stdlib/stdlib.asm"
0008D1r 2               .include "stdlib.inc"
0008D1r 3               Std_StrLen = 1
0008D1r 3               Std_ReadNum = 2
0008D1r 3               Std_StrCompareUntilWhiteSpace = 3
0008D1r 3               
0008D1r 2               
0008D1r 2               .SEGMENT "STDLIB"
000000r 2               
000000r 2               StdLib:
000000r 2  C2 30            longr
000002r 2  48               pha
000003r 2  DA               phx
000004r 2  5A               phy
000005r 2               
000005r 2  29 FF 00         and #$00FF
000008r 2  3A               dec a                           ; 0 index function number
000009r 2  0A               asl a                           ; double function number to match words
00000Ar 2               
00000Ar 2  E2 30            shortr
00000Cr 2  AA               tax
00000Dr 2               
00000Dr 2  7C rr rr         jmp (StdLibTable,x)
000010r 2               
000010r 2               
000010r 2               StdLibTable:
000010r 2  rr rr            .word Stdlib_StrLen
000012r 2  rr rr            .word Stdlib_ReadNum
000014r 2  rr rr            .word StdLib_StrCompareUntilWhiteSpace
000016r 2               
000016r 2               
000016r 2               .include "strings.asm"
000016r 3               .RODATA
000414r 3  53 74 72 4C  	strlen: .asciiz "StrLen Called\n"
000418r 3  65 6E 20 43  
00041Cr 3  61 6C 6C 65  
000423r 3  52 65 61 64  	readnum: .asciiz "ReadNum Called\n"
000427r 3  4E 75 6D 20  
00042Br 3  43 61 6C 6C  
000433r 3               
000433r 3               .SEGMENT "STDLIB"
000016r 3               
000016r 3               
000016r 3               ;	STRING LENGTH
000016r 3               ; 		Return lenght of zero terminated string in A
000016r 3               ;	Input:
000016r 3               ;		stack: 2 bytes string address (0 terminated)
000016r 3               ;	Output:
000016r 3               ;		A: length of the string
000016r 3               Stdlib_StrLen:
000016r 3  18           		clc
000017r 3               
000017r 3  E2 30        		shortr
000019r 3               
000019r 3  A0 00        		ldy #0
00001Br 3               	@next:
00001Br 3  B3 0A        		lda (args_start,s),y
00001Dr 3  F0 04        		beq @result
00001Fr 3  C8           		iny
000020r 3  4C rr rr     		jmp @next
000023r 3               	@result:
000023r 3  98           		tya
000024r 3  83 05        		sta reg_a, s
000026r 3               
000026r 3               	;	shortr
000026r 3               	;	write strlen
000026r 3               
000026r 3  C2 30        		longr
000028r 3               
000028r 3  7A           		ply
000029r 3  FA           		plx
00002Ar 3  68           		pla
00002Br 3               
00002Br 3  6B           		rtl
00002Cr 3               
00002Cr 3               
00002Cr 3               
00002Cr 3               
00002Cr 3               ;	READ NUMBER
00002Cr 3               ; 		Return the decimal number read from string input
00002Cr 3               Stdlib_ReadNum_StackSize = 6
00002Cr 3               Stdlib_ReadNum_SingleDigit = 1
00002Cr 3               Stdlib_ReadNum_Result = Stdlib_ReadNum_SingleDigit + 2
00002Cr 3               Stdlib_ReadNum_LoopCounter = Stdlib_ReadNum_Result + 2
00002Cr 3               Stdlib_ReadNum:
00002Cr 3  C2 30        		longr
00002Er 3  A2 00 00     		ldx #0
000031r 3  A0 00 00     		ldy #0
000034r 3  5A           		phy
000035r 3  5A           		phy
000036r 3  5A           		phy
000037r 3               	@next:
000037r 3  E2 30        		shortr
000039r 3  B3 10        		lda (args_start+Stdlib_ReadNum_StackSize,s),y
00003Br 3  C2 30        		longr
00003Dr 3  C9 30 00     		cmp #$30
000040r 3  90 09        		bcc @numend						; less than $30
000042r 3  C9 40 00     		cmp #$40
000045r 3  B0 04        		bcs @numend						; more than $39
000047r 3  C8           		iny
000048r 3  4C rr rr     		jmp @next
00004Br 3               	@numend:
00004Br 3  98           		tya
00004Cr 3  F0 1F        		beq @done						; did we read 0 numbers? then end
00004Er 3  88           		dey								; subtract 1 for the last number
00004Fr 3  E2 30        		shortr
000051r 3  B3 10        		lda (args_start+Stdlib_ReadNum_StackSize,s),y
000053r 3  C2 30        		longr
000055r 3  18           		clc
000056r 3  E9 2F 00     		sbc #$2F
000059r 3  83 01        		sta Stdlib_ReadNum_SingleDigit,s
00005Br 3               
00005Br 3  A3 05        		lda Stdlib_ReadNum_LoopCounter,s ; how many times to multiply 10?
00005Dr 3  AA           		tax								; save in loop counter X
00005Er 3               	@mulloop:
00005Er 3  8A           		txa								; look at loop counter X
00005Fr 3  F0 18        		beq @donemul					; if 0 then skip multiply 10
000061r 3  A3 01        		lda Stdlib_ReadNum_SingleDigit,s
000063r 3               
000063r 3  22 rr rr rr  		jsl MulTen
000067r 3  83 01        		sta Stdlib_ReadNum_SingleDigit,s
000069r 3               
000069r 3  CA           		dex								; derement loop counter X
00006Ar 3  4C rr rr     		jmp @mulloop
00006Dr 3               
00006Dr 3               	@done:
00006Dr 3  A3 03        		lda Stdlib_ReadNum_Result,s
00006Fr 3  83 0B        		sta reg_a+Stdlib_ReadNum_StackSize, s
000071r 3               
000071r 3  18           		clc
000072r 3               
000072r 3  7A           		ply ; clear temp stack
000073r 3  7A           		ply ; clear temp stack
000074r 3  7A           		ply ; clear temp stack
000075r 3               
000075r 3  7A           		ply
000076r 3  FA           		plx
000077r 3  68           		pla
000078r 3               
000078r 3               
000078r 3  6B           		rtl
000079r 3               
000079r 3               
000079r 3               	@donemul:
000079r 3               
000079r 3  A3 01        		lda Stdlib_ReadNum_SingleDigit,s
00007Br 3  18           		clc
00007Cr 3  63 03        		adc Stdlib_ReadNum_Result,s
00007Er 3  83 03        		sta Stdlib_ReadNum_Result,s
000080r 3               
000080r 3  A3 05        		lda Stdlib_ReadNum_LoopCounter,s
000082r 3  18           		clc
000083r 3  69 01 00     		adc #1								; add one time multiply with 10
000086r 3  83 05        		sta Stdlib_ReadNum_LoopCounter,s
000088r 3  4C rr rr     		jmp @numend
00008Br 3               
00008Br 3               
00008Br 3               MulTen:
00008Br 3  5A           		phy
00008Cr 3  0A           		asl						;   *  2
00008Dr 3  48           		pha
00008Er 3  0A           		asl						;   *  4
00008Fr 3  0A           		asl		               	;   *  8
000090r 3  18           		clc
000091r 3  63 01        		adc 1,s               	;   + (*2)
000093r 3  7A           		ply
000094r 3  7A           		ply
000095r 3  6B           		rtl
000096r 3               
000096r 3               
000096r 3               
000096r 3               ; Compare the first token of string1 (delimited by whitespace) against string2
000096r 3               ; in:
000096r 3               ;    string1  - string tokenized by space
000096r 3               ;    string2  - string to compare first token of string1 against
000096r 3               ; example:
000096r 3               ;    first:  time test\0
000096r 3               ;    second: time\0
000096r 3               ;    This is a match
000096r 3               ; out:
000096r 3               ;   carry set if no match
000096r 3               ;	carry clear if match
000096r 3               StdLib_StrCompareUntilWhiteSpace_Arg_String2 = args_start
000096r 3               StdLib_StrCompareUntilWhiteSpace_Arg_String1 = args_start + 2
000096r 3               StdLib_StrCompareUntilWhiteSpace:
000096r 3  18           		clc
000097r 3  A0 00 00     		ldy #$00
00009Ar 3               	@strcmp_token_load:
00009Ar 3  B3 0C        		lda (StdLib_StrCompareUntilWhiteSpace_Arg_String1,s), Y
00009Cr 3  C9 20 00     		cmp #$20                                ; is whitespace?
00009Fr 3  F0 0D        		beq @strcmp_token_is_second_done		; yes then check if string2 is done
0000A1r 3  D3 0A        		cmp (StdLib_StrCompareUntilWhiteSpace_Arg_String2,s), Y
0000A3r 3  D0 13        		bne @strcmp_token_notequal				; is it equal to string2?
0000A5r 3  C8           		INY
0000A6r 3  C9 00 00     		CMP #0
0000A9r 3  D0 EF        		BNE @strcmp_token_load
0000ABr 3  4C rr rr     		jmp @return
0000AEr 3               
0000AEr 3               	@strcmp_token_is_second_done:
0000AEr 3  B3 0A        		lda (StdLib_StrCompareUntilWhiteSpace_Arg_String2,s), Y
0000B0r 3  C9 00 00     		cmp #0									; is string2 done?
0000B3r 3  F0 04        		beq @return								; yes then return match
0000B5r 3  4C rr rr     		jmp @strcmp_token_notequal				; no then return no match
0000B8r 3               	@strcmp_token_notequal:
0000B8r 3  38           		sec
0000B9r 3               	@return:
0000B9r 3  7A           		ply
0000BAr 3  FA           		plx
0000BBr 3  68           		pla
0000BCr 3  6B           		rtl
0000BDr 3               
0000BDr 2               
0000BDr 2               
0000BDr 2               ;    register stack frame...
0000BDr 2               ;
0000BDr 2               reg_y       =1                    ;16 bit .Y
0000BDr 2               reg_x       =reg_y+2              ;16 bit .X
0000BDr 2               reg_a       =reg_x+2              ;16 bit .A
0000BDr 2               reg_rtl     =reg_a+2              ;24 bit RTL address
0000BDr 2               
0000BDr 2               args_start  =reg_rtl+3
0000BDr 2               
0000BDr 2               ; ARGS      $10 args_start
0000BDr 2               ; RTS___    $07 reg_rts
0000BDr 2               ; AAAA      $05 reg_a
0000BDr 2               ; XXXX      $03 reg_x
0000BDr 2               ; YYYY      $01 reg_y
0000BDr 2               ;           current StackPointer
0000BDr 2               
0000BDr 1               
0000BDr 1               .include "programs/programs.inc"
0000BDr 2               
0000BDr 2               .include "shell.asm"
0000BDr 3               ; DIRECT PAGE LAYOUT
0000BDr 3               ; $00 - $7F   : Input Buffer
0000BDr 3               ; $80         : Input Buffer Index
0000BDr 3               
0000BDr 3               Shell_InputBufferStart = $00
0000BDr 3               Shell_InputBufferIndex = $80
0000BDr 3               
0000BDr 3               ShellExec:
0000BDr 3  E2 30                shortr
0000BFr 3                   @restart:
0000BFr 3  64 80                stz Shell_InputBufferIndex      ; reset input buffer
0000C1r 3  64 00                stz Shell_InputBufferStart      ; start buffer with 0-termination
0000C3r 3               
0000C3r 3  A9 3E                lda #'>'
0000C5r 3  22 rr rr rr          jsl RA8875_WriteChar
0000C9r 3  A9 20                lda #' '
0000CBr 3  22 rr rr rr          jsl RA8875_WriteChar
0000CFr 3               
0000CFr 3               
0000CFr 3                   @loop:
0000CFr 3  A2 00                ldx #STREAM_STDIN                ; TODO: Get stream from Task Context (not hardcoded stdin)
0000D1r 3  22 rr rr rr          jsl StreamGetC
0000D5r 3  F0 F8                beq @loop                       ; Noting in stream (carry set)
0000D7r 3  48                   pha
0000D8r 3  22 rr rr rr          jsl RA8875_WriteChar            ; Write to RA8875       - todo: write to stream (from task context) - stdout
0000DCr 3  68                   pla
0000DDr 3  C5 0A                cmp $0A                         ; Is it LINE FEED?
0000DFr 3  F0 10                beq @execute                    ; yes - then execute input buffer
0000E1r 3               
0000E1r 3                       ; store in input buffer
0000E1r 3  A6 80                ldx Shell_InputBufferIndex
0000E3r 3  95 00                sta Shell_InputBufferStart,x
0000E5r 3  E8                   inx
0000E6r 3  C9 80                cmp #Shell_InputBufferIndex     ; compare to #128
0000E8r 3  D0 02                bne @cnt                        ; if not overflow then continue
0000EAr 3  64 80                stz Shell_InputBufferIndex
0000ECr 3               
0000ECr 3                   @cnt:
0000ECr 3  74 00                stz Shell_InputBufferStart,x    ; 0-terminate the end of the input buffer
0000EEr 3               
0000EEr 3  4C rr rr             jmp @loop
0000F1r 3               
0000F1r 3                   @execute:
0000F1r 3               ; TODO: EXECUTE string in input buffer
0000F1r 3               
0000F1r 3                       ;lda #00                         ; put start of input buffer on stack
0000F1r 3                       ;pha
0000F1r 3                       ;pha
0000F1r 3               
0000F1r 3  4C rr rr             jmp @restart
0000F4r 3               
0000F4r 2               .include "clock.asm"
0000F4r 3               
0000F4r 3               .SEGMENT "RAM"
000002r 3               
000002r 3  xx xx        ClockCounter: .res 2
000004r 3               
000004r 3               .code
0008D1r 3               .A16
0008D1r 3               .I16
0008D1r 3               ClockExec:
0008D1r 3  E2 30            shortr
0008D3r 3  A9 00            lda #$0
0008D5r 3  85 00            sta $0
0008D7r 3               @loop:
0008D7r 3  EE rr rr         inc ClockCounter
0008DAr 3  D0 03            BNE @lowonly    ; Branch to end if the low byte didn't roll over to 00.
0008DCr 3  EE rr rr         inc ClockCounter+1
0008DFr 3                   @lowonly:
0008DFr 3               
0008DFr 3               
0008DFr 3  4C rr rr         jmp @loop
0008E2r 3               
0008E2r 3  C2 30            longr
0008E4r 3  60               rts
0008E5r 3               
0008E5r 2               .include "diodeblink.asm"
0008E5r 3               .RODATA
000433r 3               
000433r 3  0D 28 2A 2D  running_diode_0: .asciiz "\r(*------)"
000437r 3  2D 2D 2D 2D  
00043Br 3  2D 29 00     
00043Er 3  0D 28 2D 2A  running_diode_1: .asciiz "\r(-*-----)"
000442r 3  2D 2D 2D 2D  
000446r 3  2D 29 00     
000449r 3  0D 28 2D 2D  running_diode_2: .asciiz "\r(--*----)"
00044Dr 3  2A 2D 2D 2D  
000451r 3  2D 29 00     
000454r 3  0D 28 2D 2D  running_diode_3: .asciiz "\r(---*---)"
000458r 3  2D 2A 2D 2D  
00045Cr 3  2D 29 00     
00045Fr 3  0D 28 2D 2D  running_diode_4: .asciiz "\r(----*--)"
000463r 3  2D 2D 2A 2D  
000467r 3  2D 29 00     
00046Ar 3  0D 28 2D 2D  running_diode_5: .asciiz "\r(-----*-)"
00046Er 3  2D 2D 2D 2A  
000472r 3  2D 29 00     
000475r 3  0D 28 2D 2D  running_diode_6: .asciiz "\r(------*)"
000479r 3  2D 2D 2D 2D  
00047Dr 3  2A 29 00     
000480r 3               
000480r 3               .code
0008E5r 3               .A16
0008E5r 3               .I16
0008E5r 3               LoaderExec:
0008E5r 3  A9 0A 00         lda #$0A
0008E8r 3  22 rr rr rr      jsl RA8875_WriteChar16          ; write new line
0008ECr 3  E2 30        shortr
0008EEr 3  22 rr rr rr      jsl Sys_GetPID
0008F2r 3  C2 30        longr
0008F4r 3  0A               asl
0008F5r 3  0A               asl
0008F6r 3  0A               asl
0008F7r 3  0A               asl
0008F8r 3  18               clc
0008F9r 3  69 D0 00         adc #(16*13)
0008FCr 3  85 00            sta $00
0008FEr 3               
0008FEr 3               
0008FEr 3  A5 00            lda $00
000900r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000904r 3               
000904r 3  22 rr rr rr      jsl RA8875_WriteHex16
000908r 3               
000908r 3  A9 0A 00         lda #$0A
00090Br 3  22 rr rr rr      jsl RA8875_WriteChar16          ; write new line
00090Fr 3               LoaderLoop:
00090Fr 3               
00090Fr 3  A5 00            lda $00
000911r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000915r 3  78 F4 rr rr      write running_diode_0
000919r 3  22 rr rr rr  
00091Dr 3  68 58        
00091Fr 3  20 rr rr         jsr LongDelayLoaderExec
000922r 3               
000922r 3  A5 00            lda $00
000924r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000928r 3  78 F4 rr rr      write running_diode_1
00092Cr 3  22 rr rr rr  
000930r 3  68 58        
000932r 3  20 rr rr         jsr LongDelayLoaderExec
000935r 3               
000935r 3  A5 00            lda $00
000937r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
00093Br 3  78 F4 rr rr      write running_diode_2
00093Fr 3  22 rr rr rr  
000943r 3  68 58        
000945r 3  20 rr rr         jsr LongDelayLoaderExec
000948r 3               
000948r 3  A5 00            lda $00
00094Ar 3  22 rr rr rr      jsl RA8875_SetTextCursorY
00094Er 3  78 F4 rr rr      write running_diode_3
000952r 3  22 rr rr rr  
000956r 3  68 58        
000958r 3  20 rr rr         jsr LongDelayLoaderExec
00095Br 3               
00095Br 3  A5 00            lda $00
00095Dr 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000961r 3  78 F4 rr rr      write running_diode_4
000965r 3  22 rr rr rr  
000969r 3  68 58        
00096Br 3  20 rr rr         jsr LongDelayLoaderExec
00096Er 3               
00096Er 3  A5 00            lda $00
000970r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000974r 3  78 F4 rr rr      write running_diode_5
000978r 3  22 rr rr rr  
00097Cr 3  68 58        
00097Er 3  20 rr rr         jsr LongDelayLoaderExec
000981r 3               
000981r 3  A5 00            lda $00
000983r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000987r 3  78 F4 rr rr      write running_diode_6
00098Br 3  22 rr rr rr  
00098Fr 3  68 58        
000991r 3  20 rr rr         jsr LongDelayLoaderExec
000994r 3               
000994r 3  A5 00            lda $00
000996r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
00099Ar 3  78 F4 rr rr      write running_diode_5
00099Er 3  22 rr rr rr  
0009A2r 3  68 58        
0009A4r 3  20 rr rr         jsr LongDelayLoaderExec
0009A7r 3               
0009A7r 3  A5 00            lda $00
0009A9r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009ADr 3  78 F4 rr rr      write running_diode_4
0009B1r 3  22 rr rr rr  
0009B5r 3  68 58        
0009B7r 3  20 rr rr         jsr LongDelayLoaderExec
0009BAr 3               
0009BAr 3  A5 00            lda $00
0009BCr 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009C0r 3  78 F4 rr rr      write running_diode_3
0009C4r 3  22 rr rr rr  
0009C8r 3  68 58        
0009CAr 3  20 rr rr         jsr LongDelayLoaderExec
0009CDr 3               
0009CDr 3  A5 00            lda $00
0009CFr 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009D3r 3  78 F4 rr rr      write running_diode_2
0009D7r 3  22 rr rr rr  
0009DBr 3  68 58        
0009DDr 3  20 rr rr         jsr LongDelayLoaderExec
0009E0r 3  78 F4 rr rr      write running_diode_1
0009E4r 3  22 rr rr rr  
0009E8r 3  68 58        
0009EAr 3  20 rr rr         jsr LongDelayLoaderExec
0009EDr 3               
0009EDr 3  5C rr rr rr      JML LoaderLoop
0009F1r 3               
0009F1r 3               LongDelayLoaderExec:
0009F1r 3  E2 30            shortr
0009F3r 3  20 rr rr         jsr LogDelayLoader
0009F6r 3  20 rr rr         jsr LogDelayLoader
0009F9r 3  20 rr rr         jsr LogDelayLoader
0009FCr 3  C2 30            longr
0009FEr 3  60               rts
0009FFr 3               
0009FFr 3               .A8
0009FFr 3               .I8
0009FFr 3               LogDelayLoader:
0009FFr 3  A2 FF            ldx #$FF
000A01r 3               LogDelayLoaderLoop1:
000A01r 3  A0 FF            ldy #$FF
000A03r 3               LogDelayLoaderLoop2:
000A03r 3  88               dey
000A04r 3  D0 FD            bne LogDelayLoaderLoop2
000A06r 3  CA               dex
000A07r 3  D0 F8            bne LogDelayLoaderLoop1
000A09r 3  60               rts
000A0Ar 3               
000A0Ar 2               .include "taskprinter.asm"
000A0Ar 3               .code
000A0Ar 3               
000A0Ar 3               TaskPrinterExec:
000A0Ar 3  E2 30        shortr
000A0Cr 3  22 rr rr rr      jsl Sys_GetPID
000A10r 3  85 00            sta $00
000A12r 3               
000A12r 3               @loop:
000A12r 3               
000A12r 3  A5 00            lda $00
000A14r 3  22 rr rr rr      jsl RA8875_WriteHex
000A18r 3  20 rr rr         jsr LongDelayTaskPrinterExec
000A1Br 3               
000A1Br 3  5C rr rr rr      JML @loop
000A1Fr 3               
000A1Fr 3               LongDelayTaskPrinterExec:
000A1Fr 3  20 rr rr         jsr LogDelayTaskPrinter
000A22r 3  20 rr rr         jsr LogDelayTaskPrinter
000A25r 3  20 rr rr         jsr LogDelayTaskPrinter
000A28r 3  60               rts
000A29r 3               
000A29r 3               .A8
000A29r 3               .I8
000A29r 3               LogDelayTaskPrinter:
000A29r 3  A2 FF            ldx #$FF
000A2Br 3               LogDelayTaskPrinterLoop1:
000A2Br 3  A0 FF            ldy #$FF
000A2Dr 3               LogDelayTaskPrinterLoop2:
000A2Dr 3  88               dey
000A2Er 3  D0 FD            bne LogDelayTaskPrinterLoop2
000A30r 3  CA               dex
000A31r 3  D0 F8            bne LogDelayTaskPrinterLoop1
000A33r 3  60               rts
000A34r 3               
000A34r 2               .include "dump.asm"
000A34r 3               DumpExec:
000A34r 3  20 rr rr         jsr RA8875_WriteHex
000A37r 3  60               rts
000A38r 3               
000A38r 2               .include "dumpstack.asm"
000A38r 3               .I16
000A38r 3               .A16
000A38r 3               DumpStack:
000A38r 3  E2 30            shortr
000A3Ar 3                 ;  lda 1,s           ;get mode
000A3Ar 3                 ;  jsl RA8875_WriteHex
000A3Ar 3                 ;  lda 2,s           ;get mode
000A3Ar 3                 ;  jsl RA8875_WriteHex
000A3Ar 3               
000A3Ar 3                 ;  lda #' '
000A3Ar 3                 ;  jsl RA8875_WriteChar
000A3Ar 3               
000A3Ar 3                   ;lda #$A
000A3Ar 3                   ;jsl RA8875_WriteChar
000A3Ar 3               
000A3Ar 3  C2 30            longr
000A3Cr 3  3B               tsc
000A3Dr 3  18               clc
000A3Er 3  69 04 00         adc #4
000A41r 3  22 rr rr rr      jsl RA8875_WriteHex16
000A45r 3  E2 30            shortr
000A47r 3  A9 20            lda #' '
000A49r 3  22 rr rr rr      jsl RA8875_WriteChar
000A4Dr 3               
000A4Dr 3  C2 30            longr
000A4Fr 3  3B               tsc
000A50r 3  18               clc
000A51r 3  69 06 00         adc #6
000A54r 3  22 rr rr rr      jsl RA8875_WriteHex16
000A58r 3  E2 30            shortr
000A5Ar 3  A9 20            lda #' '
000A5Cr 3  22 rr rr rr      jsl RA8875_WriteChar
000A60r 3               
000A60r 3  C2 30            longr
000A62r 3  3B               tsc
000A63r 3  18               clc
000A64r 3  69 08 00         adc #8
000A67r 3  22 rr rr rr      jsl RA8875_WriteHex16
000A6Br 3  E2 30            shortr
000A6Dr 3  A9 20            lda #' '
000A6Fr 3  22 rr rr rr      jsl RA8875_WriteChar
000A73r 3               
000A73r 3               
000A73r 3  C2 30            longr
000A75r 3  3B               tsc
000A76r 3  18               clc
000A77r 3  69 0A 00         adc #10
000A7Ar 3  22 rr rr rr      jsl RA8875_WriteHex16
000A7Er 3  E2 30            shortr
000A80r 3  A9 20            lda #' '
000A82r 3  22 rr rr rr      jsl RA8875_WriteChar
000A86r 3               
000A86r 3               
000A86r 3               
000A86r 3  C2 30            longr
000A88r 3  3B               tsc
000A89r 3  18               clc
000A8Ar 3  69 0C 00         adc #12
000A8Dr 3  22 rr rr rr      jsl RA8875_WriteHex16
000A91r 3  E2 30            shortr
000A93r 3  A9 20            lda #' '
000A95r 3  22 rr rr rr      jsl RA8875_WriteChar
000A99r 3  C2 30            longr
000A9Br 3  3B               tsc
000A9Cr 3  18               clc
000A9Dr 3  69 0E 00         adc #14
000AA0r 3  22 rr rr rr      jsl RA8875_WriteHex16
000AA4r 3  E2 30            shortr
000AA6r 3  A9 20            lda #' '
000AA8r 3  22 rr rr rr      jsl RA8875_WriteChar
000AACr 3               
000AACr 3  C2 30            longr
000AAEr 3  3B               tsc
000AAFr 3  18               clc
000AB0r 3  69 10 00         adc #16
000AB3r 3  22 rr rr rr      jsl RA8875_WriteHex16
000AB7r 3  E2 30            shortr
000AB9r 3  A9 20            lda #' '
000ABBr 3  22 rr rr rr      jsl RA8875_WriteChar
000ABFr 3               
000ABFr 3  C2 30            longr
000AC1r 3  3B               tsc
000AC2r 3  18               clc
000AC3r 3  69 12 00         adc #18
000AC6r 3  22 rr rr rr      jsl RA8875_WriteHex16
000ACAr 3  E2 30            shortr
000ACCr 3  A9 20            lda #' '
000ACEr 3  22 rr rr rr      jsl RA8875_WriteChar
000AD2r 3               
000AD2r 3  C2 30            longr
000AD4r 3  3B               tsc
000AD5r 3  18               clc
000AD6r 3  69 14 00         adc #20
000AD9r 3  22 rr rr rr      jsl RA8875_WriteHex16
000ADDr 3  E2 30            shortr
000ADFr 3  A9 20            lda #' '
000AE1r 3  22 rr rr rr      jsl RA8875_WriteChar
000AE5r 3               
000AE5r 3  A9 0A            lda #$A
000AE7r 3  22 rr rr rr      jsl RA8875_WriteChar
000AEBr 3               
000AEBr 3               ; Skip the first two as they are DumpStack return
000AEBr 3  A3 04            lda 4,s           ;get mode
000AEDr 3  22 rr rr rr      jsl RA8875_WriteHex
000AF1r 3  A3 05            lda 5,s           ;get mode
000AF3r 3  22 rr rr rr      jsl RA8875_WriteHex
000AF7r 3               
000AF7r 3  A9 20            lda #' '
000AF9r 3  22 rr rr rr      jsl RA8875_WriteChar
000AFDr 3               
000AFDr 3               
000AFDr 3  A3 06            lda 6,s           ;get mode
000AFFr 3  22 rr rr rr      jsl RA8875_WriteHex
000B03r 3  A3 07            lda 7,s           ;get mode
000B05r 3  22 rr rr rr      jsl RA8875_WriteHex
000B09r 3               
000B09r 3  A9 20            lda #' '
000B0Br 3  22 rr rr rr      jsl RA8875_WriteChar
000B0Fr 3               
000B0Fr 3               
000B0Fr 3  A3 08            lda 8,s           ;get mode
000B11r 3  22 rr rr rr      jsl RA8875_WriteHex
000B15r 3  A3 09            lda 9,s           ;get mode
000B17r 3  22 rr rr rr      jsl RA8875_WriteHex
000B1Br 3               
000B1Br 3               
000B1Br 3  A9 20            lda #' '
000B1Dr 3  22 rr rr rr      jsl RA8875_WriteChar
000B21r 3               
000B21r 3               
000B21r 3  A3 0A            lda 10,s           ;get mode
000B23r 3  22 rr rr rr      jsl RA8875_WriteHex
000B27r 3  A3 0B            lda 11,s           ;get mode
000B29r 3  22 rr rr rr      jsl RA8875_WriteHex
000B2Dr 3               
000B2Dr 3  A9 20            lda #' '
000B2Fr 3  22 rr rr rr      jsl RA8875_WriteChar
000B33r 3               
000B33r 3               
000B33r 3  A3 0C            lda 12,s           ;get mode
000B35r 3  22 rr rr rr      jsl RA8875_WriteHex
000B39r 3  A3 0D            lda 13,s           ;get mode
000B3Br 3  22 rr rr rr      jsl RA8875_WriteHex
000B3Fr 3               
000B3Fr 3  A9 20            lda #' '
000B41r 3  22 rr rr rr      jsl RA8875_WriteChar
000B45r 3               
000B45r 3               
000B45r 3  A3 0E            lda 14,s           ;get mode
000B47r 3  22 rr rr rr      jsl RA8875_WriteHex
000B4Br 3  A3 0F            lda 15,s           ;get mode
000B4Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000B51r 3               
000B51r 3  A9 20            lda #' '
000B53r 3  22 rr rr rr      jsl RA8875_WriteChar
000B57r 3               
000B57r 3               
000B57r 3  A3 10            lda 16,s           ;get mode
000B59r 3  22 rr rr rr      jsl RA8875_WriteHex
000B5Dr 3  A3 11            lda 17,s           ;get mode
000B5Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000B63r 3               
000B63r 3               
000B63r 3  A9 20            lda #' '
000B65r 3  22 rr rr rr      jsl RA8875_WriteChar
000B69r 3               
000B69r 3               
000B69r 3  A3 12            lda 18,s           ;get mode
000B6Br 3  22 rr rr rr      jsl RA8875_WriteHex
000B6Fr 3  A3 13            lda 19,s           ;get mode
000B71r 3  22 rr rr rr      jsl RA8875_WriteHex
000B75r 3               
000B75r 3  A9 20            lda #' '
000B77r 3  22 rr rr rr      jsl RA8875_WriteChar
000B7Br 3               
000B7Br 3               
000B7Br 3  A3 14            lda 20,s           ;get mode
000B7Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000B81r 3  A3 15            lda 21,s           ;get mode
000B83r 3  22 rr rr rr      jsl RA8875_WriteHex
000B87r 3               
000B87r 3  A9 20            lda #' '
000B89r 3  22 rr rr rr      jsl RA8875_WriteChar
000B8Dr 3               
000B8Dr 3               
000B8Dr 3  A3 16            lda 22,s           ;get mode
000B8Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000B93r 3  A3 17            lda 23,s           ;get mode
000B95r 3  22 rr rr rr      jsl RA8875_WriteHex
000B99r 3               
000B99r 3  A9 20            lda #' '
000B9Br 3  22 rr rr rr      jsl RA8875_WriteChar
000B9Fr 3               
000B9Fr 3               
000B9Fr 3  A3 18            lda 24,s           ;get mode
000BA1r 3  22 rr rr rr      jsl RA8875_WriteHex
000BA5r 3  A3 19            lda 25,s           ;get mode
000BA7r 3  22 rr rr rr      jsl RA8875_WriteHex
000BABr 3               
000BABr 3               
000BABr 3  A9 20            lda #' '
000BADr 3  22 rr rr rr      jsl RA8875_WriteChar
000BB1r 3               
000BB1r 3               
000BB1r 3  A3 1A            lda 26,s           ;get mode
000BB3r 3  22 rr rr rr      jsl RA8875_WriteHex
000BB7r 3  A3 1B            lda 27,s           ;get mode
000BB9r 3  22 rr rr rr      jsl RA8875_WriteHex
000BBDr 3               
000BBDr 3  A9 0A            lda #$A
000BBFr 3  22 rr rr rr      jsl RA8875_WriteChar
000BC3r 3               
000BC3r 3  C2 30            longr
000BC5r 3  6B               rtl
000BC6r 3               
000BC6r 2               .include "dumpregs.asm"
000BC6r 3               .A8
000BC6r 3               .I8
000BC6r 3               DumpRegs:
000BC6r 3  C2 30            longr
000BC8r 3  48               pha
000BC9r 3  DA               phx
000BCAr 3  5A               phy
000BCBr 3               
000BCBr 3  E2 30            shortr
000BCDr 3               
000BCDr 3  A9 41            lda #'A'
000BCFr 3  22 rr rr rr      jsl RA8875_WriteChar
000BD3r 3  A9 3A            lda #':'
000BD5r 3  22 rr rr rr      jsl RA8875_WriteChar
000BD9r 3  A9 20            lda #' '
000BDBr 3  22 rr rr rr      jsl RA8875_WriteChar
000BDFr 3  A3 06            lda 6,s           ;get mode
000BE1r 3  22 rr rr rr      jsl RA8875_WriteHex
000BE5r 3  A3 05            lda 5,s           ;get mode
000BE7r 3  22 rr rr rr      jsl RA8875_WriteHex
000BEBr 3  A9 0A            lda #$0A
000BEDr 3  22 rr rr rr      jsl RA8875_WriteChar
000BF1r 3               
000BF1r 3               
000BF1r 3  A9 59            lda #'Y'
000BF3r 3  22 rr rr rr      jsl RA8875_WriteChar
000BF7r 3  A9 3A            lda #':'
000BF9r 3  22 rr rr rr      jsl RA8875_WriteChar
000BFDr 3  A9 20            lda #' '
000BFFr 3  22 rr rr rr      jsl RA8875_WriteChar
000C03r 3  A3 02            lda 2,s           ;get mode
000C05r 3  22 rr rr rr      jsl RA8875_WriteHex
000C09r 3  A3 01            lda 1,s           ;get mode
000C0Br 3  22 rr rr rr      jsl RA8875_WriteHex
000C0Fr 3  A9 0A            lda #$0A
000C11r 3  22 rr rr rr      jsl RA8875_WriteChar
000C15r 3               
000C15r 3  A9 58            lda #'X'
000C17r 3  22 rr rr rr      jsl RA8875_WriteChar
000C1Br 3  A9 3A            lda #':'
000C1Dr 3  22 rr rr rr      jsl RA8875_WriteChar
000C21r 3  A9 20            lda #' '
000C23r 3  22 rr rr rr      jsl RA8875_WriteChar
000C27r 3  A3 04            lda 4,s           ;get mode
000C29r 3  22 rr rr rr      jsl RA8875_WriteHex
000C2Dr 3  A3 03            lda 3,s           ;get mode
000C2Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000C33r 3  A9 0A            lda #$0A
000C35r 3  22 rr rr rr      jsl RA8875_WriteChar
000C39r 3               
000C39r 3               
000C39r 3               
000C39r 3  C2 30            longr       ;select 16 bit registers
000C3Br 3               
000C3Br 3  7A               ply
000C3Cr 3  FA               plx
000C3Dr 3  68               pla
000C3Er 3               
000C3Er 3  60               rts
000C3Fr 3               
000C3Fr 2               
000C3Fr 1               .A8
000C3Fr 1               .I8
000C3Fr 1               ResetVector:
000C3Fr 1  A2 FF            ldx #$FF
000C41r 1  9A               txs
000C42r 1  D8               cld
000C43r 1  20 rr rr         jsr InitBIOS                    ; Entry point for boot
000C46r 1               
000C46r 1  C2 30            longr
000C48r 1  20 rr rr         jsr InitKernel                  ; Kernel Init
000C4Br 1               
000C4Br 1               
000C4Br 1  E2 30            shortr
000C4Dr 1  A9 00            lda #$00            ; push program bank of ShellExec
000C4Fr 1  48               pha
000C50r 1  C2 30            longr
000C52r 1  F4 rr rr         pea ShellExec       ; push 2byte addr of ShellExec
000C55r 1  22 rr rr rr      jsl TaskSpawn
000C59r 1  68               pla
000C5Ar 1  E2 30            shortr
000C5Cr 1  68               pla
000C5Dr 1               
000C5Dr 1  A9 00            lda #$00            ; push program bank of ClockExec
000C5Fr 1  48               pha
000C60r 1  C2 30            longr
000C62r 1  F4 rr rr         pea ClockExec       ; push 2byte addr of ClockExec
000C65r 1  22 rr rr rr      jsl TaskSpawn
000C69r 1  68               pla
000C6Ar 1  E2 30            shortr
000C6Cr 1  68               pla ; clean up
000C6Dr 1               
000C6Dr 1               
000C6Dr 1  A9 00            lda #$00            ; push program bank of LoaderExec
000C6Fr 1  48               pha
000C70r 1  C2 30            longr
000C72r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000C75r 1  22 rr rr rr      jsl TaskSpawn
000C79r 1  68               pla
000C7Ar 1  E2 30            shortr
000C7Cr 1  68               pla ; clean up
000C7Dr 1               
000C7Dr 1               
000C7Dr 1  A9 00            lda #$00            ; push program bank of LoaderExec
000C7Fr 1  48               pha
000C80r 1  C2 30            longr
000C82r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000C85r 1  22 rr rr rr      jsl TaskSpawn
000C89r 1  68               pla
000C8Ar 1  E2 30            shortr
000C8Cr 1  68               pla ; clean up
000C8Dr 1               
000C8Dr 1  A9 00            lda #$00            ; push program bank of LoaderExec
000C8Fr 1  48               pha
000C90r 1  C2 30            longr
000C92r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000C95r 1  22 rr rr rr      jsl TaskSpawn
000C99r 1  68               pla
000C9Ar 1  E2 30            shortr
000C9Cr 1  68               pla ; clean up
000C9Dr 1               
000C9Dr 1  A9 00            lda #$00            ; push program bank of LoaderExec
000C9Fr 1  48               pha
000CA0r 1  C2 30            longr
000CA2r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000CA5r 1  22 rr rr rr      jsl TaskSpawn
000CA9r 1  68               pla
000CAAr 1  E2 30            shortr
000CACr 1  68               pla ; clean up
000CADr 1               
000CADr 1               
000CADr 1               
000CADr 1               
000CADr 1                   ; debug printing of task
000CADr 1                   ;lda TaskProgramBank+1
000CADr 1                   ;jsl RA8875_WriteHex
000CADr 1                   ;lda TaskProgramPointer+2
000CADr 1                   ;jsl RA8875_WriteHex
000CADr 1                   ;lda TaskProgramPointer+3
000CADr 1                   ;jsl RA8875_WriteHex
000CADr 1               
000CADr 1               
000CADr 1  58               cli
000CAEr 1               
000CAEr 1                   ;jsl Scheduler_NextTask
000CAEr 1                   ;jsr ShellExec                   ; Run shell program
000CAEr 1               
000CAEr 1               ; Blink Diode
000CAEr 1                   ;jsl LoaderExec
000CAEr 1               
000CAEr 1               Loop:
000CAEr 1  4C rr rr         jmp Loop
000CB1r 1               
000CB1r 1               .SEGMENT "NATIVE_VECTORS"
000000r 1  00 00            .word $0000                 ; COP
000002r 1  00 00            .word $0000                 ; BRK
000004r 1  00 00            .word $0000                 ; ABORTB
000006r 1  00 00            .word $0000                 ; NMIB
000008r 1  00 00            .word $0000                 ; RES
00000Ar 1               .SEGMENT "VECTORS"
000000r 1  rr rr            .word ResetVector           ; RESET
000002r 1  rr rr            .word InterruptVector       ; IRQB
000004r 1               
000004r 1               
