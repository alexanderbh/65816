ca65 V2.18 - Ubuntu 2.19-1
Main file   : src/main.asm
Current file: src/main.asm

000000r 1               .setcpu "65816"
000000r 1               .P816
000000r 1               .smart
000000r 1               .feature string_escapes
000000r 1               
000000r 1               .zeropage
000000r 1               .include "drivers/spi/spi.zp.inc"
000000r 2  xx           spi_byte_out:               .res 1
000001r 2  xx           spi_byte_in:                .res 1
000002r 2  xx           spi_selected_device:        .res 1
000003r 2               
000003r 1               .include "drivers/ra8875/ra8875.zp.inc"
000003r 2               
000003r 2  xx xx        string_ptr:                 .res 2
000005r 2  xx           cursor_x:                   .res 1
000006r 2  xx           cursor_y:                   .res 1
000007r 2               
000007r 2  xx           control_sequence_param_1:   .res 1
000008r 2  xx           control_sequence_param_2:   .res 1
000009r 2               
000009r 1               
000009r 1               .RODATA
000000r 1               
000000r 1  0A 2D 2D 2D  test_string: .asciiz "\n---\n"
000004r 1  0A 00        
000006r 1  31 33 35 37  testlen_string: .asciiz "1357abcdefgh78"
00000Ar 1  61 62 63 64  
00000Er 1  65 66 67 68  
000015r 1               
000015r 1               .code
000000r 1               .include "kernel/kernel.inc"
000000r 2               .A16
000000r 2               .I16
000000r 2               .macro write str_addr
000000r 2                   pea str_addr
000000r 2                   JSL RA8875_WriteString16
000000r 2                   PLA
000000r 2               .endmacro
000000r 2               
000000r 2               .A8
000000r 2               .I8
000000r 2               .macro write_char char
000000r 2                   PHA
000000r 2                   LDA char
000000r 2                   JSR RA8875_WriteStringChar
000000r 2                   PLA
000000r 2               .endmacro
000000r 2               
000000r 2               .RODATA
000015r 2               
000015r 2  0A 00        newline:                    .asciiz "\n"
000017r 2  4B 45 52 4E  init_kernel_done:           .asciiz "KERNEL - OK\n"
00001Br 2  45 4C 20 2D  
00001Fr 2  20 4F 4B 0A  
000024r 2  4B 45 52 4E  init_kernel_streams_done:   .asciiz "KERNEL: Streams - OK\n"
000028r 2  45 4C 3A 20  
00002Cr 2  53 74 72 65  
00003Ar 2  4B 45 52 4E  init_kernel_tasks_done:     .asciiz "KERNEL: Tasks - OK\n"
00003Er 2  45 4C 3A 20  
000042r 2  54 61 73 6B  
00004Er 2  4B 45 52 4E  init_kernel_scheduler_done: .asciiz "KERNEL: Scheduler - OK\n"
000052r 2  45 4C 3A 20  
000056r 2  53 63 68 65  
000066r 2               .code
000000r 2               
000000r 1               .include "macros/macros.inc"
000000r 2               ; bmn
000000r 2               ;       Block move macro
000000r 2               
000000r 2               .macro  bmn     len,from,to
000000r 2                       lda     #len-1
000000r 2                       ldx     #(from & $FFFF)
000000r 2                       ldy     #(to   & $FFFF)
000000r 2                       mvn     (from & $FF0000),(to & $FF0000)
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ;   Register Size Macros
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;   These macros are a convenient way to change the MPU's register sizes
000000r 2               ;   without having to remember the correct bit pattern for the REP & SEP
000000r 2               ;   instructions.  The assembler itself has no awareness of whether 8 or
000000r 2               ;   16 bit immediate mode operands are to be used.   Therefore, it is up
000000r 2               ;   to the programmer to use the appropriate instructions, & to be aware
000000r 2               ;   at all times of the MPU's register sizes.
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;
000000r 2               .macro  longa                ;16 bit accumulator & memory
000000r 2                       rep #$20
000000r 2               .A16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longr                ;16 bit all registers
000000r 2                       rep #$30
000000r 2               .A16
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longi              ;16 bit index registers
000000r 2                       rep #$10
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorta                ;8 bit accumulator & memory
000000r 2                       sep #$20
000000r 2               .A8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorti                ;8 bit index registers
000000r 2                       sep #$10
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shortr                ;8 bit all registers
000000r 2                       sep #$30
000000r 2               .A8
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               
000000r 1               
000000r 1               .include "bios/bios.asm"
000000r 2               .include "bios.inc"                         ; include BIOS includes
000000r 3               .RODATA
000066r 3               
000066r 3  42 49 4F 53  bios_init: .asciiz "BIOS Initialized"
00006Ar 3  20 49 6E 69  
00006Er 3  74 69 61 6C  
000077r 3  20 2D 20 4F  ok_string: .asciiz " - OK\n"
00007Br 3  4B 0A 00     
00007Er 3               
00007Er 3               
00007Er 3  43 4F 4C 4F  ansi_string: .byte "COLOR: ", $1B, $5B, "32mGREEN", $1B, $5B, "37m WHITE\n", $00
000082r 3  52 3A 20 1B  
000086r 3  5B 33 32 6D  
00009Cr 3               
00009Cr 3  49 4E 49 54  test_bios: .asciiz "INIT...\n"
0000A0r 3  2E 2E 2E 0A  
0000A4r 3  00           
0000A5r 3  20 2D 20 46  fail_string: .asciiz " - FAIL\n"
0000A9r 3  41 49 4C 0A  
0000ADr 3  00           
0000AEr 3               
0000AEr 3  20 5F 5F 5F  welcome_logo1: .asciiz " ______   ______   ______     ____     ______       ______   ______\n"
0000B2r 3  5F 5F 5F 20  
0000B6r 3  20 20 5F 5F  
0000F3r 3  2F 5F 5F 5F  welcome_logo2: .asciiz "/_____/\\ /_____/\\ /_____/\\   /___/\\   /_____/\\     /_____/\\ /_____/\\\n"
0000F7r 3  5F 5F 2F 5C  
0000FBr 3  20 2F 5F 5F  
000139r 3  5C 3A 3A 3A  welcome_logo3: .asciiz "\\:::__\\/ \\::::_\\/_\\:::_:\\ \\  \\_::\\ \\  \\:::__\\/     \\:::_ \\ \\\\::::_\\/_\n"
00013Dr 3  5F 5F 5C 2F  
000141r 3  20 5C 3A 3A  
000180r 3  20 5C 3A 5C  welcome_logo4: .asciiz " \\:\\ \\____\\:\\/___/\\\\:\\_\\:\\ \\   \\::\\ \\  \\:\\ \\____    \\:\\ \\ \\ \\\\:\\/___/\\\n"
000184r 3  20 5C 5F 5F  
000188r 3  5F 5F 5C 3A  
0001C8r 3  20 20 5C 3A  welcome_logo5: .asciiz "  \\::__::/\\\\_::._\\:\\\\::__:\\ \\  _\\: \\ \\__\\::__::/\\    \\:\\ \\ \\ \\\\_::._\\:\\\n"
0001CCr 3  3A 5F 5F 3A  
0001D0r 3  3A 2F 5C 5C  
000211r 3  20 20 20 5C  welcome_logo6: .asciiz "   \\:\\_\\:\\ \\/_____\\/ \\:\\_\\:\\ \\/__\\: \\__/\\\\:\\_\\:\\ \\    \\:\\_\\ \\ \\ /____\\:\\\n"
000215r 3  3A 5C 5F 5C  
000219r 3  3A 5C 20 5C  
00025Br 3  20 20 20 20  welcome_logo7: .asciiz "    \\_____\\/\\_____/   \\_____\\/\\________\\/ \\_____\\/     \\_____\\/ \\_____\\/\n"
00025Fr 3  5C 5F 5F 5F  
000263r 3  5F 5F 5C 2F  
0002A5r 3               
0002A5r 3               .code
000000r 3               
000000r 2               .include "via.inc"                          ; include VIA labels
000000r 3               
000000r 3                   .import __VIA1_START__
000000r 3                   .import __VIA2_START__
000000r 3               
000000r 3                   VIA1B = __VIA1_START__                            ; VIA PORT B input/output register
000000r 3                   VIA1A = __VIA1_START__ + 1                        ; VIA PORT A input/output register
000000r 3                   VIA1B_DIRECTION = __VIA1_START__ + 2              ; VIA PORT B direction register is $6002
000000r 3                   VIA1A_DIRECTION = __VIA1_START__ + 3              ; VIA PORT A direction register is $6003
000000r 3                   VIA1_T1CL = __VIA1_START__ + 4                    ; Timer 1 Low order latches
000000r 3                   VIA1_T1CH = __VIA1_START__ + 5                    ; Timer 1 High order counter
000000r 3                   VIA1_ACR = __VIA1_START__ + 11                    ; Auxillary Control Register
000000r 3                   VIA1_PCR = __VIA1_START__ + 12                    ; Peripheral Control Register
000000r 3                   VIA1_IFR = __VIA1_START__ + 13                    ; Interupt Flag Register
000000r 3                   VIA1_IER = __VIA1_START__ + 14                    ; Interupt Enable Register
000000r 3               
000000r 3                   VIA2B = __VIA2_START__                            ; VIA2 PORT B input/output register
000000r 3                   VIA2A = __VIA2_START__ + 1                        ; VIA2 PORT A input/output register
000000r 3                   VIA2B_DIRECTION = __VIA2_START__ + 2              ; VIA2 PORT B direction register is $5002
000000r 3                   VIA2A_DIRECTION = __VIA2_START__ + 3              ; VIA2 PORT A direction register is $5003
000000r 3               
000000r 2               .include "../drivers/spi/spi.asm"           ; include SPI code
000000r 3               .A8
000000r 3               .I8
000000r 3               SPI_VIA = VIA1B
000000r 3               
000000r 3               ; prepares spi VIA PORT A for input output
000000r 3               InitSPI:
000000r 3  A9 47            LDA #$47
000002r 3  8D rr rr         STA VIA1B_DIRECTION
000005r 3  A9 00            LDA #$00
000007r 3  8D rr rr         STA SPI_VIA
00000Ar 3  60               RTS
00000Br 3               
00000Br 3               ; select device for spi communication
00000Br 3               SpiDeviceSelect:
00000Br 3  85 rr            STA spi_selected_device
00000Dr 3  AD rr rr         LDA SPI_VIA
000010r 3  60               RTS
000011r 3               
000011r 3               ; deselect spi device
000011r 3               SpiDeviceDeselect:
000011r 3  64 rr            STZ spi_selected_device
000013r 3  9C rr rr         STZ SPI_VIA
000016r 3  60               RTS
000017r 3               
000017r 3               
000017r 3               ; Transmit one byte SPI data. Remember to select SPI device with SpiDeviceSelect
000017r 3               ; in:
000017r 3               ;   A - byte to send over SPI
000017r 3               ; out:
000017r 3               ;   A - byte received over SPI
000017r 3               
000017r 3               SpiByte:
000017r 3  85 rr            STA spi_byte_out                            ; store
000019r 3  64 rr            STZ spi_byte_in
00001Br 3  A2 08            LDX #8
00001Dr 3  A5 rr            LDA spi_selected_device
00001Fr 3               spibytelp:
00001Fr 3  06 rr            ASL spi_byte_out	                        ; (5) shift MSB in to carry
000021r 3  90 02            BCC spibyte1
000023r 3  09 40            ORA #$40                                    ; set MOSI if MSB set
000025r 3               spibyte1:
000025r 3  8D rr rr         STA SPI_VIA	                                ; output (MOSI    SCS low   SCLK low)
000028r 3               
000028r 3  A5 rr            LDA spi_selected_device                     ; set A to selected device bit (Do it here for delay reasons)
00002Ar 3  EE rr rr         INC SPI_VIA                                 ; toggle clock high (SCLK is bit 0)
00002Dr 3               
00002Dr 3  18               CLC                                         ; clear C (Not affected by bit)
00002Er 3  2C rr rr         BIT SPI_VIA                                 ; copy MISO (bit 7) in to N (and MOSI in to V)
000031r 3  10 01            BPL spibyte2
000033r 3  38               SEC		                                    ; set C is MISO bit is set (i.e. N)
000034r 3               spibyte2:
000034r 3  26 rr            ROL spi_byte_in		                        ; copy C (i.e. MISO bit) in to bit 0 of result
000036r 3  CE rr rr         DEC SPI_VIA                                 ; toggle clock low (SCLK is bit 0)
000039r 3               
000039r 3  CA               DEX
00003Ar 3  D0 E3            BNE spibytelp;
00003Cr 3  A5 rr            LDA spi_byte_in	                            ; load result into A
00003Er 3               
00003Er 3  60               RTS
00003Fr 3               
00003Fr 2               .include "../drivers/keyboard/keyboard.asm" ; include Keyboard driver
00003Fr 3               KB_CONTROL_RELEASE      = %00000001
00003Fr 3               KB_CONTROL_RELEASE_INV  = %11111110
00003Fr 3               KB_CONTROL_EXTENDED     = %00000010
00003Fr 3               KB_CONTROL_EXTENDED_INV = %11111101
00003Fr 3               KB_CONTROL_SHIFTED      = %10000000
00003Fr 3               KB_CONTROL_SHIFTED_INV  = %01111111
00003Fr 3               
00003Fr 3               .include "keyboard_layout_iso.inc"
00003Fr 4               
00003Fr 4               .rodata
0002A5r 4               ASCIITBL:
0002A5r 4  00                          .byte $00               ; 00 no key pressed
0002A6r 4  89                          .byte $89               ; 01 F9
0002A7r 4  87                          .byte $87               ; 02 relocated F7
0002A8r 4  85                          .byte $85               ; 03 F5
0002A9r 4  83                          .byte $83               ; 04 F3
0002AAr 4  81                          .byte $81               ; 05 F1
0002ABr 4  82                          .byte $82               ; 06 F2
0002ACr 4  8C                          .byte $8C               ; 07 F12
0002ADr 4  00                          .byte $00               ; 08
0002AEr 4  8A                          .byte $8A               ; 09 F10
0002AFr 4  88                          .byte $88               ; 0A F8
0002B0r 4  86                          .byte $86               ; 0B F6
0002B1r 4  84                          .byte $84               ; 0C F4
0002B2r 4  09                          .byte $09               ; 0D tab
0002B3r 4  60                          .byte $60               ; 0E `~
0002B4r 4  8F                          .byte $8F               ; 0F relocated Print Screen key
0002B5r 4  03                          .byte $03               ; 10 relocated Pause/Break key
0002B6r 4  A0                          .byte $A0               ; 11 left alt (right alt too)
0002B7r 4  00                          .byte $00               ; 12 left shift
0002B8r 4  E0                          .byte $E0               ; 13 relocated Alt release code
0002B9r 4  00                          .byte $00               ; 14 left ctrl (right ctrl too)
0002BAr 4  71                          .byte $71               ; 15 qQ
0002BBr 4  31                          .byte $31               ; 16 1!
0002BCr 4  00                          .byte $00               ; 17
0002BDr 4  00                          .byte $00               ; 18
0002BEr 4  00                          .byte $00               ; 19
0002BFr 4  7A                          .byte $7A               ; 1A zZ
0002C0r 4  73                          .byte $73               ; 1B sS
0002C1r 4  61                          .byte $61               ; 1C aA
0002C2r 4  77                          .byte $77               ; 1D wW
0002C3r 4  32                          .byte $32               ; 1E 2@
0002C4r 4  A1                          .byte $A1               ; 1F Windows 98 menu key (left side)
0002C5r 4  02                          .byte $02               ; 20 relocated ctrl-break key
0002C6r 4  63                          .byte $63               ; 21 cC
0002C7r 4  78                          .byte $78               ; 22 xX
0002C8r 4  64                          .byte $64               ; 23 dD
0002C9r 4  65                          .byte $65               ; 24 eE
0002CAr 4  34                          .byte $34               ; 25 4$
0002CBr 4  33                          .byte $33               ; 26 3#
0002CCr 4  A2                          .byte $A2               ; 27 Windows 98 menu key (right side)
0002CDr 4  00                          .byte $00               ; 28
0002CEr 4  20                          .byte $20               ; 29 space
0002CFr 4  76                          .byte $76               ; 2A vV
0002D0r 4  66                          .byte $66               ; 2B fF
0002D1r 4  74                          .byte $74               ; 2C tT
0002D2r 4  72                          .byte $72               ; 2D rR
0002D3r 4  35                          .byte $35               ; 2E 5%
0002D4r 4  A3                          .byte $A3               ; 2F Windows 98 option key (right click, right side)
0002D5r 4  00                          .byte $00               ; 30
0002D6r 4  6E                          .byte $6E               ; 31 nN
0002D7r 4  62                          .byte $62               ; 32 bB
0002D8r 4  68                          .byte $68               ; 33 hH
0002D9r 4  67                          .byte $67               ; 34 gG
0002DAr 4  79                          .byte $79               ; 35 yY
0002DBr 4  36                          .byte $36               ; 36 6^
0002DCr 4  00                          .byte $00               ; 37
0002DDr 4  00                          .byte $00               ; 38
0002DEr 4  00                          .byte $00               ; 39
0002DFr 4  6D                          .byte $6D               ; 3A mM
0002E0r 4  6A                          .byte $6A               ; 3B jJ
0002E1r 4  75                          .byte $75               ; 3C uU
0002E2r 4  37                          .byte $37               ; 3D 7/
0002E3r 4  38                          .byte $38               ; 3E 8(
0002E4r 4  00                          .byte $00               ; 3F
0002E5r 4  00                          .byte $00               ; 40
0002E6r 4  2C                          .byte $2C               ; 41 ,<
0002E7r 4  6B                          .byte $6B               ; 42 kK
0002E8r 4  69                          .byte $69               ; 43 iI
0002E9r 4  6F                          .byte $6F               ; 44 oO
0002EAr 4  30                          .byte $30               ; 45 0=
0002EBr 4  39                          .byte $39               ; 46 9)
0002ECr 4  00                          .byte $00               ; 47
0002EDr 4  00                          .byte $00               ; 48
0002EEr 4  2E                          .byte $2E               ; 49 .>
0002EFr 4  2D                          .byte $2D               ; 4A -_
0002F0r 4  6C                          .byte $6C               ; 4B lL
0002F1r 4  3B                          .byte $3B               ; 4C ;:
0002F2r 4  70                          .byte $70               ; 4D pP
0002F3r 4  2B                          .byte $2B               ; 4E +?
0002F4r 4  00                          .byte $00               ; 4F
0002F5r 4  00                          .byte $00               ; 50
0002F6r 4  00                          .byte $00               ; 51
0002F7r 4  27                          .byte $27               ; 52 '"
0002F8r 4  00                          .byte $00               ; 53
0002F9r 4  5B                          .byte $5B               ; 54 [{
0002FAr 4  3D                          .byte $3D               ; 55 =+
0002FBr 4  00                          .byte $00               ; 56
0002FCr 4  00                          .byte $00               ; 57
0002FDr 4  00                          .byte $00               ; 58 caps
0002FEr 4  00                          .byte $00               ; 59 r shift
0002FFr 4  0A                          .byte $0A               ; 5A <Enter>
000300r 4  5D                          .byte $5D               ; 5B ]}
000301r 4  00                          .byte $00               ; 5C
000302r 4  27                          .byte $27               ; 5D '*
000303r 4  00                          .byte $00               ; 5E
000304r 4  00                          .byte $00               ; 5F
000305r 4  00                          .byte $00               ; 60
000306r 4  00                          .byte $00               ; 61
000307r 4  00                          .byte $00               ; 62
000308r 4  00                          .byte $00               ; 63
000309r 4  00                          .byte $00               ; 64
00030Ar 4  00                          .byte $00               ; 65
00030Br 4  08                          .byte $08               ; 66 bkspace
00030Cr 4  00                          .byte $00               ; 67
00030Dr 4  00                          .byte $00               ; 68
00030Er 4  31                          .byte $31               ; 69 kp 1
00030Fr 4  2F                          .byte $2f               ; 6A kp / converted from E04A in code
000310r 4  34                          .byte $34               ; 6B kp 4
000311r 4  37                          .byte $37               ; 6C kp 7
000312r 4  00                          .byte $00               ; 6D
000313r 4  00                          .byte $00               ; 6E
000314r 4  00                          .byte $00               ; 6F
000315r 4  30                          .byte $30               ; 70 kp 0
000316r 4  2E                          .byte $2E               ; 71 kp .
000317r 4  32                          .byte $32               ; 72 kp 2
000318r 4  35                          .byte $35               ; 73 kp 5
000319r 4  36                          .byte $36               ; 74 kp 6
00031Ar 4  38                          .byte $38               ; 75 kp 8
00031Br 4  1B                          .byte $1B               ; 76 esc
00031Cr 4  00                          .byte $00               ; 77 num lock
00031Dr 4  8B                          .byte $8B               ; 78 F11
00031Er 4  2B                          .byte $2B               ; 79 kp +
00031Fr 4  33                          .byte $33               ; 7A kp 3
000320r 4  2D                          .byte $2D               ; 7B kp -
000321r 4  2A                          .byte $2A               ; 7C kp *
000322r 4  39                          .byte $39               ; 7D kp 9
000323r 4  8D                          .byte $8D               ; 7E scroll lock
000324r 4  00                          .byte $00               ; 7F
000325r 4               ;
000325r 4               ; Table for shifted scancodes
000325r 4               ;
000325r 4  00                          .byte $00               ; 80
000326r 4  C9                          .byte $C9               ; 81 F9
000327r 4  C7                          .byte $C7               ; 82 relocated F7
000328r 4  C5                          .byte $C5               ; 83 F5 (F7 actual scancode=83)
000329r 4  C3                          .byte $C3               ; 84 F3
00032Ar 4  C1                          .byte $C1               ; 85 F1
00032Br 4  C2                          .byte $C2               ; 86 F2
00032Cr 4  CC                          .byte $CC               ; 87 F12
00032Dr 4  00                          .byte $00               ; 88
00032Er 4  CA                          .byte $CA               ; 89 F10
00032Fr 4  C8                          .byte $C8               ; 8A F8
000330r 4  C6                          .byte $C6               ; 8B F6
000331r 4  C4                          .byte $C4               ; 8C F4
000332r 4  09                          .byte $09               ; 8D tab
000333r 4  7E                          .byte $7E               ; 8E `~
000334r 4  CF                          .byte $CF               ; 8F relocated Print Screen key
000335r 4  03                          .byte $03               ; 90 relocated Pause/Break key
000336r 4  A0                          .byte $A0               ; 91 left alt (right alt)
000337r 4  00                          .byte $00               ; 92 left shift
000338r 4  E0                          .byte $E0               ; 93 relocated Alt release code
000339r 4  00                          .byte $00               ; 94 left ctrl (and right ctrl)
00033Ar 4  51                          .byte $51               ; 95 qQ
00033Br 4  21                          .byte $21               ; 96 1!
00033Cr 4  00                          .byte $00               ; 97
00033Dr 4  00                          .byte $00               ; 98
00033Er 4  00                          .byte $00               ; 99
00033Fr 4  5A                          .byte $5A               ; 9A zZ
000340r 4  53                          .byte $53               ; 9B sS
000341r 4  41                          .byte $41               ; 9C aA
000342r 4  57                          .byte $57               ; 9D wW
000343r 4  22                          .byte $22               ; 9E 2"
000344r 4  E1                          .byte $E1               ; 9F Windows 98 menu key (left side)
000345r 4  02                          .byte $02               ; A0 relocated ctrl-break key
000346r 4  43                          .byte $43               ; A1 cC
000347r 4  58                          .byte $58               ; A2 xX
000348r 4  44                          .byte $44               ; A3 dD
000349r 4  45                          .byte $45               ; A4 eE
00034Ar 4  24                          .byte $24               ; A5 4$
00034Br 4  23                          .byte $23               ; A6 3#
00034Cr 4  E2                          .byte $E2               ; A7 Windows 98 menu key (right side)
00034Dr 4  00                          .byte $00               ; A8
00034Er 4  20                          .byte $20               ; A9 space
00034Fr 4  56                          .byte $56               ; AA vV
000350r 4  46                          .byte $46               ; AB fF
000351r 4  54                          .byte $54               ; AC tT
000352r 4  52                          .byte $52               ; AD rR
000353r 4  25                          .byte $25               ; AE 5%
000354r 4  E3                          .byte $E3               ; AF Windows 98 option key (right click, right side)
000355r 4  00                          .byte $00               ; B0
000356r 4  4E                          .byte $4E               ; B1 nN
000357r 4  42                          .byte $42               ; B2 bB
000358r 4  48                          .byte $48               ; B3 hH
000359r 4  47                          .byte $47               ; B4 gG
00035Ar 4  59                          .byte $59               ; B5 yY
00035Br 4  5E                          .byte $5E               ; B6 6^
00035Cr 4  00                          .byte $00               ; B7
00035Dr 4  00                          .byte $00               ; B8
00035Er 4  00                          .byte $00               ; B9
00035Fr 4  4D                          .byte $4D               ; BA mM
000360r 4  4A                          .byte $4A               ; BB jJ
000361r 4  55                          .byte $55               ; BC uU
000362r 4  2F                          .byte $2F               ; BD 7/
000363r 4  28                          .byte $28               ; BE 8(
000364r 4  00                          .byte $00               ; BF
000365r 4  00                          .byte $00               ; C0
000366r 4  3B                          .byte $3B               ; C1 ,;
000367r 4  4B                          .byte $4B               ; C2 kK
000368r 4  49                          .byte $49               ; C3 iI
000369r 4  4F                          .byte $4F               ; C4 oO
00036Ar 4  3D                          .byte $3D               ; C5 0=
00036Br 4  29                          .byte $29               ; C6 9)
00036Cr 4  00                          .byte $00               ; C7
00036Dr 4  00                          .byte $00               ; C8
00036Er 4  3A                          .byte $3A               ; C9 .:
00036Fr 4  5F                          .byte $5F               ; CA -_
000370r 4  4C                          .byte $4C               ; CB lL
000371r 4  3A                          .byte $3A               ; CC ;:
000372r 4  50                          .byte $50               ; CD pP
000373r 4  3F                          .byte $3F               ; CE +?
000374r 4  00                          .byte $00               ; CF
000375r 4  00                          .byte $00               ; D0
000376r 4  00                          .byte $00               ; D1
000377r 4  22                          .byte $22               ; D2 '"
000378r 4  00                          .byte $00               ; D3
000379r 4  7B                          .byte $7B               ; D4 [{
00037Ar 4  2B                          .byte $2B               ; D5 =+
00037Br 4  00                          .byte $00               ; D6
00037Cr 4  00                          .byte $00               ; D7
00037Dr 4  00                          .byte $00               ; D8 caps
00037Er 4  00                          .byte $00               ; D9 r shift
00037Fr 4  0D                          .byte $0D               ; DA <Enter>
000380r 4  7D                          .byte $7D               ; DB ]}
000381r 4  00                          .byte $00               ; DC
000382r 4  2A                          .byte $2A               ; DD '*
000383r 4  00                          .byte $00               ; DE
000384r 4  00                          .byte $00               ; DF
000385r 4  00                          .byte $00               ; E0
000386r 4  00                          .byte $00               ; E1
000387r 4  00                          .byte $00               ; E2
000388r 4  00                          .byte $00               ; E3
000389r 4  00                          .byte $00               ; E4
00038Ar 4  00                          .byte $00               ; E5
00038Br 4  08                          .byte $08               ; E6 bkspace
00038Cr 4  00                          .byte $00               ; E7
00038Dr 4  00                          .byte $00               ; E8
00038Er 4  91                          .byte $91               ; E9 kp 1
00038Fr 4  2F                          .byte $2f               ; EA kp / converted from E04A in code
000390r 4  94                          .byte $94               ; EB kp 4
000391r 4  97                          .byte $97               ; EC kp 7
000392r 4  00                          .byte $00               ; ED
000393r 4  00                          .byte $00               ; EE
000394r 4  00                          .byte $00               ; EF
000395r 4  90                          .byte $90               ; F0 kp 0
000396r 4  7F                          .byte $7F               ; F1 kp .
000397r 4  92                          .byte $92               ; F2 kp 2
000398r 4  95                          .byte $95               ; F3 kp 5
000399r 4  96                          .byte $96               ; F4 kp 6
00039Ar 4  98                          .byte $98               ; F5 kp 8
00039Br 4  1B                          .byte $1B               ; F6 esc
00039Cr 4  00                          .byte $00               ; F7 num lock
00039Dr 4  CB                          .byte $CB               ; F8 F11
00039Er 4  2B                          .byte $2B               ; F9 kp +
00039Fr 4  93                          .byte $93               ; FA kp 3
0003A0r 4  2D                          .byte $2D               ; FB kp -
0003A1r 4  2A                          .byte $2A               ; FC kp *
0003A2r 4  99                          .byte $99               ; FD kp 9
0003A3r 4  CD                          .byte $CD               ; FE scroll lock
0003A4r 4               ; NOT USED     .byte $00               ; FF
0003A4r 4               ; end
0003A4r 4               
0003A4r 3               
0003A4r 3               .SEGMENT "RAM"
000000r 3  xx               kb_byte:                            .res 1
000001r 3                   ; control byte:
000001r 3                   ; bit 0         - release
000001r 3                   ; bit 1         - extended
000001r 3                   ; bit 7         - shifted
000001r 3  xx               kb_control_byte:                    .res 1
000002r 3               
000002r 3               .code
00003Fr 3               
00003Fr 3               InterruptKeyboard:
00003Fr 3               
00003Fr 3  E2 30            shortr
000041r 3  AD rr rr         lda VIA1A                               ; read byte from VIA
000044r 3  8D rr rr         sta kb_byte
000047r 3               
000047r 3               ; DEBUG SCANCODE
000047r 3                   ; lda #'['
000047r 3                   ; jsl RA8875_WriteChar
000047r 3                   ; lda kb_byte
000047r 3                   ; jsl RA8875_WriteHex
000047r 3                   ; lda #']'
000047r 3                   ; jsl RA8875_WriteChar
000047r 3               
000047r 3                   ; Check control byte first
000047r 3  AD rr rr         lda kb_control_byte
00004Ar 3  29 01            and #KB_CONTROL_RELEASE
00004Cr 3  D0 5F            bne keyboardHandleRelease               ; Is release control set?
00004Er 3  AD rr rr         lda kb_control_byte
000051r 3  29 02            and #KB_CONTROL_EXTENDED
000053r 3  D0 79            bne keyboardHandleExtended              ; Is extended control set?
000055r 3               
000055r 3               
000055r 3  AD rr rr         lda kb_byte
000058r 3               
000058r 3  20 rr rr         jsr keyboardCommandTest                 ; Test for non printable scan codes
00005Br 3  F0 03            beq InterruptKeyboardReturn             ; 0 means key is handled as command
00005Dr 3               
00005Dr 3               
00005Dr 3  20 rr rr         jsr keyboardHandleAscii                 ; Handle as ASCII
000060r 3               
000060r 3               InterruptKeyboardReturn:
000060r 3  2C rr rr         bit VIA1A
000063r 3               
000063r 3  60               rts
000064r 3               
000064r 3               .A8
000064r 3               .I8
000064r 3               keyboardHandleAscii:
000064r 3  AD rr rr         lda kb_control_byte
000067r 3  29 80            and #KB_CONTROL_SHIFTED                 ; Set bit 7 is shifted
000069r 3  0D rr rr         ora kb_byte
00006Cr 3               
00006Cr 3  AA               tax
00006Dr 3  BD rr rr         lda ASCIITBL,x
000070r 3               
000070r 3  A2 00            ldx #STREAM_STDIN
000072r 3                   ;jsl RA8875_WriteChar                    ; TODO: Do not print here
000072r 3  22 rr rr rr      jsl StreamPutC                          ; Put in standard in stream
000076r 3               
000076r 3               
000076r 3               ; DEBUG SINGLE KEY COMMANDS. TODO REMOVE THIS
000076r 3  C9 69            cmp #$69
000078r 3  D0 0E            bne @next1
00007Ar 3  AD rr rr         lda TaskSwitches+1
00007Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000081r 3  AD rr rr         lda TaskSwitches
000084r 3  22 rr rr rr      jsl RA8875_WriteHex
000088r 3               @next1:
000088r 3  C9 6A            cmp #$6A
00008Ar 3  D0 0E            bne @next2
00008Cr 3  AD rr rr         lda TimerCounter+1
00008Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000093r 3  AD rr rr         lda TimerCounter
000096r 3  22 rr rr rr      jsl RA8875_WriteHex
00009Ar 3               
00009Ar 3               
00009Ar 3               @next2:
00009Ar 3  C9 6B            cmp #$6B
00009Cr 3  D0 0E            bne @return
00009Er 3  AD rr rr         lda ClockCounter+1
0000A1r 3  22 rr rr rr      jsl RA8875_WriteHex
0000A5r 3  AD rr rr         lda ClockCounter
0000A8r 3  22 rr rr rr      jsl RA8875_WriteHex
0000ACr 3               ; END DEBUG
0000ACr 3               
0000ACr 3               @return:
0000ACr 3  60               rts
0000ADr 3               
0000ADr 3               keyboardHandleRelease:
0000ADr 3  AD rr rr         lda kb_control_byte
0000B0r 3  29 FE            and #KB_CONTROL_RELEASE_INV
0000B2r 3  8D rr rr         sta kb_control_byte
0000B5r 3                   ; TODO: Toggle released key
0000B5r 3                   ;       Have a map of which keys are pressed
0000B5r 3               
0000B5r 3                   ; TODO Handle control release
0000B5r 3  AD rr rr         lda kb_byte
0000B8r 3  C9 12            cmp #$12                                ; left shift released
0000BAr 3  F0 07            beq kbClearShifted
0000BCr 3  C9 59            cmp #$59                                ; right shift released
0000BEr 3  F0 03            beq kbClearShifted
0000C0r 3               keyboardHandleReleaseCont1:
0000C0r 3  4C rr rr         jmp InterruptKeyboardReturn
0000C3r 3               
0000C3r 3               kbClearShifted:
0000C3r 3  AD rr rr         lda kb_control_byte
0000C6r 3  29 7F            and #KB_CONTROL_SHIFTED_INV
0000C8r 3  8D rr rr         sta kb_control_byte
0000CBr 3  4C rr rr         jmp keyboardHandleReleaseCont1
0000CEr 3               
0000CEr 3               keyboardHandleExtended:
0000CEr 3  AD rr rr         lda kb_control_byte
0000D1r 3  29 FD            and #KB_CONTROL_EXTENDED_INV
0000D3r 3  8D rr rr         sta kb_control_byte
0000D6r 3                   ; TODO: Handle extended key
0000D6r 3  4C rr rr         jmp InterruptKeyboardReturn
0000D9r 3               
0000D9r 3               keyboardCommandTest:
0000D9r 3  A2 04            ldx #$04
0000DBr 3               keyboardCommandTestLoop:
0000DBr 3  DD rr rr         cmp kbcommands,x
0000DEr 3  F0 04            beq keyboardCommandRun
0000E0r 3  CA               dex
0000E1r 3  10 F8            bpl keyboardCommandTestLoop
0000E3r 3  60               rts
0000E4r 3               
0000E4r 3               keyboardCommandRun:
0000E4r 3  8A               txa
0000E5r 3  0A               asl                                 ; *2 to get address from lookup table
0000E6r 3  AA               tax
0000E7r 3  7C rr rr         jmp (kbCommandRoutines,x)           ; Jmp to the command routine
0000EAr 3               
0000EAr 3               kbcommands:
0000EAr 3  12               .byte $12       ; left shift
0000EBr 3  59               .byte $59       ; right shift
0000ECr 3  14               .byte $14       ; left ctrl
0000EDr 3  E0               .byte $E0       ; extended
0000EEr 3  F0               .byte $F0       ; break
0000EFr 3                   ; TODO: Add right control
0000EFr 3               
0000EFr 3               kbCommandRoutines:
0000EFr 3  rr rr            .word kbSetShifted
0000F1r 3  rr rr            .word kbSetShifted
0000F3r 3  rr rr            .word kbnull                        ; TODO: Handle left control
0000F5r 3  rr rr            .word kbSetExtended
0000F7r 3  rr rr            .word kbSetBreak
0000F9r 3               
0000F9r 3               kbSetExtended:
0000F9r 3  AD rr rr         lda kb_control_byte
0000FCr 3  09 02            ora #KB_CONTROL_EXTENDED
0000FEr 3  8D rr rr         sta kb_control_byte
000101r 3  4C rr rr         jmp kbnull
000104r 3               
000104r 3               kbSetShifted:
000104r 3  AD rr rr         lda kb_control_byte
000107r 3  09 80            ora #KB_CONTROL_SHIFTED
000109r 3  8D rr rr         sta kb_control_byte
00010Cr 3  4C rr rr         jmp kbnull
00010Fr 3               
00010Fr 3               kbSetBreak:
00010Fr 3  AD rr rr         lda kb_control_byte
000112r 3  09 01            ora #KB_CONTROL_RELEASE
000114r 3  8D rr rr         sta kb_control_byte
000117r 3  4C rr rr         jmp kbnull
00011Ar 3               
00011Ar 3               kbnull:
00011Ar 3  A9 00            lda #$00
00011Cr 3  60               rts
00011Dr 3               
00011Dr 3               ; Initialize Keyboard driver
00011Dr 3               InitKeyboard:
00011Dr 3  E2 30            shortr
00011Fr 3  9C rr rr         stz kb_control_byte
000122r 3  9C rr rr         stz kb_byte
000125r 3               
000125r 3  9C rr rr         stz VIA1A_DIRECTION             ; read input
000128r 3  A9 82            lda #%10000010
00012Ar 3  8D rr rr         sta VIA1_IER
00012Dr 3               
00012Dr 3  A9 00            lda #$00
00012Fr 3  8D rr rr         sta VIA1_PCR
000132r 3  C2 30            longr
000134r 3               
000134r 3  60               rts
000135r 3               
000135r 3               
000135r 3               
000135r 2               .include "../drivers/ra8875/ra8875.asm"     ; include Driver for RA8875
000135r 3               .A8
000135r 3               .I8
000135r 3                   .include "ra8875.inc"
000135r 4               SPI_DEVICE_RA8875 = $04
000135r 4               
000135r 4               RA8875_DATAWRITE = $00
000135r 4               RA8875_DATAREAD = $40
000135r 4               RA8875_CMDWRITE = $80
000135r 4               
000135r 4               RA8875_SYSR = $10
000135r 4               RA8875_SYSR_8BPP = $00
000135r 4               RA8875_SYSR_16BPP = $0C
000135r 4               RA8875_SYSR_MCU8 = $00
000135r 4               
000135r 4               RA8875_PLLC1 = $88
000135r 4               RA8875_PLLC1_PLLDIV2 = $80
000135r 4               RA8875_PLLC1_PLLDIV1 = $00
000135r 4               
000135r 4               RA8875_PLLC2 = $89
000135r 4               RA8875_PLLC2_DIV4 = $02
000135r 4               
000135r 4               RA8875_PCSR = $04
000135r 4               RA8875_PCSR_PDATL = $80
000135r 4               RA8875_PCSR_2CLK = $01
000135r 4               
000135r 4               RA8875_HDWR = $14
000135r 4               RA8875_HNDFTR = $15
000135r 4               RA8875_HNDFTR_DE_HIGH = $00
000135r 4               RA8875_HNDR = $16
000135r 4               RA8875_HSTR = $17
000135r 4               RA8875_HPWR = $18
000135r 4               RA8875_HPWR_LOW = $00
000135r 4               
000135r 4               RA8875_VDHR0 = $19
000135r 4               RA8875_VDHR1 = $1A
000135r 4               RA8875_VNDR0 = $1B
000135r 4               RA8875_VNDR1 = $1C
000135r 4               RA8875_VSTR0 = $1D
000135r 4               RA8875_VSTR1 = $1E
000135r 4               RA8875_VPWR = $1F
000135r 4               RA8875_VPWR_LOW = $00
000135r 4               
000135r 4               RA8875_HSAW0 = $30
000135r 4               RA8875_HSAW1 = $31
000135r 4               RA8875_HEAW0 = $34
000135r 4               RA8875_HEAW1 = $35
000135r 4               
000135r 4               RA8875_VSAW0 = $32
000135r 4               RA8875_VSAW1 = $33
000135r 4               RA8875_VEAW0 = $36
000135r 4               RA8875_VEAW1 = $37
000135r 4               
000135r 4               RA8875_FGCR0 = $63
000135r 4               RA8875_FGCR1 = $64
000135r 4               RA8875_FGCR2 = $65
000135r 4               
000135r 4               RA8875_MCLR = $8E
000135r 4               RA8875_MCLR_START = $80
000135r 4               RA8875_MCLR_FULL = $00
000135r 4               
000135r 4               RA8875_PWRR = $01
000135r 4               RA8875_PWRR_NORMAL = $00
000135r 4               RA8875_PWRR_DISPON = $80
000135r 4               
000135r 4               RA8875_P1CR = $8A
000135r 4               RA8875_P1CR_ENABLE = $80
000135r 4               RA8875_PWM_CLK_DIV1024 = $0A
000135r 4               RA8875_PWM_CLK_DIV8 = $03
000135r 4               
000135r 4               RA8875_P1DCR = $8B
000135r 4               
000135r 4               RA8875_MWCR0 = $40
000135r 4               RA8875_MWCR0_TXTMODE = $80
000135r 4               
000135r 4               RA8875_MWCR0_CURSOR = $40
000135r 4               RA8875_MWCR0_BLINK = $20
000135r 4               
000135r 4               RA8875_F_CURXL = $2A
000135r 4               RA8875_F_CURXH = $2B
000135r 4               RA8875_F_CURYL = $2C
000135r 4               RA8875_F_CURYH = $2D
000135r 4               
000135r 4               RA8875_BTCR = $44
000135r 4               
000135r 4               RA8875_FNCR0 = $21
000135r 4               
000135r 4               RA8875_MRWC = $02
000135r 4               
000135r 4               RA8875_GPIOX = $C7
000135r 4               
000135r 4               
000135r 4               RA8875_WIDTH = 800
000135r 4               RA8875_HEIGHT = 480
000135r 4               RA8875_hsync_nondisp = 26
000135r 4               RA8875_hsync_start = 32
000135r 4               RA8875_hsync_pw = 96
000135r 4               RA8875_hsync_finetune = 0
000135r 4               RA8875_vsync_nondisp = 32
000135r 4               RA8875_vsync_start = 23
000135r 4               RA8875_vsync_pw = 2
000135r 4               
000135r 4               RA_1 = $20
000135r 4               RA_2 = $21
000135r 4               
000135r 3               
000135r 3               ; Write Data  destroy A
000135r 3               ; in
000135r 3               ;   A - Data
000135r 3               RA8875WriteData:
000135r 3  48               PHA
000136r 3  A9 04            LDA #SPI_DEVICE_RA8875
000138r 3  20 rr rr         JSR SpiDeviceSelect
00013Br 3  A9 00            LDA #RA8875_DATAWRITE
00013Dr 3  20 rr rr         JSR SpiByte
000140r 3  68               PLA
000141r 3  20 rr rr         JSR SpiByte
000144r 3  20 rr rr         JSR SpiDeviceDeselect
000147r 3  60               RTS
000148r 3               
000148r 3               ; Write Command  destroy A
000148r 3               ; in
000148r 3               ;   A - Data
000148r 3               RA8875WriteCommand:
000148r 3  48               PHA
000149r 3  A9 04            LDA #SPI_DEVICE_RA8875
00014Br 3  20 rr rr         JSR SpiDeviceSelect
00014Er 3  A9 80            LDA #RA8875_CMDWRITE
000150r 3  20 rr rr         JSR SpiByte
000153r 3  68               PLA
000154r 3  20 rr rr         JSR SpiByte
000157r 3  20 rr rr         JSR SpiDeviceDeselect
00015Ar 3  60               RTS
00015Br 3               
00015Br 3               ; Read Command  destroy A
00015Br 3               ; in
00015Br 3               ;   A - Register to read
00015Br 3               ; out
00015Br 3               ;   A - Data from register
00015Br 3               RA8875ReadCommand:
00015Br 3  20 rr rr         JSR RA8875WriteCommand
00015Er 3  A9 04            LDA #SPI_DEVICE_RA8875
000160r 3  20 rr rr         JSR SpiDeviceSelect
000163r 3  A9 40            LDA #RA8875_DATAREAD
000165r 3  20 rr rr         JSR SpiByte
000168r 3  20 rr rr         JSR SpiByte
00016Br 3  20 rr rr         JSR SpiDeviceDeselect
00016Er 3  60               RTS
00016Fr 3               
00016Fr 3               ; Initialize the RA8875  destroy AX
00016Fr 3               InitRA8875:
00016Fr 3               
00016Fr 3               ; PLL settings
00016Fr 3  A9 88            LDA #RA8875_PLLC1
000171r 3  20 rr rr         JSR RA8875WriteCommand
000174r 3  A9 0A            LDA #(RA8875_PLLC1_PLLDIV1+10)
000176r 3  20 rr rr         JSR RA8875WriteData
000179r 3               
000179r 3  20 rr rr         JSR LongDelay
00017Cr 3               
00017Cr 3  A9 89            LDA #RA8875_PLLC2
00017Er 3  20 rr rr         JSR RA8875WriteCommand
000181r 3  A9 02            LDA #RA8875_PLLC2_DIV4
000183r 3  20 rr rr         JSR RA8875WriteData
000186r 3               
000186r 3  20 rr rr         JSR LongDelay
000189r 3               ; Color mode  MCU size
000189r 3  A9 10            LDA #RA8875_SYSR
00018Br 3  20 rr rr         JSR RA8875WriteCommand
00018Er 3                   ; For 16 bit color
00018Er 3                   ; LDA #(RA8875_SYSR_16BPP | RA8875_SYSR_MCU8)
00018Er 3  A9 00            LDA #(RA8875_SYSR_8BPP | RA8875_SYSR_MCU8)
000190r 3  20 rr rr         JSR RA8875WriteData
000193r 3               
000193r 3  20 rr rr         JSR LongDelay
000196r 3               
000196r 3               ; Pixel clock
000196r 3  A9 04            LDA #RA8875_PCSR
000198r 3  20 rr rr         JSR RA8875WriteCommand
00019Br 3  A9 81            LDA #(RA8875_PCSR_PDATL | RA8875_PCSR_2CLK)
00019Dr 3  20 rr rr         JSR RA8875WriteData
0001A0r 3               
0001A0r 3  20 rr rr         JSR LongDelay
0001A3r 3               
0001A3r 3               ; Horizontal settings
0001A3r 3  A9 14            LDA #RA8875_HDWR
0001A5r 3  20 rr rr         JSR RA8875WriteCommand
0001A8r 3  A9 63            LDA #((RA8875_WIDTH / 8) - 1)
0001AAr 3  20 rr rr         JSR RA8875WriteData
0001ADr 3               
0001ADr 3  A9 15            LDA #RA8875_HNDFTR
0001AFr 3  20 rr rr         JSR RA8875WriteCommand
0001B2r 3  A9 00            LDA #(RA8875_HNDFTR_DE_HIGH + RA8875_hsync_finetune)
0001B4r 3  20 rr rr         JSR RA8875WriteData
0001B7r 3               
0001B7r 3  A9 16            LDA #RA8875_HNDR
0001B9r 3  20 rr rr         JSR RA8875WriteCommand
0001BCr 3  A9 03            LDA #((RA8875_hsync_nondisp - RA8875_hsync_finetune - 2) / 8)
0001BEr 3  20 rr rr         JSR RA8875WriteData
0001C1r 3               
0001C1r 3  A9 17            LDA #RA8875_HSTR
0001C3r 3  20 rr rr         JSR RA8875WriteCommand
0001C6r 3  A9 03            LDA #((RA8875_hsync_start / 8) - 1)
0001C8r 3  20 rr rr         JSR RA8875WriteData
0001CBr 3               
0001CBr 3  A9 18            LDA #RA8875_HPWR
0001CDr 3  20 rr rr         JSR RA8875WriteCommand
0001D0r 3  A9 0B            LDA #(RA8875_HPWR_LOW + ((RA8875_hsync_pw / 8) - 1))
0001D2r 3  20 rr rr         JSR RA8875WriteData
0001D5r 3               
0001D5r 3               ; Vertical settings
0001D5r 3  A9 19            LDA #RA8875_VDHR0
0001D7r 3  20 rr rr         JSR RA8875WriteCommand
0001DAr 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
0001DCr 3  20 rr rr         JSR RA8875WriteData
0001DFr 3               
0001DFr 3  A9 1A            LDA #RA8875_VDHR1
0001E1r 3  20 rr rr         JSR RA8875WriteCommand
0001E4r 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
0001E6r 3  20 rr rr         JSR RA8875WriteData
0001E9r 3               
0001E9r 3  A9 1B            LDA #RA8875_VNDR0
0001EBr 3  20 rr rr         JSR RA8875WriteCommand
0001EEr 3  A9 1F            LDA #(RA8875_vsync_nondisp - 1)
0001F0r 3  20 rr rr         JSR RA8875WriteData
0001F3r 3               
0001F3r 3  A9 1C            LDA #RA8875_VNDR1
0001F5r 3  20 rr rr         JSR RA8875WriteCommand
0001F8r 3  A9 00            LDA #(RA8875_vsync_nondisp >> 8)
0001FAr 3  20 rr rr         JSR RA8875WriteData
0001FDr 3               
0001FDr 3  A9 1D            LDA #RA8875_VSTR0
0001FFr 3  20 rr rr         JSR RA8875WriteCommand
000202r 3  A9 16            LDA #(RA8875_vsync_start - 1)
000204r 3  20 rr rr         JSR RA8875WriteData
000207r 3               
000207r 3  A9 1E            LDA #RA8875_VSTR1
000209r 3  20 rr rr         JSR RA8875WriteCommand
00020Cr 3  A9 00            LDA #(RA8875_vsync_start >> 8)
00020Er 3  20 rr rr         JSR RA8875WriteData
000211r 3               
000211r 3  A9 1F            LDA #RA8875_VPWR
000213r 3  20 rr rr         JSR RA8875WriteCommand
000216r 3  A9 01            LDA #(RA8875_VPWR_LOW + RA8875_vsync_pw - 1)
000218r 3  20 rr rr         JSR RA8875WriteData
00021Br 3               
00021Br 3               ; Set active window X
00021Br 3               
00021Br 3  A9 30            LDA #RA8875_HSAW0
00021Dr 3  20 rr rr         JSR RA8875WriteCommand
000220r 3  A9 00            LDA #0
000222r 3  20 rr rr         JSR RA8875WriteData
000225r 3               
000225r 3  A9 31            LDA #RA8875_HSAW1
000227r 3  20 rr rr         JSR RA8875WriteCommand
00022Ar 3  A9 00            LDA #0
00022Cr 3  20 rr rr         JSR RA8875WriteData
00022Fr 3               
00022Fr 3  A9 34            LDA #RA8875_HEAW0
000231r 3  20 rr rr         JSR RA8875WriteCommand
000234r 3  A9 1F            LDA #((RA8875_WIDTH - 1) & $FF)
000236r 3  20 rr rr         JSR RA8875WriteData
000239r 3               
000239r 3  A9 35            LDA #RA8875_HEAW1
00023Br 3  20 rr rr         JSR RA8875WriteCommand
00023Er 3  A9 03            LDA #((RA8875_WIDTH - 1) >> 8)
000240r 3  20 rr rr         JSR RA8875WriteData
000243r 3               
000243r 3               ; Set active window Y
000243r 3               
000243r 3  A9 32            LDA #RA8875_VSAW0
000245r 3  20 rr rr         JSR RA8875WriteCommand
000248r 3  A9 00            LDA #0
00024Ar 3  20 rr rr         JSR RA8875WriteData
00024Dr 3               
00024Dr 3  A9 33            LDA #RA8875_VSAW1
00024Fr 3  20 rr rr         JSR RA8875WriteCommand
000252r 3  A9 00            LDA #0
000254r 3  20 rr rr         JSR RA8875WriteData
000257r 3               
000257r 3  A9 36            LDA #RA8875_VEAW0
000259r 3  20 rr rr         JSR RA8875WriteCommand
00025Cr 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
00025Er 3  20 rr rr         JSR RA8875WriteData
000261r 3               
000261r 3  A9 37            LDA #RA8875_VEAW1
000263r 3  20 rr rr         JSR RA8875WriteCommand
000266r 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
000268r 3  20 rr rr         JSR RA8875WriteData
00026Br 3               
00026Br 3               ; Clear entire screen
00026Br 3               
00026Br 3  A9 8E            LDA #RA8875_MCLR
00026Dr 3  20 rr rr         JSR RA8875WriteCommand
000270r 3  A9 80            LDA #(RA8875_MCLR_START | RA8875_MCLR_FULL)
000272r 3  20 rr rr         JSR RA8875WriteData
000275r 3               
000275r 3  20 rr rr         JSR LongDelay
000278r 3               
000278r 3               ; Display on
000278r 3  A9 01            LDA #RA8875_PWRR
00027Ar 3  20 rr rr         JSR RA8875WriteCommand
00027Dr 3               
00027Dr 3  A9 80            LDA #(RA8875_PWRR_NORMAL | RA8875_PWRR_DISPON)
00027Fr 3  20 rr rr         JSR RA8875WriteData
000282r 3               
000282r 3               ; GPIOX on    enable tft
000282r 3  A9 C7            LDA #RA8875_GPIOX
000284r 3  20 rr rr         JSR RA8875WriteCommand
000287r 3  A9 01            LDA #1
000289r 3  20 rr rr         JSR RA8875WriteData
00028Cr 3               
00028Cr 3               
00028Cr 3               ; PWM1 Config backlight
00028Cr 3  A9 8A            LDA #RA8875_P1CR
00028Er 3  20 rr rr         JSR RA8875WriteCommand
000291r 3  A9 8A            LDA #(RA8875_P1CR_ENABLE | (RA8875_PWM_CLK_DIV1024 & $F))
000293r 3  20 rr rr         JSR RA8875WriteData
000296r 3               
000296r 3               ; Backlight clock
000296r 3  A9 8B            LDA #RA8875_P1DCR
000298r 3  20 rr rr         JSR RA8875WriteCommand
00029Br 3  A9 FF            LDA #255
00029Dr 3  20 rr rr         JSR RA8875WriteData
0002A0r 3               
0002A0r 3               ; Set text mode
0002A0r 3  20 rr rr         JSR RA8875_TextMode
0002A3r 3               
0002A3r 3  64 rr            STZ cursor_x
0002A5r 3               
0002A5r 3  64 rr            STZ cursor_x + 1
0002A7r 3               
0002A7r 3  64 rr            STZ cursor_y
0002A9r 3               
0002A9r 3  64 rr            STZ cursor_y + 1
0002ABr 3               
0002ABr 3  20 rr rr         JSR RA8875_SetTextCursor
0002AEr 3               
0002AEr 3  A9 FF            LDA #$FF
0002B0r 3  20 rr rr         JSR RA8875_SetForegroundColor
0002B3r 3               
0002B3r 3  60               RTS
0002B4r 3               
0002B4r 3               RA8875_CursorBlink:
0002B4r 3               
0002B4r 3  A9 40            LDA #RA8875_MWCR0
0002B6r 3  20 rr rr         JSR RA8875WriteCommand
0002B9r 3               
0002B9r 3  A9 C0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR)
0002BBr 3  20 rr rr         JSR RA8875WriteData
0002BEr 3               
0002BEr 3  A9 40            LDA #RA8875_MWCR0
0002C0r 3  20 rr rr         JSR RA8875WriteCommand
0002C3r 3               
0002C3r 3  A9 E0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR | RA8875_MWCR0_BLINK)
0002C5r 3  20 rr rr         JSR RA8875WriteData
0002C8r 3               
0002C8r 3  A9 44            LDA #RA8875_BTCR
0002CAr 3  20 rr rr         JSR RA8875WriteCommand
0002CDr 3               
0002CDr 3  A9 20            LDA #32                        ; Blink rate 1-255 1 is fast
0002CFr 3  20 rr rr         JSR RA8875WriteData
0002D2r 3               
0002D2r 3  60               RTS
0002D3r 3               
0002D3r 3               RA8875_CursorHide:
0002D3r 3               
0002D3r 3  A9 40            LDA #RA8875_MWCR0
0002D5r 3  20 rr rr         JSR RA8875WriteCommand
0002D8r 3               
0002D8r 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
0002DAr 3  20 rr rr         JSR RA8875WriteData
0002DDr 3               
0002DDr 3  60               RTS
0002DEr 3               
0002DEr 3               RA8875_GetTextCursorX:
0002DEr 3  A9 2B            LDA #RA8875_F_CURXH
0002E0r 3  20 rr rr         JSR RA8875ReadCommand
0002E3r 3  85 rr            STA cursor_x+1
0002E5r 3               
0002E5r 3  A9 2A            LDA #RA8875_F_CURXL
0002E7r 3  20 rr rr         JSR RA8875ReadCommand
0002EAr 3  85 rr            STA cursor_x
0002ECr 3               
0002ECr 3  60               RTS
0002EDr 3               
0002EDr 3               RA8875_GetTextCursorY:
0002EDr 3  A9 2D            LDA #RA8875_F_CURYH
0002EFr 3  20 rr rr         JSR RA8875ReadCommand
0002F2r 3  85 rr            STA cursor_y+1
0002F4r 3               
0002F4r 3  A9 2C            LDA #RA8875_F_CURYL
0002F6r 3  20 rr rr         JSR RA8875ReadCommand
0002F9r 3  85 rr            STA cursor_y
0002FBr 3               
0002FBr 3  60               RTS
0002FCr 3               
0002FCr 3               RA8875_SetTextCursor:
0002FCr 3  A9 2A            LDA #RA8875_F_CURXL
0002FEr 3  20 rr rr         JSR RA8875WriteCommand
000301r 3  A5 rr            LDA cursor_x
000303r 3  20 rr rr         JSR RA8875WriteData
000306r 3               
000306r 3  A9 2B            LDA #RA8875_F_CURXH
000308r 3  20 rr rr         JSR RA8875WriteCommand
00030Br 3  A5 rr            LDA cursor_x+1
00030Dr 3  20 rr rr         JSR RA8875WriteData
000310r 3               
000310r 3               
000310r 3  A9 2C            LDA #RA8875_F_CURYL
000312r 3  20 rr rr         JSR RA8875WriteCommand
000315r 3  A5 rr            LDA cursor_y
000317r 3  20 rr rr         JSR RA8875WriteData
00031Ar 3               
00031Ar 3  A9 2D            LDA #RA8875_F_CURYH
00031Cr 3  20 rr rr         JSR RA8875WriteCommand
00031Fr 3  A5 rr            LDA cursor_y+1
000321r 3  20 rr rr         JSR RA8875WriteData
000324r 3               
000324r 3  60               RTS
000325r 3               
000325r 3               
000325r 3               RA8875_TextMode:
000325r 3  A9 40            LDA #RA8875_MWCR0
000327r 3  20 rr rr         JSR RA8875WriteCommand
00032Ar 3               
00032Ar 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
00032Cr 3  20 rr rr         JSR RA8875WriteData
00032Fr 3               
00032Fr 3               ; select internal font
00032Fr 3  A9 21            LDA #RA8875_FNCR0
000331r 3  20 rr rr         JSR RA8875WriteCommand
000334r 3               
000334r 3  A9 00            LDA #0
000336r 3  20 rr rr         JSR RA8875WriteData
000339r 3               
000339r 3  60               RTS
00033Ar 3               
00033Ar 3               RA8875_SetForegroundColor:
00033Ar 3  48               PHA
00033Br 3  48               PHA
00033Cr 3                       ; writeCommand(0x63);
00033Cr 3                       ; writeData((foreColor & 0xf800) >> 11);
00033Cr 3                       ; writeCommand(0x64);
00033Cr 3                       ; writeData((foreColor & 0x07e0) >> 5);
00033Cr 3                       ; writeCommand(0x65);
00033Cr 3                       ; writeData((foreColor & 0x001f));
00033Cr 3  A9 65            LDA #RA8875_FGCR2
00033Er 3  20 rr rr         JSR RA8875WriteCommand
000341r 3               
000341r 3  68               PLA
000342r 3  20 rr rr         JSR RA8875WriteData
000345r 3               
000345r 3  A9 64            LDA #RA8875_FGCR1
000347r 3  20 rr rr         JSR RA8875WriteCommand
00034Ar 3               
00034Ar 3  68               PLA
00034Br 3  4A               lsr
00034Cr 3  4A               lsr
00034Dr 3  48               PHA
00034Er 3               
00034Er 3  20 rr rr         JSR RA8875WriteData
000351r 3               
000351r 3  A9 63            LDA #RA8875_FGCR0
000353r 3  20 rr rr         JSR RA8875WriteCommand
000356r 3               
000356r 3  68               PLA
000357r 3               
000357r 3  4A               lsr
000358r 3  4A               lsr
000359r 3  4A               lsr
00035Ar 3               
00035Ar 3  20 rr rr         JSR RA8875WriteData
00035Dr 3  60               RTS
00035Er 3               
00035Er 3               ; Handle a single char
00035Er 3               RA8875_SingleChar:
00035Er 3  C9 20            CMP #$20                        ; $20 or greater
000360r 3  B0 18            BCS RA8875_WriteStringChar      ; then print character
000362r 3  C9 0A            CMP #$0A                        ; Compare to 0x0A   line feed
000364r 3  D0 04            BNE @check_1                    ; != 0x0A
000366r 3  20 rr rr         JSR RA8875_ControlLineFeed      ; Handle as line feed
000369r 3  60               rts                             ; Do not print
00036Ar 3               @check_1:
00036Ar 3  C9 0D            CMP #$0D                         ; Compare to 0D   carriage return
00036Cr 3  D0 04            BNE @check_2                      ; != 0x0D
00036Er 3  20 rr rr         JSR RA8875_ControlCarriageReturn ; handle as carriage return
000371r 3  60               rts                             ; Do not print
000372r 3               @check_2:
000372r 3  C9 1B            CMP #$1B                         ; Compare to 1B   escape
000374r 3  D0 04            BNE RA8875_WriteStringChar       ; != 0x1B
000376r 3  20 rr rr         JSR RA8875_ControlEscape         ; handle as escape sequence
000379r 3  60               rts                             ; Do not print
00037Ar 3               
00037Ar 3               RA8875_WriteStringChar:
00037Ar 3  20 rr rr         JSR RA8875WriteData
00037Dr 3  60               RTS
00037Er 3               
00037Er 3               RA8875_ControlLineFeed:
00037Er 3  64 rr            STZ cursor_x                    ; Control char LINE FEED
000380r 3  64 rr            STZ cursor_x+1
000382r 3  20 rr rr         JSR RA8875_GetTextCursorY
000385r 3  18               CLC
000386r 3  69 10            ADC #16
000388r 3  85 rr            STA cursor_y
00038Ar 3  A5 rr            LDA cursor_y+1
00038Cr 3  69 00            ADC #$00
00038Er 3  85 rr            STA cursor_y+1
000390r 3                   ; TODO: It overflows here. Needs two bytes to handle cursor value
000390r 3  20 rr rr         JSR RA8875_SetTextCursor
000393r 3  A9 02            LDA #RA8875_MRWC
000395r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
000398r 3  60               RTS
000399r 3               
000399r 3               RA8875_ControlCarriageReturn:
000399r 3  64 rr            STZ cursor_x                    ; Control char LINE FEED
00039Br 3  64 rr            STZ cursor_x+1
00039Dr 3  20 rr rr         JSR RA8875_GetTextCursorY
0003A0r 3  20 rr rr         JSR RA8875_SetTextCursor
0003A3r 3  A9 02            LDA #RA8875_MRWC
0003A5r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
0003A8r 3  60               RTS
0003A9r 3               
0003A9r 3               RA8875_ControlEscape:
0003A9r 3  C8               INY                             ; Look at next character
0003AAr 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003ACr 3  F0 2C            BEQ SkipControl
0003AEr 3  C9 5B            CMP #$5B                        ; CSI look for [
0003B0r 3  D0 28            BNE SkipControl
0003B2r 3  C8               INY                             ; Next char
0003B3r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003B5r 3               
0003B5r 3  C9 33            CMP #$33
0003B7r 3  D0 1B            BNE @not_foreground
0003B9r 3  C8               INY                             ; Next char
0003BAr 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003BCr 3  C9 37            CMP #$37
0003BEr 3  D0 08            BNE @nextcol1
0003C0r 3  A9 FF            LDA #%11111111
0003C2r 3  20 rr rr         jsr RA8875_SetForegroundColor
0003C5r 3  4C rr rr         jmp @done
0003C8r 3               @nextcol1:
0003C8r 3  C9 32            CMP #$32
0003CAr 3  D0 08            BNE @nextcol2
0003CCr 3  A9 1C            LDA #%00011100
0003CEr 3  20 rr rr         jsr RA8875_SetForegroundColor
0003D1r 3  4C rr rr         jmp @done
0003D4r 3               @nextcol2:
0003D4r 3               
0003D4r 3               @not_foreground:
0003D4r 3               
0003D4r 3               
0003D4r 3               @done:
0003D4r 3  C8               INY
0003D5r 3               
0003D5r 3  98               tya
0003D6r 3  22 rr rr rr      jsl RA8875_WriteHex
0003DAr 3               
0003DAr 3               
0003DAr 3               SkipControl:
0003DAr 3  60               RTS
0003DBr 3               
0003DBr 2               .include "../drivers/ra8875/ra8875_api.asm" ; include API for RA8875
0003DBr 3               .A16
0003DBr 3               .I16
0003DBr 3               RA8875_WriteString16_ARG = 8
0003DBr 3               RA8875_WriteString16:
0003DBr 3  5A               PHY
0003DCr 3  DA               PHX
0003DDr 3  E2 30            shortr
0003DFr 3  A0 00            LDY #$00
0003E1r 3  A9 02            LDA #RA8875_MRWC
0003E3r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
0003E6r 3               RA8875_WriteString16_0:
0003E6r 3  B3 08            LDA (RA8875_WriteString16_ARG,s),Y
0003E8r 3  F0 06            BEQ RA8875_WriteStringEnd16       ; Is char 0 then end write
0003EAr 3               
0003EAr 3  20 rr rr         JSR RA8875_SingleChar           ; Handle single character
0003EDr 3               
0003EDr 3  C8               INY
0003EEr 3  D0 F6            BNE RA8875_WriteString16_0
0003F0r 3               RA8875_WriteStringEnd16:
0003F0r 3  C2 30            longr
0003F2r 3  FA               PLX
0003F3r 3  7A               PLY
0003F4r 3  6B               RTL
0003F5r 3               
0003F5r 3               .A8
0003F5r 3               .I8
0003F5r 3               RA8875_WriteChar:
0003F5r 3  DA               PHX
0003F6r 3  F0 0A            BEQ RA8875_WriteCharEnd         ; Is char 0 then end write
0003F8r 3  48               PHA
0003F9r 3  A9 02            LDA #RA8875_MRWC
0003FBr 3  20 rr rr         JSR RA8875WriteCommand
0003FEr 3  68               PLA
0003FFr 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
000402r 3               RA8875_WriteCharEnd:
000402r 3  FA               PLX
000403r 3  6B               RTL
000404r 3               
000404r 3               .A16
000404r 3               .I16
000404r 3               RA8875_WriteChar16:
000404r 3  F0 12            BEQ RA8875_WriteChar16End         ; Is char 0 then end write
000406r 3  48               PHA
000407r 3  E2 30            shortr
000409r 3  A9 02            LDA #RA8875_MRWC
00040Br 3  20 rr rr         JSR RA8875WriteCommand
00040Er 3  C2 30            longr
000410r 3  68               PLA
000411r 3  E2 30            shortr
000413r 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
000416r 3  C2 30            longr
000418r 3               RA8875_WriteChar16End:
000418r 3  6B               RTL
000419r 3               
000419r 3               .A8
000419r 3               .I8
000419r 3               RA8875_WriteNumber:
000419r 3  A2 FF            LDX #$FF
00041Br 3  38               SEC                             ; Prepare for subtraction
00041Cr 3               RA8875_WriteNumber100:
00041Cr 3  E8               INX
00041Dr 3  E9 64            SBC #100
00041Fr 3  B0 FB            BCS RA8875_WriteNumber100       ; Count how many 100s
000421r 3  69 64            ADC #100
000423r 3  20 rr rr         JSR RA8875_WriteDigit           ; Print the 100s
000426r 3  A2 FF            LDX #$FF
000428r 3  38               SEC                             ; Prepare for subtraction
000429r 3               RA8875_WriteNumber10:
000429r 3  E8               INX
00042Ar 3  E9 0A            SBC #10
00042Cr 3  B0 FB            BCS RA8875_WriteNumber10         ; Count how many 10s
00042Er 3  69 0A            ADC #10
000430r 3  20 rr rr         JSR RA8875_WriteDigit            ; Print the 10s
000433r 3  AA               TAX                              ; Pass 1s into X
000434r 3               RA8875_WriteDigit:
000434r 3  48               PHA
000435r 3  8A               TXA                             ; Save A pass digit to A
000436r 3  09 30            ORA #$30                        ; ASCII 0
000438r 3  22 rr rr rr      JSL RA8875_WriteChar            ; Convert to character and print it
00043Cr 3  68               PLA
00043Dr 3  60               RTS                             ; Restore A and return
00043Er 3               
00043Er 3               .A8
00043Er 3               .I8
00043Er 3               RA8875_WriteHex:
00043Er 3  48               PHA                     ; Save A for LSD.
00043Fr 3  4A               LSR
000440r 3  4A               LSR
000441r 3  4A               LSR                     ; MSD to LSD position.
000442r 3  4A               LSR
000443r 3  22 rr rr rr      JSL RA8875_WriteHex1    ; Output hex digit.
000447r 3  68               PLA                     ; Restore A.
000448r 3               RA8875_WriteHex1:
000448r 3  DA               PHX
000449r 3  48               PHA
00044Ar 3  18               CLC
00044Br 3  29 0F            AND #$0F                ; Mask LSD for hex print.
00044Dr 3  09 30            ORA #$30                ; Add "0".
00044Fr 3  C9 3A            CMP #$3A                ; Digit?
000451r 3  90 02            BCC RA8875_WriteHex2    ; Yes, output it.
000453r 3  69 06            ADC #$06                ; Add offset for letter.
000455r 3               RA8875_WriteHex2:
000455r 3  22 rr rr rr      JSL RA8875_WriteChar
000459r 3  68               PLA
00045Ar 3  FA               PLX
00045Br 3  6B               RTL                    ; Return.
00045Cr 3               
00045Cr 3               .A16
00045Cr 3               .I16
00045Cr 3               RA8875_WriteHex16:
00045Cr 3  E2 30            shortr
00045Er 3  EB               xba                     ; switch high and low A
00045Fr 3  22 rr rr rr      jsl RA8875_WriteHex     ; print first byte
000463r 3  EB               xba                     ; switch high and low A
000464r 3  22 rr rr rr      jsl RA8875_WriteHex     ; print second byte
000468r 3  C2 30            longr
00046Ar 3  6B               RTL
00046Br 3               
00046Br 2               
00046Br 2               .include "ramtest.asm"
00046Br 3               .RODATA
0003A4r 3               
0003A4r 3  52 75 6E 6E  ram_test_start: .asciiz "Running ram test"
0003A8r 3  69 6E 67 20  
0003ACr 3  72 61 6D 20  
0003B5r 3               
0003B5r 3               
0003B5r 3               .code
00046Br 3               .A16
00046Br 3               .I16
00046Br 3               RamTestRun:
00046Br 3  F4 rr rr 22      write ram_test_start
00046Fr 3  rr rr rr 68  
000473r 3               
000473r 3  E2 30            shortr
000475r 3               ; Single cell at $0300
000475r 3  A9 42            LDA #$42
000477r 3  8D 00 03         STA $0300
00047Ar 3  A9 00            LDA #$00
00047Cr 3  AD 00 03         LDA $0300
00047Fr 3  C9 42            CMP #$42
000481r 3  D0 3E            BNE RamTestFail
000483r 3               ; Single cell at $0300
000483r 3  A9 66            LDA #$66
000485r 3  8D 98 98         STA $9898
000488r 3  A9 00            LDA #$00
00048Ar 3  AD 98 98         LDA $9898
00048Dr 3  C9 66            CMP #$66
00048Fr 3  D0 30            BNE RamTestFail
000491r 3               
000491r 3               ; All of zero page
000491r 3  A2 00            ldx #0                ;ZP location index
000493r 3  8A               txa                   ;initialize
000494r 3  38               sec                   ;test "bit"
000495r 3               
000495r 3               loop0010:
000495r 3  95 00            sta $00,x             ;clear test cell
000497r 3  A0 09            ldy #9                ;bit shift iterations
000499r 3               
000499r 3               loop0020:
000499r 3  36 00            rol $00,x             ;rotate away
00049Br 3  88               dey                   ;step counter
00049Cr 3  D0 FB            bne loop0020          ;not done
00049Er 3               
00049Er 3  90 21            bcc RamTestFail       ;RAM defective...abort
0004A0r 3               
0004A0r 3  B5 00            lda $0,x              ;any "stuck" bits?
0004A2r 3  D0 1D            bne RamTestFail       ;yes, bad RAM...abort
0004A4r 3               
0004A4r 3  E8               inx                   ;we done?
0004A5r 3  D0 EE            bne loop0010          ;no, do next
0004A7r 3               
0004A7r 3  C2 30            longr
0004A9r 3  F4 rr rr 22      write ok_string
0004ADr 3  rr rr rr 68  
0004B1r 3               
0004B1r 3  A9 00 00         lda #$00
0004B4r 3  A2 00 00         ldx #$0000
0004B7r 3               @loop:
0004B7r 3  9D 00 A0         sta $A000,x
0004BAr 3               
0004BAr 3  E8               inx
0004BBr 3  E0 00 10         cpx #$1000
0004BEr 3  D0 F7            bne @loop
0004C0r 3               
0004C0r 3  6B               RTL
0004C1r 3               
0004C1r 3               
0004C1r 3               RamTestFail:
0004C1r 3  C2 30            longr
0004C3r 3  F4 rr rr 22      write fail_string
0004C7r 3  rr rr rr 68  
0004CBr 3  6B               RTL
0004CCr 3               
0004CCr 2               .include "ramtest_wide.asm"
0004CCr 3               .RODATA
0003B5r 3               
0003B5r 3  52 75 6E 6E  ram_test_start_wide: .asciiz "Running wide ram test"
0003B9r 3  69 6E 67 20  
0003BDr 3  77 69 64 65  
0003CBr 3  2E 00        ram_test_progress: .asciiz "."
0003CDr 3  31 36 20 62  bit16_registers: .asciiz "16 bit registers"
0003D1r 3  69 74 20 72  
0003D5r 3  65 67 69 73  
0003DEr 3               
0003DEr 3               .code
0004CCr 3               .A16
0004CCr 3               .I16
0004CCr 3               RamTestWideRun:
0004CCr 3               
0004CCr 3  F4 rr rr 22      write ram_test_start_wide
0004D0r 3  rr rr rr 68  
0004D4r 3               
0004D4r 3  E2 30            shortr
0004D6r 3  A9 42            LDA #$42
0004D8r 3  8F 34 12 01      STA $011234
0004DCr 3  A9 11            LDA #$11
0004DEr 3  AF 34 12 01      LDA $011234
0004E2r 3  C9 42            CMP #$42
0004E4r 3  D0 2F            BNE RamTestFailWide
0004E6r 3  A9 F6            LDA #$F6
0004E8r 3  8F 34 12 02      STA $021234
0004ECr 3  AF 34 12 01      LDA $011234
0004F0r 3  C9 42            CMP #$42
0004F2r 3  D0 21            BNE RamTestFailWide
0004F4r 3  AF 34 12 02      LDA $021234
0004F8r 3  C9 F6            CMP #$F6
0004FAr 3  D0 19            BNE RamTestFailWide
0004FCr 3  A9 55            LDA #$55
0004FEr 3  8F 34 12 03      STA $031234
000502r 3  AF 34 12 01      LDA $011234
000506r 3  C9 42            CMP #$42
000508r 3  D0 0B            BNE RamTestFailWide
00050Ar 3               
00050Ar 3  C2 30            longr
00050Cr 3  F4 rr rr 22      write ok_string
000510r 3  rr rr rr 68  
000514r 3  60               rts
000515r 3               
000515r 3               RamTestFailWide:
000515r 3  C2 30            longr
000517r 3  F4 rr rr 22      write fail_string
00051Br 3  rr rr rr 68  
00051Fr 3  60               rts
000520r 3               
000520r 3               .A16
000520r 3               .I16
000520r 3               RamTestWideRegistersRun:
000520r 3               
000520r 3  F4 rr rr 22      write bit16_registers
000524r 3  rr rr rr 68  
000528r 3               
000528r 3  A9 34 12         LDA #$1234
00052Br 3  8F 00 04 04      STA $040400
00052Fr 3  A9 76 98         LDA #$9876
000532r 3  AF 00 04 04      LDA $040400
000536r 3  C9 34 12         CMP #$1234
000539r 3  D0 DA            BNE RamTestFailWide
00053Br 3               
00053Br 3  F4 rr rr 22      write ok_string
00053Fr 3  rr rr rr 68  
000543r 3               
000543r 3  60               rts
000544r 3               
000544r 2               
000544r 2               .A8
000544r 2               .I8
000544r 2               InitBIOS:
000544r 2  20 rr rr         JSR InitSPI
000547r 2  20 rr rr         JSR InitRA8875
00054Ar 2  20 rr rr         JSR InitKeyboard
00054Dr 2               
00054Dr 2               
00054Dr 2               ; switch out of emulation mode
00054Dr 2  18               clc
00054Er 2  FB               xce
00054Fr 2               
00054Fr 2  C2 30            longr
000551r 2                   ;pea test_bios
000551r 2                   ;jsl RA8875_WriteString16
000551r 2                   ;pla
000551r 2               
000551r 2                   ;shortr
000551r 2                   ;LDA #%01101111
000551r 2                   ;jsr RA8875_SetForegroundColor
000551r 2                   ;longr
000551r 2               
000551r 2               
000551r 2               ;    write welcome_logo1
000551r 2               ;    write welcome_logo2
000551r 2               ;    write welcome_logo3
000551r 2               ;    write welcome_logo4
000551r 2               ;    write welcome_logo5
000551r 2               ;    write welcome_logo6
000551r 2               ;    write welcome_logo7
000551r 2               
000551r 2                   ;lda #$0A
000551r 2                   ;jsl RA8875_WriteChar16
000551r 2               
000551r 2                   ;shortr
000551r 2                   ;LDA #%11111111
000551r 2                   ;jsr RA8875_SetForegroundColor
000551r 2                   ;longr
000551r 2               
000551r 2  22 rr rr rr      JSL RamTestRun
000555r 2               
000555r 2               
000555r 2               
000555r 2                   ; jsr RamTestWideRegistersRun
000555r 2                   ; jsr RamTestWideRun
000555r 2               
000555r 2                   ;shortr
000555r 2                   ;LDA #%00011100
000555r 2                   ;jsr RA8875_SetForegroundColor
000555r 2  C2 30            longr
000557r 2               
000557r 2  F4 rr rr 22      write bios_init
00055Br 2  rr rr rr 68  
00055Fr 2  F4 rr rr 22      write ok_string
000563r 2  rr rr rr 68  
000567r 2               
000567r 2                   ;shortr
000567r 2                   ;LDA #%11111111
000567r 2                   ;jsr RA8875_SetForegroundColor
000567r 2                   ;longr
000567r 2               
000567r 2  F4 rr rr 22      write ansi_string
00056Br 2  rr rr rr 68  
00056Fr 2               
00056Fr 2  E2 30            shortr
000571r 2  60               RTS
000572r 2               
000572r 1               .include "kernel/kernel.asm"
000572r 2               
000572r 2               .include "tasks.asm"
000572r 3               NUMBER_OF_TASKS = 16
000572r 3               
000572r 3               TASK_STATUS_NONE = 0
000572r 3               TASK_STATUS_RUNNING = 1
000572r 3               TASK_STATUS_RUNNABLE = 2
000572r 3               TASK_STATUS_EXITED = 6          ; everything above this can be taken by a new task
000572r 3               TASK_STATUS_KILLED = 7
000572r 3               
000572r 3               TASK_EXIT_CODE_KILLED = 7
000572r 3               
000572r 3               .include "scheduler.asm"
000572r 4               ; IRQ steps
000572r 4               ; Push to the stack:
000572r 4               ;
000572r 4               ;   PB  - Program Bank           - 1 byte
000572r 4               ;   PCH - Program Counter High   - 1 byte
000572r 4               ;   PCL - Program Counter Low    - 1 byte
000572r 4               ;   SR  - Status Register        - 1 byte
000572r 4               ;
000572r 4               ; PB set to $00
000572r 4               
000572r 4               
000572r 4               ; Stacks and direct page
000572r 4               ; 0000-00FF : kernel direct page
000572r 4               ; 0100-01FF : kernel stack
000572r 4               
000572r 4               ; 9000-90FF : task 0  - direct
000572r 4               ; A000-A0FF : task 0  - stack
000572r 4               ; 9F00-9FFF : task 16 - direct
000572r 4               ; AF00-AFFF : task 16 - stack
000572r 4               
000572r 4               
000572r 4               ; NOT USED! THIS IS A TEST:
000572r 4               ; 0000-00FF : kernel direct page
000572r 4               ; 0100-01FF : kernel stack
000572r 4               ; 0200-02FF : task 1 DP
000572r 4               ; 0300-03FF : task 1 stack
000572r 4               
000572r 4               ; B000-C000 : I/O
000572r 4               InterruptStackY = 3+1
000572r 4               InterruptStackX = InterruptStackY+2
000572r 4               InterruptStackA = InterruptStackX+2
000572r 4               InterruptDP = InterruptStackA+2
000572r 4               InterruptDB = InterruptDP+2
000572r 4               InterruptStatusRegister = InterruptDB+1
000572r 4               InterruptPC = InterruptStatusRegister+1
000572r 4               InterruptPB = InterruptPC+2
000572r 4               
000572r 4               .SEGMENT "RAM"
000002r 4               
000002r 4  xx           SchedulerCount: .res 1
000003r 4               
000003r 4  xx xx        TimerCounter: .res 2
000005r 4  xx xx        TaskSwitches: .res 2
000007r 4               
000007r 4  xx           TempStackReturnBank: .res 1
000008r 4  xx xx        TempStackReturnPC: .res 2
00000Ar 4               
00000Ar 4               .code
000572r 4               
000572r 4               
000572r 4               
000572r 4               .A8
000572r 4               .I8
000572r 4               Scheduler_NextTask:
000572r 4  78               sei
000573r 4               
000573r 4  AE rr rr         ldx ActiveTask
000576r 4               
000576r 4  BD rr rr         lda TaskStatus,x
000579r 4  C9 01            cmp #TASK_STATUS_RUNNING
00057Br 4  D0 4E            bne @loop
00057Dr 4               
00057Dr 4  A9 02            lda #TASK_STATUS_RUNNABLE               ; if running then set to runnable
00057Fr 4  9D rr rr         sta TaskStatus,x
000582r 4               
000582r 4               ; save current task stage
000582r 4                   ;longr
000582r 4                   ;write task_save_old
000582r 4                   ;write test_string
000582r 4                   ;shortr
000582r 4               
000582r 4                   ;ldx ActiveTask
000582r 4                   ;txa
000582r 4                   ;jsl RA8875_WriteHex
000582r 4                   ;lda #' '
000582r 4                   ;jsl RA8875_WriteChar
000582r 4                   ;lda #$A
000582r 4                   ;jsl RA8875_WriteChar
000582r 4                   ;lda #'o'
000582r 4                   ;jsl RA8875_WriteChar
000582r 4                   ;longr
000582r 4                   ;jsl DumpStack
000582r 4                   ;shortr
000582r 4                   ;ldx ActiveTask
000582r 4               
000582r 4  A3 0C            lda InterruptDB,s
000584r 4  9D rr rr         sta TaskDataBank,x
000587r 4               
000587r 4  A3 10            lda InterruptPB,s
000589r 4  9D rr rr         sta TaskProgramBank,x
00058Cr 4               
00058Cr 4  A3 0D            lda InterruptStatusRegister,s
00058Er 4  9D rr rr         sta TaskStatusRegister,x
000591r 4               
000591r 4               
000591r 4               
000591r 4                   ;ldx ActiveTask
000591r 4  8A               txa
000592r 4  0A               asl
000593r 4  AA               tax
000594r 4               
000594r 4               ; SAVE STACK POINTER
000594r 4  C2 20            longa
000596r 4  3B               tsc                                 ; A = stack pointer
000597r 4  18               clc
000598r 4  69 10 00         adc #InterruptPB                 ; A = stack pointer - ...
00059Br 4  9D rr rr         sta TaskStackPointer,x
00059Er 4  E2 20            shorta
0005A0r 4               
0005A0r 4                   ; lda TaskStackPointer+1,x
0005A0r 4                   ; jsl RA8875_WriteHex
0005A0r 4                   ; lda #' '
0005A0r 4                   ; jsl RA8875_WriteChar
0005A0r 4                   ; lda TaskStackPointer,x
0005A0r 4                   ; jsl RA8875_WriteHex
0005A0r 4                   ; lda #' '
0005A0r 4                   ; jsl RA8875_WriteChar
0005A0r 4               
0005A0r 4  A3 08            lda InterruptStackA,s
0005A2r 4  9D rr rr         sta TaskA,x
0005A5r 4  A3 09            lda InterruptStackA+1,s
0005A7r 4  9D rr rr         sta TaskA+1,x
0005AAr 4  A3 06            lda InterruptStackX,s
0005ACr 4  9D rr rr         sta TaskX,x
0005AFr 4  A3 07            lda InterruptStackX+1,s
0005B1r 4  9D rr rr         sta TaskX+1,x
0005B4r 4  A3 04            lda InterruptStackY,s
0005B6r 4  9D rr rr         sta TaskY,x
0005B9r 4  A3 05            lda InterruptStackY+1,s
0005BBr 4  9D rr rr         sta TaskY+1,x
0005BEr 4               
0005BEr 4               
0005BEr 4  A3 0E            lda InterruptPC,s
0005C0r 4  9D rr rr         sta TaskProgramPointer,x
0005C3r 4               
0005C3r 4                   ;jsl RA8875_WriteHex
0005C3r 4                   ;lda #' '
0005C3r 4                   ;jsl RA8875_WriteChar
0005C3r 4               
0005C3r 4  A3 0F            lda InterruptPC+1,s
0005C5r 4  9D rr rr         sta TaskProgramPointer+1,x
0005C8r 4               
0005C8r 4                   ;jsl RA8875_WriteHex
0005C8r 4                   ;lda #$A
0005C8r 4                   ;jsl RA8875_WriteChar
0005C8r 4               
0005C8r 4  AE rr rr         ldx ActiveTask
0005CBr 4               @loop:
0005CBr 4  E8               inx
0005CCr 4  E0 10            cpx #NUMBER_OF_TASKS
0005CEr 4  D0 05            bne @fine
0005D0r 4  A2 FF            ldx #$FF     ; will roll to 0 on inx
0005D2r 4  4C rr rr         jmp @loop
0005D5r 4               @fine:
0005D5r 4               
0005D5r 4  BD rr rr         lda TaskStatus,x
0005D8r 4               
0005D8r 4  F0 F1            beq @loop
0005DAr 4               
0005DAr 4  C9 02            cmp #TASK_STATUS_RUNNABLE
0005DCr 4  F0 1C            beq @task_switch
0005DEr 4  C9 01            cmp #TASK_STATUS_RUNNING
0005E0r 4  F0 15            beq @goreturn
0005E2r 4               
0005E2r 4  22 rr rr rr      jsl RA8875_WriteHex
0005E6r 4  8A               txa
0005E7r 4  22 rr rr rr      jsl RA8875_WriteHex
0005EBr 4  C2 30            longr
0005EDr 4  F4 rr rr 22      write task_unknown_status
0005F1r 4  rr rr rr 68  
0005F5r 4  E2 30            shortr
0005F7r 4               @goreturn:
0005F7r 4  4C rr rr         jmp @return
0005FAr 4               
0005FAr 4               @task_switch:
0005FAr 4               
0005FAr 4               
0005FAr 4               ; SWITCH TO NEW TASK
0005FAr 4               
0005FAr 4  8E rr rr         stx ActiveTask
0005FDr 4               
0005FDr 4                ;   lda #$A
0005FDr 4                ;   jsl RA8875_WriteChar
0005FDr 4                ;   lda #'s'
0005FDr 4               ;    jsl RA8875_WriteChar
0005FDr 4               ;    longr
0005FDr 4               ;    jsl DumpStack
0005FDr 4               ;    shortr
0005FDr 4               
0005FDr 4               
0005FDr 4                   ;longr
0005FDr 4                   ;write task_switching_task
0005FDr 4                   ;shortr
0005FDr 4               
0005FDr 4                   ;ldx ActiveTask
0005FDr 4                   ;txa
0005FDr 4                   ;jsl RA8875_WriteHex
0005FDr 4                   ;lda #' '
0005FDr 4                   ;jsl RA8875_WriteChar
0005FDr 4               
0005FDr 4                   ;ldx ActiveTask
0005FDr 4               
0005FDr 4  A9 01            lda #TASK_STATUS_RUNNING               ; if running then set to runnable
0005FFr 4  9D rr rr         sta TaskStatus,x
000602r 4               
000602r 4  A3 01            lda 1,s
000604r 4  8D rr rr         sta TempStackReturnPC+1
000607r 4  A3 02            lda 2,s
000609r 4  8D rr rr         sta TempStackReturnPC
00060Cr 4  A3 03            lda 3,s
00060Er 4  8D rr rr         sta TempStackReturnBank
000611r 4               ; Set up stack
000611r 4  8A               txa
000612r 4  0A               asl
000613r 4  AA               tax
000614r 4  C2 30            longr
000616r 4  BD rr rr         lda TaskStackPointer,x
000619r 4  18               clc
00061Ar 4  E9 0F 00         sbc #InterruptPB-1
00061Dr 4  1B               tcs
00061Er 4  E2 30            shortr
000620r 4               
000620r 4  AD rr rr         lda TempStackReturnPC+1
000623r 4  83 01            sta 1,s
000625r 4  AD rr rr         lda TempStackReturnPC
000628r 4  83 02            sta 2,s
00062Ar 4  AD rr rr         lda TempStackReturnBank
00062Dr 4  83 03            sta 3,s
00062Fr 4               
00062Fr 4  AE rr rr         ldx ActiveTask
000632r 4               
000632r 4  BD rr rr         lda TaskProgramBank,x
000635r 4  83 10            sta InterruptPB,s
000637r 4               
000637r 4  BD rr rr         lda TaskDataBank,x
00063Ar 4  83 0C            sta InterruptDB,s
00063Cr 4               
00063Cr 4  BD rr rr         lda TaskStatusRegister,x
00063Fr 4  83 0D            sta InterruptStatusRegister,s
000641r 4               
000641r 4  8A               txa
000642r 4  0A               asl
000643r 4  AA               tax
000644r 4               ; Set Direct Page to $9x00
000644r 4  AD rr rr         lda ActiveTask
000647r 4  18               clc
000648r 4  69 90            adc #$90                                ; A = $9x
00064Ar 4               
00064Ar 4  95 0A            sta InterruptDP,x
00064Cr 4                   ;jsl RA8875_WriteHex
00064Cr 4               
00064Cr 4               ; Set registers
00064Cr 4  BD rr rr         lda TaskA,x
00064Fr 4  83 08            sta InterruptStackA,s
000651r 4  BD rr rr         lda TaskA+1,x
000654r 4  83 09            sta InterruptStackA+1,s
000656r 4  BD rr rr         lda TaskY,x
000659r 4  83 04            sta InterruptStackY,s
00065Br 4  BD rr rr         lda TaskY+1,x
00065Er 4  83 05            sta InterruptStackY+1,s
000660r 4  BD rr rr         lda TaskX,x
000663r 4  83 06            sta InterruptStackX,s
000665r 4  BD rr rr         lda TaskX+1,x
000668r 4  83 07            sta InterruptStackX+1,s
00066Ar 4               
00066Ar 4               
00066Ar 4  BD rr rr         lda TaskProgramPointer+1,x
00066Dr 4  83 0F            sta InterruptPC+1,s
00066Fr 4                   ;jsl RA8875_WriteHex
00066Fr 4               
00066Fr 4  BD rr rr         lda TaskProgramPointer,x
000672r 4  83 0E            sta InterruptPC,s
000674r 4                   ;jsl RA8875_WriteHex
000674r 4               
000674r 4                   ;lda #$A
000674r 4                   ;jsl RA8875_WriteChar
000674r 4               
000674r 4                   ;lda #'n'
000674r 4                   ;jsl RA8875_WriteChar
000674r 4                   ;longr
000674r 4                   ;jsl DumpStack
000674r 4                   ;shortr
000674r 4                   ;lda #$A
000674r 4                   ;jsl RA8875_WriteChar
000674r 4  4C rr rr         jmp @return
000677r 4               
000677r 4               
000677r 4               @return:
000677r 4               
000677r 4               
000677r 4  58               cli
000678r 4  6B               rtl
000679r 4               
000679r 4               
000679r 4               .A16
000679r 4               .I16
000679r 4               InitScheduler:
000679r 4               
000679r 4  9C rr rr         stz TimerCounter        ; set interrupt timer counter to 0
00067Cr 4  9C rr rr         stz TaskSwitches        ; set task switch count to 0
00067Fr 4               
00067Fr 4               ; should be approx 256 times per second
00067Fr 4  A9 A8 26         lda #9896
000682r 4  8D rr rr         sta VIA1_T1CL
000685r 4               
000685r 4  E2 30            shortr
000687r 4  AD rr rr         lda  VIA1_ACR       ; Clear the ACR's bit that
00068Ar 4  29 7F            AND  #%01111111      ; tells T1 to toggle PB7 upon time-out, and
00068Cr 4  09 40            ORA  #%01000000      ; set the bit that tells T1 to automatically
00068Er 4  8D rr rr         STA  VIA1_ACR       ; produce an interrupt at every time-out and
000691r 4                                       ; just reload from the latches and keep going.
000691r 4  A9 C0            LDA  #%11000000
000693r 4  8D rr rr         STA  VIA1_IER       ; Enable the T1 interrupt in the VIA.
000696r 4               
000696r 4  C2 30            longr
000698r 4  60               rts
000699r 4               
000699r 3               .include "tasks.inc"
000699r 4               
000699r 4               .RODATA
0003DEr 4               
0003DEr 4  4E 6F 20 66  task_no_free_slot:           .asciiz "No free task slot!\n"
0003E2r 4  72 65 65 20  
0003E6r 4  74 61 73 6B  
0003F2r 4  55 6E 6B 6E  task_unknown_status:           .asciiz "Unknown task status!\n"
0003F6r 4  6F 77 6E 20  
0003FAr 4  74 61 73 6B  
000408r 4  4E 65 77 3A  task_switching_task:           .asciiz "New: "
00040Cr 4  20 00        
00040Er 4  4F 6C 64 3A  task_save_old:               .asciiz "Old: "
000412r 4  20 00        
000414r 4               
000414r 3               
000414r 3               .SEGMENT "RAM"
00000Ar 3               
00000Ar 3  xx           KernelSp: .res 1
00000Br 3  xx           ActiveTask: .res 1
00000Cr 3  xx xx xx xx  TaskStatus: .res NUMBER_OF_TASKS
000010r 3  xx xx xx xx  
000014r 3  xx xx xx xx  
00001Cr 3  xx xx xx xx  TaskExitCode: .res NUMBER_OF_TASKS
000020r 3  xx xx xx xx  
000024r 3  xx xx xx xx  
00002Cr 3  xx xx xx xx  TaskStackPointer: .res NUMBER_OF_TASKS * 2
000030r 3  xx xx xx xx  
000034r 3  xx xx xx xx  
00004Cr 3  xx xx xx xx  TaskDataBank: .res NUMBER_OF_TASKS
000050r 3  xx xx xx xx  
000054r 3  xx xx xx xx  
00005Cr 3  xx xx xx xx  TaskProgramBank: .res NUMBER_OF_TASKS
000060r 3  xx xx xx xx  
000064r 3  xx xx xx xx  
00006Cr 3  xx xx xx xx  TaskProgramPointer: .res NUMBER_OF_TASKS * 2
000070r 3  xx xx xx xx  
000074r 3  xx xx xx xx  
00008Cr 3  xx xx xx xx  TaskStatusRegister: .res NUMBER_OF_TASKS
000090r 3  xx xx xx xx  
000094r 3  xx xx xx xx  
00009Cr 3  xx xx xx xx  TaskA: .res NUMBER_OF_TASKS * 2
0000A0r 3  xx xx xx xx  
0000A4r 3  xx xx xx xx  
0000BCr 3  xx xx xx xx  TaskX: .res NUMBER_OF_TASKS * 2
0000C0r 3  xx xx xx xx  
0000C4r 3  xx xx xx xx  
0000DCr 3  xx xx xx xx  TaskY: .res NUMBER_OF_TASKS * 2
0000E0r 3  xx xx xx xx  
0000E4r 3  xx xx xx xx  
0000FCr 3               
0000FCr 3               
0000FCr 3               .SEGMENT "TASK" ; marked as used
000000r 3               
000000r 3               .code
000699r 3               
000699r 3               
000699r 3               ; Initialize tasks
000699r 3               .A16
000699r 3               .I16
000699r 3               InitTasks:
000699r 3  E2 30                shortr
00069Br 3  A2 10                ldx #NUMBER_OF_TASKS
00069Dr 3                   @clrloop:
00069Dr 3  CA                   dex
00069Er 3  9E rr rr             stz TaskStatus,x
0006A1r 3  9E rr rr             stz TaskExitCode,x
0006A4r 3  9E rr rr             stz TaskStatusRegister,x
0006A7r 3  9E rr rr             stz TaskProgramBank,x
0006AAr 3  9E rr rr             stz TaskDataBank,x
0006ADr 3  C2 30                longr
0006AFr 3  9E rr rr             stz TaskStackPointer, x
0006B2r 3  9E rr rr             stz TaskProgramPointer, x
0006B5r 3  9E rr rr             stz TaskA, x
0006B8r 3  9E rr rr             stz TaskX, x
0006BBr 3  9E rr rr             stz TaskY, x
0006BEr 3  E2 30                shortr
0006C0r 3  D0 DB            bne @clrloop
0006C2r 3               
0006C2r 3  A9 FF                lda #$FF
0006C4r 3  8D rr rr             sta ActiveTask
0006C7r 3               
0006C7r 3  C2 30                longr
0006C9r 3  60                   rts
0006CAr 3               
0006CAr 3               
0006CAr 3               
0006CAr 3               ; Spawn a new task
0006CAr 3               TaskSpawnArg_Addr = 1+3+6      ; jsl 3 bytes return
0006CAr 3               .A16
0006CAr 3               .I16
0006CAr 3               TaskSpawn:
0006CAr 3  48                   pha
0006CBr 3  DA                   phx
0006CCr 3  5A                   phy
0006CDr 3  E2 30                shortr
0006CFr 3  20 rr rr             jsr TaskFindUnusedTask
0006D2r 3  B0 3C                bcs @no_unused_tasks
0006D4r 3               
0006D4r 3                       ;txa
0006D4r 3                       ;jsl RA8875_WriteHex
0006D4r 3               
0006D4r 3  9E rr rr             stz TaskExitCode,x
0006D7r 3               
0006D7r 3  A9 02                lda #TASK_STATUS_RUNNABLE
0006D9r 3  9D rr rr             sta TaskStatus,x
0006DCr 3               
0006DCr 3  A3 0C                lda TaskSpawnArg_Addr+2,s
0006DEr 3  9D rr rr             sta TaskProgramBank,x
0006E1r 3               
0006E1r 3  8A                   txa
0006E2r 3  A8                   tay
0006E3r 3  0A                   asl
0006E4r 3  AA                   tax
0006E5r 3  98                   tya
0006E6r 3  18                   clc
0006E7r 3  69 A0                adc #$A0
0006E9r 3  9D rr rr             sta TaskStackPointer+1,x
0006ECr 3  A9 FF                lda #$FF
0006EEr 3  9D rr rr             sta TaskStackPointer,x            ; Stack pointer: $AxFF
0006F1r 3               
0006F1r 3               
0006F1r 3  A3 0A                lda TaskSpawnArg_Addr,s
0006F3r 3  9D rr rr             sta TaskProgramPointer,x
0006F6r 3               
0006F6r 3  A3 0B                lda TaskSpawnArg_Addr+1,s
0006F8r 3  9D rr rr             sta TaskProgramPointer+1,x
0006FBr 3               
0006FBr 3               
0006FBr 3  9E rr rr             stz TaskA,x
0006FEr 3  9E rr rr             stz TaskA+1,x
000701r 3  9E rr rr             stz TaskY,x
000704r 3  9E rr rr             stz TaskY+1,x
000707r 3  9E rr rr             stz TaskX,x
00070Ar 3  9E rr rr             stz TaskX+1,x
00070Dr 3               
00070Dr 3               
00070Dr 3  4C rr rr             jmp @return
000710r 3               
000710r 3                   @no_unused_tasks:
000710r 3  C2 30                longr
000712r 3  F4 rr rr 22          write task_no_free_slot
000716r 3  rr rr rr 68  
00071Ar 3  4C rr rr             jmp @return
00071Dr 3                   @return:
00071Dr 3  C2 30                longr
00071Fr 3  7A                   ply
000720r 3  FA                   plx
000721r 3  68                   pla
000722r 3  6B                   rtl
000723r 3               
000723r 3               
000723r 3               
000723r 3               ; Find task slot not used. First try to find a slot with status 0
000723r 3               ; if none with status 0 is found then find a exited or killed slot
000723r 3               ; input: n/a
000723r 3               ; output:
000723r 3               ;   x - slot number that's empty
000723r 3               ;   carry set if error
000723r 3               .A8
000723r 3               .I8
000723r 3               TaskFindUnusedTask:
000723r 3  18                   clc
000724r 3  48                   pha
000725r 3  A2 00                ldx #0
000727r 3                   @loop:
000727r 3  BD rr rr             lda TaskStatus,x
00072Ar 3  F0 14                beq @return
00072Cr 3  E8                   inx
00072Dr 3  E0 10                cpx #NUMBER_OF_TASKS         ; Reach end of tasks list?
00072Fr 3  D0 F6                bne @loop
000731r 3                   ; No slot found. Try one killed or exited
000731r 3  A2 00                ldx #$0
000733r 3                   @loop2:
000733r 3  BD rr rr             lda TaskStatus,x
000736r 3  C9 06                cmp #TASK_STATUS_EXITED
000738r 3  B0 06                bcs @return
00073Ar 3  E8                   inx
00073Br 3  E0 10                cpx #NUMBER_OF_TASKS
00073Dr 3  D0 F4                bne @loop2
00073Fr 3  38                   sec                         ; reached the end the second time.
000740r 3                                                   ; no slots available. return with carry set
000740r 3                   @return:
000740r 3  68                   pla
000741r 3  60                   rts
000742r 3               
000742r 3               
000742r 3               
000742r 3               ; Mark current task as exited. Go into nop-loop until
000742r 3               ; next task is chosen by scheduler
000742r 3               ; input:
000742r 3               ;   A - exit code
000742r 3               ; output: n/a
000742r 3               .A16
000742r 3               .I16
000742r 3               TaskExit:
000742r 3  AE rr rr             ldx ActiveTask
000745r 3               
000745r 3  9D rr rr             sta TaskExitCode,x              ; store the exit code
000748r 3               
000748r 3  A9 06 00             lda #TASK_STATUS_EXITED
00074Br 3  9D rr rr             sta TaskStatus,x                ; mark the task as exited
00074Er 3               
00074Er 3                       @loop:                          ; go into infinite loop
00074Er 3  EA                       nop                         ; until scheduler picks
00074Fr 3  4C rr rr                 jmp @loop                   ; the next task
000752r 3               
000752r 3               
000752r 3               
000752r 3               ; exit task from outside the task itself
000752r 3               ; input:
000752r 3               ;   x - task number to kill
000752r 3               ; output: n/a
000752r 3               .A16
000752r 3               .I16
000752r 3               TaskKill:
000752r 3  A9 07 00             lda #TASK_STATUS_KILLED
000755r 3  9D rr rr             sta TaskStatus,x
000758r 3  9D rr rr             sta TaskExitCode,x
00075Br 3               
00075Br 3  6B                   rtl
00075Cr 3               
00075Cr 2               .include "interrupt.asm"
00075Cr 3               .code
00075Cr 3               .A16
00075Cr 3               .I16
00075Cr 3               InterruptVector:
00075Cr 3  8B               phb                   ;save DB - data bank
00075Dr 3  0B               phd                   ;save DP - direct page
00075Er 3  C2 30            longr                 ;select 16 bit registers
000760r 3  48               pha                   ;save .C
000761r 3  DA               phx                   ;save .X
000762r 3  5A               phy                   ;save .Y
000763r 3               
000763r 3  E2 30            shortr
000765r 3               
000765r 3  AD rr rr         lda VIA1_IFR
000768r 3  2D rr rr         and VIA1_IER            ; zero those that were not allowed to pull IRQ down.
00076Br 3  0A               asl ; timer 1
00076Cr 3  30 0A            bmi  InterruptTimer1
00076Er 3  0A               asl ; timer 2
00076Fr 3  0A               asl ; cb1
000770r 3  0A               asl ; cb2
000771r 3  0A               asl ; shift reg
000772r 3  0A               asl ; ca1
000773r 3               
000773r 3  30 2A            bmi InterruptKB
000775r 3               
000775r 3               
000775r 3               
000775r 3  4C rr rr         jmp crti
000778r 3               
000778r 3               InterruptTimer1:
000778r 3  2C rr rr         bit VIA1_T1CL
00077Br 3  EE rr rr         inc TimerCounter
00077Er 3  D0 03            BNE @lowcnt    ; Branch to end if the low byte didn't roll over to 00.
000780r 3  EE rr rr         inc TimerCounter+1
000783r 3               @lowcnt:
000783r 3  EE rr rr         inc SchedulerCount
000786r 3  AD rr rr         lda SchedulerCount
000789r 3  C9 06            cmp #$06
00078Br 3  D0 0F            bne @noschedule
00078Dr 3  9C rr rr         stz SchedulerCount
000790r 3  EE rr rr         inc TaskSwitches
000793r 3  D0 03            BNE @lowcntSwitch    ; Branch to end if the low byte didn't roll over to 00.
000795r 3  EE rr rr         inc TaskSwitches+1
000798r 3               @lowcntSwitch:
000798r 3  22 rr rr rr      jsl Scheduler_NextTask
00079Cr 3               @noschedule:
00079Cr 3               
00079Cr 3  4C rr rr         jmp crti
00079Fr 3               
00079Fr 3               InterruptKB:
00079Fr 3  20 rr rr         jsr InterruptKeyboard
0007A2r 3               
0007A2r 3               crti:
0007A2r 3  C2 30            longr
0007A4r 3  7A               ply                   ;restore .Y
0007A5r 3  FA               plx                   ;restore .X
0007A6r 3  68               pla                   ;restore .C
0007A7r 3  2B               pld                   ;restore DP
0007A8r 3  AB               plb                   ;restore DB
0007A9r 3  40               rti                   ;resume foreground task
0007AAr 3               
0007AAr 2               .include "streams.asm"
0007AAr 3               
0007AAr 3               NUMBER_OF_STREAMS = 3           ; Number of streams
0007AAr 3               SIZE_OF_STREAM = 16             ; Number of bytes per stream
0007AAr 3               
0007AAr 3               STREAM_STDIN = 0
0007AAr 3               
0007AAr 3               .SEGMENT "RAM"
0000FCr 3               
0000FCr 3               StreamLookupHead:
0000FCr 3  xx xx xx         .res NUMBER_OF_STREAMS
0000FFr 3               StreamLookupTail:
0000FFr 3  xx xx xx         .res NUMBER_OF_STREAMS
000102r 3               StreamData:
000102r 3  xx xx xx xx      .res SIZE_OF_STREAM * NUMBER_OF_STREAMS
000106r 3  xx xx xx xx  
00010Ar 3  xx xx xx xx  
000132r 3               
000132r 3               .code
0007AAr 3               
0007AAr 3               ; Initialize streams
0007AAr 3               ; Zeroes out head, tail, data
0007AAr 3               .A16
0007AAr 3               .I16
0007AAr 3               InitStreams:
0007AAr 3  E2 30            shortr
0007ACr 3  A2 03            ldx #NUMBER_OF_STREAMS
0007AEr 3               @clrloop:
0007AEr 3  CA               dex
0007AFr 3  9E rr rr         stz StreamLookupHead, x
0007B2r 3  9E rr rr         stz StreamLookupTail, x
0007B5r 3               
0007B5r 3  D0 F7            bne @clrloop
0007B7r 3  A2 10            ldx #SIZE_OF_STREAM
0007B9r 3               @clrloop2:
0007B9r 3  CA               dex
0007BAr 3  9E rr rr         stz StreamData, x
0007BDr 3  9E rr rr         stz StreamData+SIZE_OF_STREAM, x
0007C0r 3  9E rr rr         stz StreamData+SIZE_OF_STREAM+SIZE_OF_STREAM, x
0007C3r 3               
0007C3r 3               
0007C3r 3  D0 F4            bne @clrloop2
0007C5r 3               
0007C5r 3  C2 30            longr
0007C7r 3  60               rts
0007C8r 3               
0007C8r 3               ; Put byte to stream
0007C8r 3               ; in:
0007C8r 3               ;   A - byte to put
0007C8r 3               ;   X - stream id
0007C8r 3               ; out:
0007C8r 3               .A8
0007C8r 3               .I8
0007C8r 3               StreamPutC:
0007C8r 3  48               pha
0007C9r 3  78               sei
0007CAr 3  BC rr rr         ldy StreamLookupTail,x      ; fetch current tail
0007CDr 3  5A               phy                         ; stack: [tail]
0007CEr 3               
0007CEr 3  BC rr rr         ldy StreamLookupHead,x      ; fetch current head
0007D1r 3  5A               phy                         ; stack: [tail, head]
0007D2r 3               
0007D2r 3  DA               phx                         ; stack: [tail, head, stream id]
0007D3r 3  48               pha                         ; stack: [tail, head, stream id, A-byte]
0007D4r 3  8A               txa
0007D5r 3               
0007D5r 3  0A               asl                         ; *  2
0007D6r 3  0A               asl                         ; *  4
0007D7r 3  0A               asl                         ; *  8
0007D8r 3  0A               asl                         ; * 16
0007D9r 3  63 03            adc 3,s                     ; + head_offset
0007DBr 3  AA               tax                         ; X = X * 16 + head_offset
0007DCr 3               
0007DCr 3  68               pla                         ; stack: [tail, head, stream id], a = A-byte
0007DDr 3               
0007DDr 3  9D rr rr         sta StreamData,x            ; Store byte in stream
0007E0r 3               
0007E0r 3               ; increment head_offset
0007E0r 3  FA               plx                         ; stack: [tail, head], x=stream id
0007E1r 3  7A               ply                         ; stack: [tail], y = head
0007E2r 3  C8               iny                         ; increment head
0007E3r 3  98               tya
0007E4r 3               
0007E4r 3  C9 10            cmp #SIZE_OF_STREAM         ; head overflow?
0007E6r 3  D0 02            bne @checktail
0007E8r 3  A9 00            lda #0
0007EAr 3               @checktail:
0007EAr 3  9D rr rr         sta StreamLookupHead,x      ; store head
0007EDr 3               
0007EDr 3               ; this is untested.
0007EDr 3               ; if the stream wraps around
0007EDr 3  C3 01            cmp 1,s                     ; is head == stack[1]/tail?
0007EFr 3  D0 09            bne @tailnothead
0007F1r 3  7A               ply                         ; if yes increment tail
0007F2r 3  C8               iny
0007F3r 3  98               tya
0007F4r 3  9D rr rr         sta StreamLookupTail,x
0007F7r 3  4C rr rr         jmp @done
0007FAr 3               
0007FAr 3               
0007FAr 3               @tailnothead:
0007FAr 3  FA               plx ; clear tail from stack. not used pt
0007FBr 3               @done:
0007FBr 3  58               cli
0007FCr 3  68               pla
0007FDr 3  6B               rtl
0007FEr 3               
0007FEr 3               ; Get byte from stream
0007FEr 3               ; in:
0007FEr 3               ;   X - stream id
0007FEr 3               ; out:
0007FEr 3               ;   A: read byte
0007FEr 3               ;       0: nothing
0007FEr 3               ;       x: read byte
0007FEr 3               .A8
0007FEr 3               .I8
0007FEr 3               StreamGetC:
0007FEr 3  78               sei
0007FFr 3  BD rr rr         lda StreamLookupTail,x
000802r 3  DD rr rr         cmp StreamLookupHead,x
000805r 3  D0 05            bne @readc                  ; tail !== head
000807r 3  A9 00            lda #0                      ; set A to 0 (nothing read)
000809r 3  4C rr rr         jmp @done
00080Cr 3               @readc:
00080Cr 3               
00080Cr 3  48               pha                         ; s:[tail]
00080Dr 3  18               clc
00080Er 3  69 01            adc #1                      ; tail = tail + 1
000810r 3  C9 10            cmp #SIZE_OF_STREAM         ; tail === 16?
000812r 3  D0 02            bne @savetail               ; if not skip next
000814r 3  A9 00            lda #0                      ; tail = 0
000816r 3               @savetail:
000816r 3  9D rr rr         sta StreamLookupTail,x      ; save tail
000819r 3               
000819r 3  8A               txa
00081Ar 3               
00081Ar 3  0A               asl                         ; *  2
00081Br 3  0A               asl                         ; *  4
00081Cr 3  0A               asl                         ; *  8
00081Dr 3  0A               asl                         ; * 16
00081Er 3  63 01            adc 1,s                     ; + tail_offset
000820r 3  AA               tax                         ; X = X * 16 + tail_offset
000821r 3  7A               ply                         ; s:[]
000822r 3               
000822r 3  BD rr rr         lda StreamData,x
000825r 3               
000825r 3               @done:
000825r 3  58               cli
000826r 3  6B               rtl
000827r 3               
000827r 2               
000827r 2               .A16
000827r 2               .I16
000827r 2               InitKernel:
000827r 2  20 rr rr         jsr InitTasks
00082Ar 2                   ;write init_kernel_tasks_done
00082Ar 2  20 rr rr         jsr InitScheduler
00082Dr 2                   ;write init_kernel_scheduler_done
00082Dr 2  20 rr rr         jsr InitStreams
000830r 2                   ;write init_kernel_streams_done
000830r 2                   ;write init_kernel_done
000830r 2  60               rts
000831r 2               ;;;
000831r 2               ; Long Delay
000831r 2               ;;;
000831r 2               
000831r 2               .A8
000831r 2               .I8
000831r 2               LongDelay:
000831r 2  A2 FF            ldx #$FF
000833r 2               LongDelayLoop1:
000833r 2  A0 FF            ldy #$FF
000835r 2               LongDelayLoop2:
000835r 2  88               dey
000836r 2  D0 FD            bne LongDelayLoop2
000838r 2  CA               dex
000839r 2  D0 F8            bne LongDelayLoop1
00083Br 2  60               rts
00083Cr 2               
00083Cr 2               ;;;
00083Cr 2               ; Delay
00083Cr 2               ;;;
00083Cr 2               .A8
00083Cr 2               .I8
00083Cr 2               Delay:
00083Cr 2  A2 FF            ldx #$FF
00083Er 2               DelayLoop1:
00083Er 2  A0 FF            ldy #$FF
000840r 2               DelayLoop2:
000840r 2  88               dey
000841r 2  D0 FD            bne DelayLoop2
000843r 2  CA               dex
000844r 2  D0 F8            bne DelayLoop1
000846r 2  60               rts
000847r 2               
000847r 2               ;;;
000847r 2               ; Short Delay
000847r 2               ;;;
000847r 2               .A8
000847r 2               .I8
000847r 2  A2 AA        DelayShort:	ldx #$aa
000849r 2               DelayShortLoop1:
000849r 2  CA           	dex
00084Ar 2  D0 FD            bne DelayShortLoop1
00084Cr 2  60               rts
00084Dr 2               
00084Dr 1               
00084Dr 1               
00084Dr 1               .include "stdlib/stdlib.asm"
00084Dr 2               .include "stdlib.inc"
00084Dr 3               Std_StrLen = 1
00084Dr 3               Std_ReadNum = 2
00084Dr 3               Std_StrCompareUntilWhiteSpace = 3
00084Dr 3               
00084Dr 2               
00084Dr 2               .SEGMENT "STDLIB"
000000r 2               
000000r 2               StdLib:
000000r 2  C2 30            longr
000002r 2  48               pha
000003r 2  DA               phx
000004r 2  5A               phy
000005r 2               
000005r 2  29 FF 00         and #$00FF
000008r 2  3A               dec a                           ; 0 index function number
000009r 2  0A               asl a                           ; double function number to match words
00000Ar 2               
00000Ar 2  E2 30            shortr
00000Cr 2  AA               tax
00000Dr 2               
00000Dr 2  7C rr rr         jmp (StdLibTable,x)
000010r 2               
000010r 2               
000010r 2               StdLibTable:
000010r 2  rr rr            .word Stdlib_StrLen
000012r 2  rr rr            .word Stdlib_ReadNum
000014r 2  rr rr            .word StdLib_StrCompareUntilWhiteSpace
000016r 2               
000016r 2               
000016r 2               .include "strings.asm"
000016r 3               .RODATA
000414r 3  53 74 72 4C  	strlen: .asciiz "StrLen Called\n"
000418r 3  65 6E 20 43  
00041Cr 3  61 6C 6C 65  
000423r 3  52 65 61 64  	readnum: .asciiz "ReadNum Called\n"
000427r 3  4E 75 6D 20  
00042Br 3  43 61 6C 6C  
000433r 3               
000433r 3               .SEGMENT "STDLIB"
000016r 3               
000016r 3               
000016r 3               ;	STRING LENGTH
000016r 3               ; 		Return lenght of zero terminated string in A
000016r 3               ;	Input:
000016r 3               ;		stack: 2 bytes string address (0 terminated)
000016r 3               ;	Output:
000016r 3               ;		A: length of the string
000016r 3               Stdlib_StrLen:
000016r 3  18           		clc
000017r 3               
000017r 3  E2 30        		shortr
000019r 3               
000019r 3  A0 00        		ldy #0
00001Br 3               	@next:
00001Br 3  B3 0A        		lda (args_start,s),y
00001Dr 3  F0 04        		beq @result
00001Fr 3  C8           		iny
000020r 3  4C rr rr     		jmp @next
000023r 3               	@result:
000023r 3  98           		tya
000024r 3  83 05        		sta reg_a, s
000026r 3               
000026r 3               	;	shortr
000026r 3               	;	write strlen
000026r 3               
000026r 3  C2 30        		longr
000028r 3               
000028r 3  7A           		ply
000029r 3  FA           		plx
00002Ar 3  68           		pla
00002Br 3               
00002Br 3  6B           		rtl
00002Cr 3               
00002Cr 3               
00002Cr 3               
00002Cr 3               
00002Cr 3               ;	READ NUMBER
00002Cr 3               ; 		Return the decimal number read from string input
00002Cr 3               Stdlib_ReadNum_StackSize = 6
00002Cr 3               Stdlib_ReadNum_SingleDigit = 1
00002Cr 3               Stdlib_ReadNum_Result = Stdlib_ReadNum_SingleDigit + 2
00002Cr 3               Stdlib_ReadNum_LoopCounter = Stdlib_ReadNum_Result + 2
00002Cr 3               Stdlib_ReadNum:
00002Cr 3  C2 30        		longr
00002Er 3  A2 00 00     		ldx #0
000031r 3  A0 00 00     		ldy #0
000034r 3  5A           		phy
000035r 3  5A           		phy
000036r 3  5A           		phy
000037r 3               	@next:
000037r 3  E2 30        		shortr
000039r 3  B3 10        		lda (args_start+Stdlib_ReadNum_StackSize,s),y
00003Br 3  C2 30        		longr
00003Dr 3  C9 30 00     		cmp #$30
000040r 3  90 09        		bcc @numend						; less than $30
000042r 3  C9 40 00     		cmp #$40
000045r 3  B0 04        		bcs @numend						; more than $39
000047r 3  C8           		iny
000048r 3  4C rr rr     		jmp @next
00004Br 3               	@numend:
00004Br 3  98           		tya
00004Cr 3  F0 1F        		beq @done						; did we read 0 numbers? then end
00004Er 3  88           		dey								; subtract 1 for the last number
00004Fr 3  E2 30        		shortr
000051r 3  B3 10        		lda (args_start+Stdlib_ReadNum_StackSize,s),y
000053r 3  C2 30        		longr
000055r 3  18           		clc
000056r 3  E9 2F 00     		sbc #$2F
000059r 3  83 01        		sta Stdlib_ReadNum_SingleDigit,s
00005Br 3               
00005Br 3  A3 05        		lda Stdlib_ReadNum_LoopCounter,s ; how many times to multiply 10?
00005Dr 3  AA           		tax								; save in loop counter X
00005Er 3               	@mulloop:
00005Er 3  8A           		txa								; look at loop counter X
00005Fr 3  F0 18        		beq @donemul					; if 0 then skip multiply 10
000061r 3  A3 01        		lda Stdlib_ReadNum_SingleDigit,s
000063r 3               
000063r 3  22 rr rr rr  		jsl MulTen
000067r 3  83 01        		sta Stdlib_ReadNum_SingleDigit,s
000069r 3               
000069r 3  CA           		dex								; derement loop counter X
00006Ar 3  4C rr rr     		jmp @mulloop
00006Dr 3               
00006Dr 3               	@done:
00006Dr 3  A3 03        		lda Stdlib_ReadNum_Result,s
00006Fr 3  83 0B        		sta reg_a+Stdlib_ReadNum_StackSize, s
000071r 3               
000071r 3  18           		clc
000072r 3               
000072r 3  7A           		ply ; clear temp stack
000073r 3  7A           		ply ; clear temp stack
000074r 3  7A           		ply ; clear temp stack
000075r 3               
000075r 3  7A           		ply
000076r 3  FA           		plx
000077r 3  68           		pla
000078r 3               
000078r 3               
000078r 3  6B           		rtl
000079r 3               
000079r 3               
000079r 3               	@donemul:
000079r 3               
000079r 3  A3 01        		lda Stdlib_ReadNum_SingleDigit,s
00007Br 3  18           		clc
00007Cr 3  63 03        		adc Stdlib_ReadNum_Result,s
00007Er 3  83 03        		sta Stdlib_ReadNum_Result,s
000080r 3               
000080r 3  A3 05        		lda Stdlib_ReadNum_LoopCounter,s
000082r 3  18           		clc
000083r 3  69 01 00     		adc #1								; add one time multiply with 10
000086r 3  83 05        		sta Stdlib_ReadNum_LoopCounter,s
000088r 3  4C rr rr     		jmp @numend
00008Br 3               
00008Br 3               
00008Br 3               MulTen:
00008Br 3  5A           		phy
00008Cr 3  0A           		asl						;   *  2
00008Dr 3  48           		pha
00008Er 3  0A           		asl						;   *  4
00008Fr 3  0A           		asl		               	;   *  8
000090r 3  18           		clc
000091r 3  63 01        		adc 1,s               	;   + (*2)
000093r 3  7A           		ply
000094r 3  7A           		ply
000095r 3  6B           		rtl
000096r 3               
000096r 3               
000096r 3               
000096r 3               ; Compare the first token of string1 (delimited by whitespace) against string2
000096r 3               ; in:
000096r 3               ;    string1  - string tokenized by space
000096r 3               ;    string2  - string to compare first token of string1 against
000096r 3               ; example:
000096r 3               ;    first:  time test\0
000096r 3               ;    second: time\0
000096r 3               ;    This is a match
000096r 3               ; out:
000096r 3               ;   carry set if no match
000096r 3               ;	carry clear if match
000096r 3               StdLib_StrCompareUntilWhiteSpace_Arg_String2 = args_start
000096r 3               StdLib_StrCompareUntilWhiteSpace_Arg_String1 = args_start + 2
000096r 3               StdLib_StrCompareUntilWhiteSpace:
000096r 3  18           		clc
000097r 3  A0 00 00     		ldy #$00
00009Ar 3               	@strcmp_token_load:
00009Ar 3  B3 0C        		lda (StdLib_StrCompareUntilWhiteSpace_Arg_String1,s), Y
00009Cr 3  C9 20 00     		cmp #$20                                ; is whitespace?
00009Fr 3  F0 0D        		beq @strcmp_token_is_second_done		; yes then check if string2 is done
0000A1r 3  D3 0A        		cmp (StdLib_StrCompareUntilWhiteSpace_Arg_String2,s), Y
0000A3r 3  D0 13        		bne @strcmp_token_notequal				; is it equal to string2?
0000A5r 3  C8           		INY
0000A6r 3  C9 00 00     		CMP #0
0000A9r 3  D0 EF        		BNE @strcmp_token_load
0000ABr 3  4C rr rr     		jmp @return
0000AEr 3               
0000AEr 3               	@strcmp_token_is_second_done:
0000AEr 3  B3 0A        		lda (StdLib_StrCompareUntilWhiteSpace_Arg_String2,s), Y
0000B0r 3  C9 00 00     		cmp #0									; is string2 done?
0000B3r 3  F0 04        		beq @return								; yes then return match
0000B5r 3  4C rr rr     		jmp @strcmp_token_notequal				; no then return no match
0000B8r 3               	@strcmp_token_notequal:
0000B8r 3  38           		sec
0000B9r 3               	@return:
0000B9r 3  7A           		ply
0000BAr 3  FA           		plx
0000BBr 3  68           		pla
0000BCr 3  6B           		rtl
0000BDr 3               
0000BDr 2               
0000BDr 2               
0000BDr 2               ;    register stack frame...
0000BDr 2               ;
0000BDr 2               reg_y       =1                    ;16 bit .Y
0000BDr 2               reg_x       =reg_y+2              ;16 bit .X
0000BDr 2               reg_a       =reg_x+2              ;16 bit .A
0000BDr 2               reg_rtl     =reg_a+2              ;24 bit RTL address
0000BDr 2               
0000BDr 2               args_start  =reg_rtl+3
0000BDr 2               
0000BDr 2               ; ARGS      $10 args_start
0000BDr 2               ; RTS___    $07 reg_rts
0000BDr 2               ; AAAA      $05 reg_a
0000BDr 2               ; XXXX      $03 reg_x
0000BDr 2               ; YYYY      $01 reg_y
0000BDr 2               ;           current StackPointer
0000BDr 2               
0000BDr 1               
0000BDr 1               .include "programs/programs.inc"
0000BDr 2               
0000BDr 2               .include "shell.asm"
0000BDr 3               ; DIRECT PAGE LAYOUT
0000BDr 3               ; $00 - $7F   : Input Buffer
0000BDr 3               ; $80         : Input Buffer Index
0000BDr 3               
0000BDr 3               Shell_InputBufferStart = $00
0000BDr 3               Shell_InputBufferIndex = $80
0000BDr 3               
0000BDr 3               ShellExec:
0000BDr 3  E2 30                shortr
0000BFr 3                   @restart:
0000BFr 3  64 80                stz Shell_InputBufferIndex      ; reset input buffer
0000C1r 3  64 00                stz Shell_InputBufferStart      ; start buffer with 0-termination
0000C3r 3               
0000C3r 3  A9 3E                lda #'>'
0000C5r 3  22 rr rr rr          jsl RA8875_WriteChar
0000C9r 3  A9 20                lda #' '
0000CBr 3  22 rr rr rr          jsl RA8875_WriteChar
0000CFr 3               
0000CFr 3               
0000CFr 3                   @loop:
0000CFr 3  A6 00                ldx STREAM_STDIN                ; TODO: Get stream from Task Context (not hardcoded stdin)
0000D1r 3  22 rr rr rr          jsl StreamGetC
0000D5r 3  F0 F8                beq @loop                       ; Noting in stream (carry set)
0000D7r 3               
0000D7r 3  22 rr rr rr          jsl RA8875_WriteChar            ; Write to RA8875       - todo: write to stream (from task context) - stdout
0000DBr 3               
0000DBr 3  C5 0A                cmp $0A                         ; Is it LINE FEED?
0000DDr 3  F0 13                beq @execute                    ; yes - then execute input buffer
0000DFr 3               
0000DFr 3                       ; store in input buffer
0000DFr 3  A6 80                ldx Shell_InputBufferIndex
0000E1r 3  95 00                sta Shell_InputBufferStart,x
0000E3r 3  E8                   inx
0000E4r 3  C9 80                cmp #Shell_InputBufferIndex     ; compare to #128
0000E6r 3  D0 02                bne @cnt                        ; if not overflow then continue
0000E8r 3  64 80                stz Shell_InputBufferIndex
0000EAr 3               
0000EAr 3                   @cnt:
0000EAr 3  74 00                stz Shell_InputBufferStart,x    ; 0-terminate the end of the input buffer
0000ECr 3               
0000ECr 3  4C rr rr             jmp @loop
0000EFr 3               
0000EFr 3  C2 30                longr
0000F1r 3  60                   rts
0000F2r 3               
0000F2r 3                   @execute:
0000F2r 3               ; TODO: EXECUTE string in input buffer
0000F2r 3               
0000F2r 3                       ;lda #00                         ; put start of input buffer on stack
0000F2r 3                       ;pha
0000F2r 3                       ;pha
0000F2r 3               
0000F2r 3  4C rr rr             jmp @restart
0000F5r 3               
0000F5r 2               .include "clock.asm"
0000F5r 3               
0000F5r 3               .SEGMENT "RAM"
000132r 3               
000132r 3  xx xx        ClockCounter: .res 2
000134r 3               
000134r 3               .code
00084Dr 3               .A16
00084Dr 3               .I16
00084Dr 3               ClockExec:
00084Dr 3  E2 30            shortr
00084Fr 3  A9 00            lda #$0
000851r 3  85 00            sta $0
000853r 3               @loop:
000853r 3  EE rr rr         inc ClockCounter
000856r 3  D0 03            BNE @lowonly    ; Branch to end if the low byte didn't roll over to 00.
000858r 3  EE rr rr         inc ClockCounter+1
00085Br 3                   @lowonly:
00085Br 3               
00085Br 3               
00085Br 3  4C rr rr         jmp @loop
00085Er 3               
00085Er 3  C2 30            longr
000860r 3  60               rts
000861r 3               
000861r 2               .include "diodeblink.asm"
000861r 3               .RODATA
000433r 3               
000433r 3  0D 28 2A 2D  running_diode_0: .asciiz "\r(*------)"
000437r 3  2D 2D 2D 2D  
00043Br 3  2D 29 00     
00043Er 3  0D 28 2D 2A  running_diode_1: .asciiz "\r(-*-----)"
000442r 3  2D 2D 2D 2D  
000446r 3  2D 29 00     
000449r 3  0D 28 2D 2D  running_diode_2: .asciiz "\r(--*----)"
00044Dr 3  2A 2D 2D 2D  
000451r 3  2D 29 00     
000454r 3  0D 28 2D 2D  running_diode_3: .asciiz "\r(---*---)"
000458r 3  2D 2A 2D 2D  
00045Cr 3  2D 29 00     
00045Fr 3  0D 28 2D 2D  running_diode_4: .asciiz "\r(----*--)"
000463r 3  2D 2D 2A 2D  
000467r 3  2D 29 00     
00046Ar 3  0D 28 2D 2D  running_diode_5: .asciiz "\r(-----*-)"
00046Er 3  2D 2D 2D 2A  
000472r 3  2D 29 00     
000475r 3  0D 28 2D 2D  running_diode_6: .asciiz "\r(------*)"
000479r 3  2D 2D 2D 2D  
00047Dr 3  2A 29 00     
000480r 3               
000480r 3               .code
000861r 3               .A16
000861r 3               .I16
000861r 3               LoaderExec:
000861r 3  A9 0A 00         lda #$0A
000864r 3  22 rr rr rr      jsl RA8875_WriteChar16          ; write new line
000868r 3               
000868r 3               LoaderLoop:
000868r 3               
000868r 3  F4 rr rr 22      write running_diode_0
00086Cr 3  rr rr rr 68  
000870r 3  20 rr rr         jsr LongDelayLoaderExec
000873r 3  F4 rr rr 22      write running_diode_1
000877r 3  rr rr rr 68  
00087Br 3  20 rr rr         jsr LongDelayLoaderExec
00087Er 3  F4 rr rr 22      write running_diode_2
000882r 3  rr rr rr 68  
000886r 3  20 rr rr         jsr LongDelayLoaderExec
000889r 3  F4 rr rr 22      write running_diode_3
00088Dr 3  rr rr rr 68  
000891r 3  20 rr rr         jsr LongDelayLoaderExec
000894r 3  F4 rr rr 22      write running_diode_4
000898r 3  rr rr rr 68  
00089Cr 3  20 rr rr         jsr LongDelayLoaderExec
00089Fr 3  F4 rr rr 22      write running_diode_5
0008A3r 3  rr rr rr 68  
0008A7r 3  20 rr rr         jsr LongDelayLoaderExec
0008AAr 3  F4 rr rr 22      write running_diode_6
0008AEr 3  rr rr rr 68  
0008B2r 3  20 rr rr         jsr LongDelayLoaderExec
0008B5r 3  F4 rr rr 22      write running_diode_5
0008B9r 3  rr rr rr 68  
0008BDr 3  20 rr rr         jsr LongDelayLoaderExec
0008C0r 3  F4 rr rr 22      write running_diode_4
0008C4r 3  rr rr rr 68  
0008C8r 3  20 rr rr         jsr LongDelayLoaderExec
0008CBr 3  F4 rr rr 22      write running_diode_3
0008CFr 3  rr rr rr 68  
0008D3r 3  20 rr rr         jsr LongDelayLoaderExec
0008D6r 3  F4 rr rr 22      write running_diode_2
0008DAr 3  rr rr rr 68  
0008DEr 3  20 rr rr         jsr LongDelayLoaderExec
0008E1r 3  F4 rr rr 22      write running_diode_1
0008E5r 3  rr rr rr 68  
0008E9r 3  20 rr rr         jsr LongDelayLoaderExec
0008ECr 3               
0008ECr 3  5C rr rr rr      JML LoaderLoop
0008F0r 3               
0008F0r 3               LongDelayLoaderExec:
0008F0r 3  E2 30            shortr
0008F2r 3  20 rr rr         jsr LogDelayLoader
0008F5r 3  20 rr rr         jsr LogDelayLoader
0008F8r 3  20 rr rr         jsr LogDelayLoader
0008FBr 3  C2 30            longr
0008FDr 3  60               rts
0008FEr 3               
0008FEr 3               .A8
0008FEr 3               .I8
0008FEr 3               LogDelayLoader:
0008FEr 3  A2 FF            ldx #$FF
000900r 3               LogDelayLoaderLoop1:
000900r 3  A0 FF            ldy #$FF
000902r 3               LogDelayLoaderLoop2:
000902r 3  88               dey
000903r 3  D0 FD            bne LogDelayLoaderLoop2
000905r 3  CA               dex
000906r 3  D0 F8            bne LogDelayLoaderLoop1
000908r 3  60               rts
000909r 3               
000909r 2               .include "dump.asm"
000909r 3               DumpExec:
000909r 3  20 rr rr         jsr RA8875_WriteHex
00090Cr 3  60               rts
00090Dr 3               
00090Dr 2               .include "dumpstack.asm"
00090Dr 3               .I16
00090Dr 3               .A16
00090Dr 3               DumpStack:
00090Dr 3  E2 30            shortr
00090Fr 3                 ;  lda 1,s           ;get mode
00090Fr 3                 ;  jsl RA8875_WriteHex
00090Fr 3                 ;  lda 2,s           ;get mode
00090Fr 3                 ;  jsl RA8875_WriteHex
00090Fr 3               
00090Fr 3                 ;  lda #' '
00090Fr 3                 ;  jsl RA8875_WriteChar
00090Fr 3               
00090Fr 3                   ;lda #$A
00090Fr 3                   ;jsl RA8875_WriteChar
00090Fr 3               
00090Fr 3  C2 30            longr
000911r 3  3B               tsc
000912r 3  18               clc
000913r 3  69 04 00         adc #4
000916r 3  22 rr rr rr      jsl RA8875_WriteHex16
00091Ar 3  E2 30            shortr
00091Cr 3  A9 20            lda #' '
00091Er 3  22 rr rr rr      jsl RA8875_WriteChar
000922r 3               
000922r 3  C2 30            longr
000924r 3  3B               tsc
000925r 3  18               clc
000926r 3  69 06 00         adc #6
000929r 3  22 rr rr rr      jsl RA8875_WriteHex16
00092Dr 3  E2 30            shortr
00092Fr 3  A9 20            lda #' '
000931r 3  22 rr rr rr      jsl RA8875_WriteChar
000935r 3               
000935r 3  C2 30            longr
000937r 3  3B               tsc
000938r 3  18               clc
000939r 3  69 08 00         adc #8
00093Cr 3  22 rr rr rr      jsl RA8875_WriteHex16
000940r 3  E2 30            shortr
000942r 3  A9 20            lda #' '
000944r 3  22 rr rr rr      jsl RA8875_WriteChar
000948r 3               
000948r 3               
000948r 3  C2 30            longr
00094Ar 3  3B               tsc
00094Br 3  18               clc
00094Cr 3  69 0A 00         adc #10
00094Fr 3  22 rr rr rr      jsl RA8875_WriteHex16
000953r 3  E2 30            shortr
000955r 3  A9 20            lda #' '
000957r 3  22 rr rr rr      jsl RA8875_WriteChar
00095Br 3               
00095Br 3               
00095Br 3               
00095Br 3  C2 30            longr
00095Dr 3  3B               tsc
00095Er 3  18               clc
00095Fr 3  69 0C 00         adc #12
000962r 3  22 rr rr rr      jsl RA8875_WriteHex16
000966r 3  E2 30            shortr
000968r 3  A9 20            lda #' '
00096Ar 3  22 rr rr rr      jsl RA8875_WriteChar
00096Er 3  C2 30            longr
000970r 3  3B               tsc
000971r 3  18               clc
000972r 3  69 0E 00         adc #14
000975r 3  22 rr rr rr      jsl RA8875_WriteHex16
000979r 3  E2 30            shortr
00097Br 3  A9 20            lda #' '
00097Dr 3  22 rr rr rr      jsl RA8875_WriteChar
000981r 3               
000981r 3  C2 30            longr
000983r 3  3B               tsc
000984r 3  18               clc
000985r 3  69 10 00         adc #16
000988r 3  22 rr rr rr      jsl RA8875_WriteHex16
00098Cr 3  E2 30            shortr
00098Er 3  A9 20            lda #' '
000990r 3  22 rr rr rr      jsl RA8875_WriteChar
000994r 3               
000994r 3  C2 30            longr
000996r 3  3B               tsc
000997r 3  18               clc
000998r 3  69 12 00         adc #18
00099Br 3  22 rr rr rr      jsl RA8875_WriteHex16
00099Fr 3  E2 30            shortr
0009A1r 3  A9 20            lda #' '
0009A3r 3  22 rr rr rr      jsl RA8875_WriteChar
0009A7r 3               
0009A7r 3  C2 30            longr
0009A9r 3  3B               tsc
0009AAr 3  18               clc
0009ABr 3  69 14 00         adc #20
0009AEr 3  22 rr rr rr      jsl RA8875_WriteHex16
0009B2r 3  E2 30            shortr
0009B4r 3  A9 20            lda #' '
0009B6r 3  22 rr rr rr      jsl RA8875_WriteChar
0009BAr 3               
0009BAr 3  A9 0A            lda #$A
0009BCr 3  22 rr rr rr      jsl RA8875_WriteChar
0009C0r 3               
0009C0r 3               ; Skip the first two as they are DumpStack return
0009C0r 3  A3 04            lda 4,s           ;get mode
0009C2r 3  22 rr rr rr      jsl RA8875_WriteHex
0009C6r 3  A3 05            lda 5,s           ;get mode
0009C8r 3  22 rr rr rr      jsl RA8875_WriteHex
0009CCr 3               
0009CCr 3  A9 20            lda #' '
0009CEr 3  22 rr rr rr      jsl RA8875_WriteChar
0009D2r 3               
0009D2r 3               
0009D2r 3  A3 06            lda 6,s           ;get mode
0009D4r 3  22 rr rr rr      jsl RA8875_WriteHex
0009D8r 3  A3 07            lda 7,s           ;get mode
0009DAr 3  22 rr rr rr      jsl RA8875_WriteHex
0009DEr 3               
0009DEr 3  A9 20            lda #' '
0009E0r 3  22 rr rr rr      jsl RA8875_WriteChar
0009E4r 3               
0009E4r 3               
0009E4r 3  A3 08            lda 8,s           ;get mode
0009E6r 3  22 rr rr rr      jsl RA8875_WriteHex
0009EAr 3  A3 09            lda 9,s           ;get mode
0009ECr 3  22 rr rr rr      jsl RA8875_WriteHex
0009F0r 3               
0009F0r 3               
0009F0r 3  A9 20            lda #' '
0009F2r 3  22 rr rr rr      jsl RA8875_WriteChar
0009F6r 3               
0009F6r 3               
0009F6r 3  A3 0A            lda 10,s           ;get mode
0009F8r 3  22 rr rr rr      jsl RA8875_WriteHex
0009FCr 3  A3 0B            lda 11,s           ;get mode
0009FEr 3  22 rr rr rr      jsl RA8875_WriteHex
000A02r 3               
000A02r 3  A9 20            lda #' '
000A04r 3  22 rr rr rr      jsl RA8875_WriteChar
000A08r 3               
000A08r 3               
000A08r 3  A3 0C            lda 12,s           ;get mode
000A0Ar 3  22 rr rr rr      jsl RA8875_WriteHex
000A0Er 3  A3 0D            lda 13,s           ;get mode
000A10r 3  22 rr rr rr      jsl RA8875_WriteHex
000A14r 3               
000A14r 3  A9 20            lda #' '
000A16r 3  22 rr rr rr      jsl RA8875_WriteChar
000A1Ar 3               
000A1Ar 3               
000A1Ar 3  A3 0E            lda 14,s           ;get mode
000A1Cr 3  22 rr rr rr      jsl RA8875_WriteHex
000A20r 3  A3 0F            lda 15,s           ;get mode
000A22r 3  22 rr rr rr      jsl RA8875_WriteHex
000A26r 3               
000A26r 3  A9 20            lda #' '
000A28r 3  22 rr rr rr      jsl RA8875_WriteChar
000A2Cr 3               
000A2Cr 3               
000A2Cr 3  A3 10            lda 16,s           ;get mode
000A2Er 3  22 rr rr rr      jsl RA8875_WriteHex
000A32r 3  A3 11            lda 17,s           ;get mode
000A34r 3  22 rr rr rr      jsl RA8875_WriteHex
000A38r 3               
000A38r 3               
000A38r 3  A9 20            lda #' '
000A3Ar 3  22 rr rr rr      jsl RA8875_WriteChar
000A3Er 3               
000A3Er 3               
000A3Er 3  A3 12            lda 18,s           ;get mode
000A40r 3  22 rr rr rr      jsl RA8875_WriteHex
000A44r 3  A3 13            lda 19,s           ;get mode
000A46r 3  22 rr rr rr      jsl RA8875_WriteHex
000A4Ar 3               
000A4Ar 3  A9 20            lda #' '
000A4Cr 3  22 rr rr rr      jsl RA8875_WriteChar
000A50r 3               
000A50r 3               
000A50r 3  A3 14            lda 20,s           ;get mode
000A52r 3  22 rr rr rr      jsl RA8875_WriteHex
000A56r 3  A3 15            lda 21,s           ;get mode
000A58r 3  22 rr rr rr      jsl RA8875_WriteHex
000A5Cr 3               
000A5Cr 3  A9 20            lda #' '
000A5Er 3  22 rr rr rr      jsl RA8875_WriteChar
000A62r 3               
000A62r 3               
000A62r 3  A3 16            lda 22,s           ;get mode
000A64r 3  22 rr rr rr      jsl RA8875_WriteHex
000A68r 3  A3 17            lda 23,s           ;get mode
000A6Ar 3  22 rr rr rr      jsl RA8875_WriteHex
000A6Er 3               
000A6Er 3  A9 20            lda #' '
000A70r 3  22 rr rr rr      jsl RA8875_WriteChar
000A74r 3               
000A74r 3               
000A74r 3  A3 18            lda 24,s           ;get mode
000A76r 3  22 rr rr rr      jsl RA8875_WriteHex
000A7Ar 3  A3 19            lda 25,s           ;get mode
000A7Cr 3  22 rr rr rr      jsl RA8875_WriteHex
000A80r 3               
000A80r 3               
000A80r 3  A9 20            lda #' '
000A82r 3  22 rr rr rr      jsl RA8875_WriteChar
000A86r 3               
000A86r 3               
000A86r 3  A3 1A            lda 26,s           ;get mode
000A88r 3  22 rr rr rr      jsl RA8875_WriteHex
000A8Cr 3  A3 1B            lda 27,s           ;get mode
000A8Er 3  22 rr rr rr      jsl RA8875_WriteHex
000A92r 3               
000A92r 3  A9 0A            lda #$A
000A94r 3  22 rr rr rr      jsl RA8875_WriteChar
000A98r 3               
000A98r 3  C2 30            longr
000A9Ar 3  6B               rtl
000A9Br 3               
000A9Br 2               .include "dumpregs.asm"
000A9Br 3               .A8
000A9Br 3               .I8
000A9Br 3               DumpRegs:
000A9Br 3  C2 30            longr
000A9Dr 3  48               pha
000A9Er 3  DA               phx
000A9Fr 3  5A               phy
000AA0r 3               
000AA0r 3  E2 30            shortr
000AA2r 3               
000AA2r 3  A9 41            lda #'A'
000AA4r 3  22 rr rr rr      jsl RA8875_WriteChar
000AA8r 3  A9 3A            lda #':'
000AAAr 3  22 rr rr rr      jsl RA8875_WriteChar
000AAEr 3  A9 20            lda #' '
000AB0r 3  22 rr rr rr      jsl RA8875_WriteChar
000AB4r 3  A3 06            lda 6,s           ;get mode
000AB6r 3  22 rr rr rr      jsl RA8875_WriteHex
000ABAr 3  A3 05            lda 5,s           ;get mode
000ABCr 3  22 rr rr rr      jsl RA8875_WriteHex
000AC0r 3  A9 0A            lda #$0A
000AC2r 3  22 rr rr rr      jsl RA8875_WriteChar
000AC6r 3               
000AC6r 3               
000AC6r 3  A9 59            lda #'Y'
000AC8r 3  22 rr rr rr      jsl RA8875_WriteChar
000ACCr 3  A9 3A            lda #':'
000ACEr 3  22 rr rr rr      jsl RA8875_WriteChar
000AD2r 3  A9 20            lda #' '
000AD4r 3  22 rr rr rr      jsl RA8875_WriteChar
000AD8r 3  A3 02            lda 2,s           ;get mode
000ADAr 3  22 rr rr rr      jsl RA8875_WriteHex
000ADEr 3  A3 01            lda 1,s           ;get mode
000AE0r 3  22 rr rr rr      jsl RA8875_WriteHex
000AE4r 3  A9 0A            lda #$0A
000AE6r 3  22 rr rr rr      jsl RA8875_WriteChar
000AEAr 3               
000AEAr 3  A9 58            lda #'X'
000AECr 3  22 rr rr rr      jsl RA8875_WriteChar
000AF0r 3  A9 3A            lda #':'
000AF2r 3  22 rr rr rr      jsl RA8875_WriteChar
000AF6r 3  A9 20            lda #' '
000AF8r 3  22 rr rr rr      jsl RA8875_WriteChar
000AFCr 3  A3 04            lda 4,s           ;get mode
000AFEr 3  22 rr rr rr      jsl RA8875_WriteHex
000B02r 3  A3 03            lda 3,s           ;get mode
000B04r 3  22 rr rr rr      jsl RA8875_WriteHex
000B08r 3  A9 0A            lda #$0A
000B0Ar 3  22 rr rr rr      jsl RA8875_WriteChar
000B0Er 3               
000B0Er 3               
000B0Er 3               
000B0Er 3  C2 30            longr       ;select 16 bit registers
000B10r 3               
000B10r 3  7A               ply
000B11r 3  FA               plx
000B12r 3  68               pla
000B13r 3               
000B13r 3  60               rts
000B14r 3               
000B14r 2               
000B14r 1               .A8
000B14r 1               .I8
000B14r 1               ResetVector:
000B14r 1  A2 FF            ldx #$FF
000B16r 1  9A               txs
000B17r 1  D8               cld
000B18r 1  20 rr rr         jsr InitBIOS                    ; Entry point for boot
000B1Br 1               
000B1Br 1  C2 30            longr
000B1Dr 1  20 rr rr         jsr InitKernel                  ; Kernel Init
000B20r 1               
000B20r 1                   ;shortr
000B20r 1                   ;write test_string
000B20r 1               
000B20r 1                   ; longr
000B20r 1                   ; ldx #$1234
000B20r 1                   ; ldy #$5678
000B20r 1                   ; lda #$9ABC
000B20r 1                   ; jsr DumpRegs
000B20r 1               
000B20r 1                   ; longr
000B20r 1                   ; ldx #$EFEF
000B20r 1                   ; ldy #$4242
000B20r 1                   ; lda #$ABCD
000B20r 1                   ; pha
000B20r 1                   ; lda #$0123
000B20r 1                   ; pha
000B20r 1                   ; lda #$CDEF
000B20r 1               
000B20r 1                   ; longr
000B20r 1                   ; pla
000B20r 1               
000B20r 1               ; print break
000B20r 1               
000B20r 1                   ;write test_string
000B20r 1               
000B20r 1               ; StrLen
000B20r 1               
000B20r 1               
000B20r 1                   ; pea testlen_string				; Add parameter to stack
000B20r 1               
000B20r 1                   ; lda #Std_StrLen
000B20r 1                   ; jsl StdLib						; Call stdlib
000B20r 1               
000B20r 1               	; plx								; Clean up stack
000B20r 1               
000B20r 1                   ; jsl RA8875_WriteHex16			; Debug write result
000B20r 1               
000B20r 1               ; print break
000B20r 1               
000B20r 1                   ;write test_string
000B20r 1               
000B20r 1               
000B20r 1               
000B20r 1               
000B20r 1               ; Readnum
000B20r 1               
000B20r 1               
000B20r 1                   ; pea testlen_string				; Add parameter to stack
000B20r 1               
000B20r 1               
000B20r 1                   ; lda #Std_ReadNum
000B20r 1                   ; jsl StdLib						; Call stdlib
000B20r 1               
000B20r 1               	; plx								; Clean up stack
000B20r 1               
000B20r 1                   ; jsl RA8875_WriteHex16			; Debug write result
000B20r 1               
000B20r 1               ; print break
000B20r 1               
000B20r 1                   ;write test_string
000B20r 1               
000B20r 1  E2 30            shortr
000B22r 1  A9 00            lda #$00            ; push program bank of ShellExec
000B24r 1  48               pha
000B25r 1  C2 30            longr
000B27r 1  F4 rr rr         pea ShellExec       ; push 2byte addr of ShellExec
000B2Ar 1               
000B2Ar 1  22 rr rr rr      jsl TaskSpawn
000B2Er 1  68               pla
000B2Fr 1  E2 30            shortr
000B31r 1  68               pla
000B32r 1               
000B32r 1               
000B32r 1                   ;longr
000B32r 1                   ;write test_string
000B32r 1                   ;shortr
000B32r 1                   ;lda TaskStatus
000B32r 1                   ;jsl RA8875_WriteHex
000B32r 1               
000B32r 1               
000B32r 1                   ;longr
000B32r 1                   ;write test_string
000B32r 1                   ;shortr
000B32r 1               
000B32r 1  AD rr rr         lda TaskProgramBank
000B35r 1  22 rr rr rr      jsl RA8875_WriteHex
000B39r 1  AD rr rr         lda TaskProgramPointer
000B3Cr 1  22 rr rr rr      jsl RA8875_WriteHex
000B40r 1  AD rr rr         lda TaskProgramPointer+1
000B43r 1  22 rr rr rr      jsl RA8875_WriteHex
000B47r 1               
000B47r 1                   ;longr
000B47r 1                   ;write test_string
000B47r 1                   ;shortr
000B47r 1               
000B47r 1  A9 00            lda #$00            ; push program bank of ClockExec
000B49r 1  48               pha
000B4Ar 1  C2 30            longr
000B4Cr 1  F4 rr rr         pea ClockExec       ; push 2byte addr of ClockExec
000B4Fr 1  22 rr rr rr      jsl TaskSpawn
000B53r 1               
000B53r 1  68               pla ; elean up 16bits
000B54r 1               
000B54r 1                   ;write test_string
000B54r 1  E2 30            shortr
000B56r 1  68               pla ; clean up
000B57r 1               
000B57r 1                   ; debug printing of task
000B57r 1                   ;lda TaskProgramBank+1
000B57r 1                   ;jsl RA8875_WriteHex
000B57r 1                   ;lda TaskProgramPointer+2
000B57r 1                   ;jsl RA8875_WriteHex
000B57r 1                   ;lda TaskProgramPointer+3
000B57r 1                   ;jsl RA8875_WriteHex
000B57r 1               
000B57r 1               
000B57r 1  58               cli
000B58r 1               
000B58r 1                   ;jsl Scheduler_NextTask
000B58r 1                   ;jsr ShellExec                   ; Run shell program
000B58r 1               
000B58r 1               ; Blink Diode
000B58r 1                   ;jsl LoaderExec
000B58r 1               
000B58r 1               Loop:
000B58r 1  4C rr rr         jmp Loop
000B5Br 1               
000B5Br 1               .SEGMENT "NATIVE_VECTORS"
000000r 1  00 00            .word $0000                 ; COP
000002r 1  00 00            .word $0000                 ; BRK
000004r 1  00 00            .word $0000                 ; ABORTB
000006r 1  00 00            .word $0000                 ; NMIB
000008r 1  00 00            .word $0000                 ; RES
00000Ar 1               .SEGMENT "VECTORS"
000000r 1  rr rr            .word ResetVector           ; RESET
000002r 1  rr rr            .word InterruptVector       ; IRQB
000004r 1               
000004r 1               
