ca65 V2.18 - Ubuntu 2.19-1
Main file   : src/main.asm
Current file: src/main.asm

000000r 1               .setcpu "65816"
000000r 1               .P816
000000r 1               .smart
000000r 1               .feature string_escapes
000000r 1               
000000r 1               .RODATA
000000r 1               
000000r 1  0A 2D 2D 2D  test_string: .asciiz "\n---\n"
000004r 1  0A 00        
000006r 1  31 33 35 37  testlen_string: .asciiz "1357abcdefgh78"
00000Ar 1  61 62 63 64  
00000Er 1  65 66 67 68  
000015r 1               
000015r 1               .code
000000r 1               .include "kernel/kernel.inc"
000000r 2               .A16
000000r 2               .I16
000000r 2               .macro write str_addr
000000r 2                   SEI
000000r 2                   pea str_addr
000000r 2                   JSL RA8875_WriteString16
000000r 2                   PLA
000000r 2                   CLI
000000r 2               .endmacro
000000r 2               
000000r 2               .A8
000000r 2               .I8
000000r 2               .macro write_char char
000000r 2                   PHA
000000r 2                   LDA char
000000r 2                   JSR RA8875_WriteStringChar
000000r 2                   PLA
000000r 2               .endmacro
000000r 2               
000000r 2               .RODATA
000015r 2               
000015r 2  0A 00        newline:                    .asciiz "\n"
000017r 2  4B 45 52 4E  init_kernel_done:           .asciiz "KERNEL - OK\n"
00001Br 2  45 4C 20 2D  
00001Fr 2  20 4F 4B 0A  
000024r 2  4B 45 52 4E  init_kernel_streams_done:   .asciiz "KERNEL: Streams - OK\n"
000028r 2  45 4C 3A 20  
00002Cr 2  53 74 72 65  
00003Ar 2  4B 45 52 4E  init_kernel_tasks_done:     .asciiz "KERNEL: Tasks - OK\n"
00003Er 2  45 4C 3A 20  
000042r 2  54 61 73 6B  
00004Er 2  4B 45 52 4E  init_kernel_scheduler_done: .asciiz "KERNEL: Scheduler - OK\n"
000052r 2  45 4C 3A 20  
000056r 2  53 63 68 65  
000066r 2               .code
000000r 2               
000000r 1               .include "macros/macros.inc"
000000r 2               ; bmn
000000r 2               ;       Block move macro
000000r 2               
000000r 2               .macro  bmn     len,from,to
000000r 2                       lda     #len-1
000000r 2                       ldx     #(from & $FFFF)
000000r 2                       ldy     #(to   & $FFFF)
000000r 2                       mvn     (from & $FF0000),(to & $FF0000)
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ;   Register Size Macros
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;   These macros are a convenient way to change the MPU's register sizes
000000r 2               ;   without having to remember the correct bit pattern for the REP & SEP
000000r 2               ;   instructions.  The assembler itself has no awareness of whether 8 or
000000r 2               ;   16 bit immediate mode operands are to be used.   Therefore, it is up
000000r 2               ;   to the programmer to use the appropriate instructions, & to be aware
000000r 2               ;   at all times of the MPU's register sizes.
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;
000000r 2               .macro  longa                ;16 bit accumulator & memory
000000r 2                       rep #$20
000000r 2               .A16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longr                ;16 bit all registers
000000r 2                       rep #$30
000000r 2               .A16
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longi              ;16 bit index registers
000000r 2                       rep #$10
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorta                ;8 bit accumulator & memory
000000r 2                       sep #$20
000000r 2               .A8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorti                ;8 bit index registers
000000r 2                       sep #$10
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shortr                ;8 bit all registers
000000r 2                       sep #$30
000000r 2               .A8
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               
000000r 1               
000000r 1               .include "bios/bios.asm"
000000r 2               .include "bios.inc"                         ; include BIOS includes
000000r 3               .RODATA
000066r 3               
000066r 3  42 49 4F 53  bios_init: .asciiz "BIOS Initialized"
00006Ar 3  20 49 6E 69  
00006Er 3  74 69 61 6C  
000077r 3  20 2D 20 4F  ok_string: .asciiz " - OK\n"
00007Br 3  4B 0A 00     
00007Er 3               
00007Er 3               
00007Er 3  43 4F 4C 4F  ansi_string: .byte "COLOR: ", $1B, $5B, "32mGREEN", $1B, $5B, "37m WHITE\n", $00
000082r 3  52 3A 20 1B  
000086r 3  5B 33 32 6D  
00009Cr 3               
00009Cr 3  49 4E 49 54  test_bios: .asciiz "INIT...\n"
0000A0r 3  2E 2E 2E 0A  
0000A4r 3  00           
0000A5r 3  20 2D 20 46  fail_string: .asciiz " - FAIL\n"
0000A9r 3  41 49 4C 0A  
0000ADr 3  00           
0000AEr 3               
0000AEr 3  20 5F 5F 5F  welcome_logo1: .asciiz " ______   ______   ______     ____     ______       ______   ______\n"
0000B2r 3  5F 5F 5F 20  
0000B6r 3  20 20 5F 5F  
0000F3r 3  2F 5F 5F 5F  welcome_logo2: .asciiz "/_____/\\ /_____/\\ /_____/\\   /___/\\   /_____/\\     /_____/\\ /_____/\\\n"
0000F7r 3  5F 5F 2F 5C  
0000FBr 3  20 2F 5F 5F  
000139r 3  5C 3A 3A 3A  welcome_logo3: .asciiz "\\:::__\\/ \\::::_\\/_\\:::_:\\ \\  \\_::\\ \\  \\:::__\\/     \\:::_ \\ \\\\::::_\\/_\n"
00013Dr 3  5F 5F 5C 2F  
000141r 3  20 5C 3A 3A  
000180r 3  20 5C 3A 5C  welcome_logo4: .asciiz " \\:\\ \\____\\:\\/___/\\\\:\\_\\:\\ \\   \\::\\ \\  \\:\\ \\____    \\:\\ \\ \\ \\\\:\\/___/\\\n"
000184r 3  20 5C 5F 5F  
000188r 3  5F 5F 5C 3A  
0001C8r 3  20 20 5C 3A  welcome_logo5: .asciiz "  \\::__::/\\\\_::._\\:\\\\::__:\\ \\  _\\: \\ \\__\\::__::/\\    \\:\\ \\ \\ \\\\_::._\\:\\\n"
0001CCr 3  3A 5F 5F 3A  
0001D0r 3  3A 2F 5C 5C  
000211r 3  20 20 20 5C  welcome_logo6: .asciiz "   \\:\\_\\:\\ \\/_____\\/ \\:\\_\\:\\ \\/__\\: \\__/\\\\:\\_\\:\\ \\    \\:\\_\\ \\ \\ /____\\:\\\n"
000215r 3  3A 5C 5F 5C  
000219r 3  3A 5C 20 5C  
00025Br 3  20 20 20 20  welcome_logo7: .asciiz "    \\_____\\/\\_____/   \\_____\\/\\________\\/ \\_____\\/     \\_____\\/ \\_____\\/\n"
00025Fr 3  5C 5F 5F 5F  
000263r 3  5F 5F 5C 2F  
0002A5r 3               
0002A5r 3               .code
000000r 3               
000000r 2               .include "via.inc"                          ; include VIA labels
000000r 3               
000000r 3                   .import __VIA1_START__
000000r 3                   .import __VIA2_START__
000000r 3               
000000r 3                   VIA1B = __VIA1_START__                            ; VIA PORT B input/output register
000000r 3                   VIA1A = __VIA1_START__ + 1                        ; VIA PORT A input/output register
000000r 3                   VIA1B_DIRECTION = __VIA1_START__ + 2              ; VIA PORT B direction register is $6002
000000r 3                   VIA1A_DIRECTION = __VIA1_START__ + 3              ; VIA PORT A direction register is $6003
000000r 3                   VIA1_T1CL = __VIA1_START__ + 4                    ; Timer 1 Low order latches
000000r 3                   VIA1_T1CH = __VIA1_START__ + 5                    ; Timer 1 High order counter
000000r 3                   VIA1_ACR = __VIA1_START__ + 11                    ; Auxillary Control Register
000000r 3                   VIA1_PCR = __VIA1_START__ + 12                    ; Peripheral Control Register
000000r 3                   VIA1_IFR = __VIA1_START__ + 13                    ; Interupt Flag Register
000000r 3                   VIA1_IER = __VIA1_START__ + 14                    ; Interupt Enable Register
000000r 3               
000000r 3                   VIA2B = __VIA2_START__                            ; VIA2 PORT B input/output register
000000r 3                   VIA2A = __VIA2_START__ + 1                        ; VIA2 PORT A input/output register
000000r 3                   VIA2B_DIRECTION = __VIA2_START__ + 2              ; VIA2 PORT B direction register is $5002
000000r 3                   VIA2A_DIRECTION = __VIA2_START__ + 3              ; VIA2 PORT A direction register is $5003
000000r 3               
000000r 2               .include "drivers/spi/spi.asm"           ; include SPI code
000000r 3               .SEGMENT "KERNEL"
000000r 3  xx               spi_byte_out:               .res 1
000001r 3  xx               spi_byte_in:                .res 1
000002r 3  xx               spi_selected_device:        .res 1
000003r 3               
000003r 3               .code
000000r 3               .A8
000000r 3               .I8
000000r 3               SPI_VIA = VIA1B
000000r 3               
000000r 3               ; prepares spi VIA PORT A for input output
000000r 3               InitSPI:
000000r 3  A9 47            LDA #$47
000002r 3  8D rr rr         STA VIA1B_DIRECTION
000005r 3  A9 00            LDA #$00
000007r 3  8D rr rr         STA SPI_VIA
00000Ar 3  60               RTS
00000Br 3               
00000Br 3               ; select device for spi communication
00000Br 3               SpiDeviceSelect:
00000Br 3  8D rr rr         STA spi_selected_device
00000Er 3  AD rr rr         LDA SPI_VIA
000011r 3  60               RTS
000012r 3               
000012r 3               ; deselect spi device
000012r 3               SpiDeviceDeselect:
000012r 3  9C rr rr         STZ spi_selected_device
000015r 3  9C rr rr         STZ SPI_VIA
000018r 3  60               RTS
000019r 3               
000019r 3               
000019r 3               ; Transmit one byte SPI data. Remember to select SPI device with SpiDeviceSelect
000019r 3               ; in:
000019r 3               ;   A - byte to send over SPI
000019r 3               ; out:
000019r 3               ;   A - byte received over SPI
000019r 3               
000019r 3               SpiByte:
000019r 3  78               SEI
00001Ar 3  8D rr rr         STA spi_byte_out                            ; store
00001Dr 3  9C rr rr         STZ spi_byte_in
000020r 3  A2 08            LDX #8
000022r 3  AD rr rr         LDA spi_selected_device
000025r 3               spibytelp:
000025r 3  0E rr rr         ASL spi_byte_out	                        ; (5) shift MSB in to carry
000028r 3  90 02            BCC spibyte1
00002Ar 3  09 40            ORA #$40                                    ; set MOSI if MSB set
00002Cr 3               spibyte1:
00002Cr 3  8D rr rr         STA SPI_VIA	                                ; output (MOSI    SCS low   SCLK low)
00002Fr 3               
00002Fr 3  AD rr rr         LDA spi_selected_device                     ; set A to selected device bit (Do it here for delay reasons)
000032r 3  EE rr rr         INC SPI_VIA                                 ; toggle clock high (SCLK is bit 0)
000035r 3               
000035r 3  18               CLC                                         ; clear C (Not affected by bit)
000036r 3  2C rr rr         BIT SPI_VIA                                 ; copy MISO (bit 7) in to N (and MOSI in to V)
000039r 3  10 01            BPL spibyte2
00003Br 3  38               SEC		                                    ; set C is MISO bit is set (i.e. N)
00003Cr 3               spibyte2:
00003Cr 3  2E rr rr         ROL spi_byte_in		                        ; copy C (i.e. MISO bit) in to bit 0 of result
00003Fr 3  CE rr rr         DEC SPI_VIA                                 ; toggle clock low (SCLK is bit 0)
000042r 3               
000042r 3  CA               DEX
000043r 3  D0 E0            BNE spibytelp;
000045r 3  AD rr rr         LDA spi_byte_in	                            ; load result into A
000048r 3  58               CLI
000049r 3  60               RTS
00004Ar 3               
00004Ar 2               .include "drivers/keyboard/keyboard.asm" ; include Keyboard driver
00004Ar 3               KB_CONTROL_RELEASE      = %00000001
00004Ar 3               KB_CONTROL_RELEASE_INV  = %11111110
00004Ar 3               KB_CONTROL_EXTENDED     = %00000010
00004Ar 3               KB_CONTROL_EXTENDED_INV = %11111101
00004Ar 3               KB_CONTROL_SHIFTED      = %10000000
00004Ar 3               KB_CONTROL_SHIFTED_INV  = %01111111
00004Ar 3               
00004Ar 3               .include "keyboard_layout_iso.inc"
00004Ar 4               
00004Ar 4               .rodata
0002A5r 4               ASCIITBL:
0002A5r 4  00                          .byte $00               ; 00 no key pressed
0002A6r 4  89                          .byte $89               ; 01 F9
0002A7r 4  87                          .byte $87               ; 02 relocated F7
0002A8r 4  85                          .byte $85               ; 03 F5
0002A9r 4  83                          .byte $83               ; 04 F3
0002AAr 4  81                          .byte $81               ; 05 F1
0002ABr 4  82                          .byte $82               ; 06 F2
0002ACr 4  8C                          .byte $8C               ; 07 F12
0002ADr 4  00                          .byte $00               ; 08
0002AEr 4  8A                          .byte $8A               ; 09 F10
0002AFr 4  88                          .byte $88               ; 0A F8
0002B0r 4  86                          .byte $86               ; 0B F6
0002B1r 4  84                          .byte $84               ; 0C F4
0002B2r 4  09                          .byte $09               ; 0D tab
0002B3r 4  60                          .byte $60               ; 0E `~
0002B4r 4  8F                          .byte $8F               ; 0F relocated Print Screen key
0002B5r 4  03                          .byte $03               ; 10 relocated Pause/Break key
0002B6r 4  A0                          .byte $A0               ; 11 left alt (right alt too)
0002B7r 4  00                          .byte $00               ; 12 left shift
0002B8r 4  E0                          .byte $E0               ; 13 relocated Alt release code
0002B9r 4  00                          .byte $00               ; 14 left ctrl (right ctrl too)
0002BAr 4  71                          .byte $71               ; 15 qQ
0002BBr 4  31                          .byte $31               ; 16 1!
0002BCr 4  00                          .byte $00               ; 17
0002BDr 4  00                          .byte $00               ; 18
0002BEr 4  00                          .byte $00               ; 19
0002BFr 4  7A                          .byte $7A               ; 1A zZ
0002C0r 4  73                          .byte $73               ; 1B sS
0002C1r 4  61                          .byte $61               ; 1C aA
0002C2r 4  77                          .byte $77               ; 1D wW
0002C3r 4  32                          .byte $32               ; 1E 2@
0002C4r 4  A1                          .byte $A1               ; 1F Windows 98 menu key (left side)
0002C5r 4  02                          .byte $02               ; 20 relocated ctrl-break key
0002C6r 4  63                          .byte $63               ; 21 cC
0002C7r 4  78                          .byte $78               ; 22 xX
0002C8r 4  64                          .byte $64               ; 23 dD
0002C9r 4  65                          .byte $65               ; 24 eE
0002CAr 4  34                          .byte $34               ; 25 4$
0002CBr 4  33                          .byte $33               ; 26 3#
0002CCr 4  A2                          .byte $A2               ; 27 Windows 98 menu key (right side)
0002CDr 4  00                          .byte $00               ; 28
0002CEr 4  20                          .byte $20               ; 29 space
0002CFr 4  76                          .byte $76               ; 2A vV
0002D0r 4  66                          .byte $66               ; 2B fF
0002D1r 4  74                          .byte $74               ; 2C tT
0002D2r 4  72                          .byte $72               ; 2D rR
0002D3r 4  35                          .byte $35               ; 2E 5%
0002D4r 4  A3                          .byte $A3               ; 2F Windows 98 option key (right click, right side)
0002D5r 4  00                          .byte $00               ; 30
0002D6r 4  6E                          .byte $6E               ; 31 nN
0002D7r 4  62                          .byte $62               ; 32 bB
0002D8r 4  68                          .byte $68               ; 33 hH
0002D9r 4  67                          .byte $67               ; 34 gG
0002DAr 4  79                          .byte $79               ; 35 yY
0002DBr 4  36                          .byte $36               ; 36 6^
0002DCr 4  00                          .byte $00               ; 37
0002DDr 4  00                          .byte $00               ; 38
0002DEr 4  00                          .byte $00               ; 39
0002DFr 4  6D                          .byte $6D               ; 3A mM
0002E0r 4  6A                          .byte $6A               ; 3B jJ
0002E1r 4  75                          .byte $75               ; 3C uU
0002E2r 4  37                          .byte $37               ; 3D 7/
0002E3r 4  38                          .byte $38               ; 3E 8(
0002E4r 4  00                          .byte $00               ; 3F
0002E5r 4  00                          .byte $00               ; 40
0002E6r 4  2C                          .byte $2C               ; 41 ,<
0002E7r 4  6B                          .byte $6B               ; 42 kK
0002E8r 4  69                          .byte $69               ; 43 iI
0002E9r 4  6F                          .byte $6F               ; 44 oO
0002EAr 4  30                          .byte $30               ; 45 0=
0002EBr 4  39                          .byte $39               ; 46 9)
0002ECr 4  00                          .byte $00               ; 47
0002EDr 4  00                          .byte $00               ; 48
0002EEr 4  2E                          .byte $2E               ; 49 .>
0002EFr 4  2D                          .byte $2D               ; 4A -_
0002F0r 4  6C                          .byte $6C               ; 4B lL
0002F1r 4  3B                          .byte $3B               ; 4C ;:
0002F2r 4  70                          .byte $70               ; 4D pP
0002F3r 4  2B                          .byte $2B               ; 4E +?
0002F4r 4  00                          .byte $00               ; 4F
0002F5r 4  00                          .byte $00               ; 50
0002F6r 4  00                          .byte $00               ; 51
0002F7r 4  27                          .byte $27               ; 52 '"
0002F8r 4  00                          .byte $00               ; 53
0002F9r 4  5B                          .byte $5B               ; 54 [{
0002FAr 4  3D                          .byte $3D               ; 55 =+
0002FBr 4  00                          .byte $00               ; 56
0002FCr 4  00                          .byte $00               ; 57
0002FDr 4  00                          .byte $00               ; 58 caps
0002FEr 4  00                          .byte $00               ; 59 r shift
0002FFr 4  0A                          .byte $0A               ; 5A <Enter>
000300r 4  5D                          .byte $5D               ; 5B ]}
000301r 4  00                          .byte $00               ; 5C
000302r 4  27                          .byte $27               ; 5D '*
000303r 4  00                          .byte $00               ; 5E
000304r 4  00                          .byte $00               ; 5F
000305r 4  00                          .byte $00               ; 60
000306r 4  00                          .byte $00               ; 61
000307r 4  00                          .byte $00               ; 62
000308r 4  00                          .byte $00               ; 63
000309r 4  00                          .byte $00               ; 64
00030Ar 4  00                          .byte $00               ; 65
00030Br 4  08                          .byte $08               ; 66 bkspace
00030Cr 4  00                          .byte $00               ; 67
00030Dr 4  00                          .byte $00               ; 68
00030Er 4  31                          .byte $31               ; 69 kp 1
00030Fr 4  2F                          .byte $2f               ; 6A kp / converted from E04A in code
000310r 4  34                          .byte $34               ; 6B kp 4
000311r 4  37                          .byte $37               ; 6C kp 7
000312r 4  00                          .byte $00               ; 6D
000313r 4  00                          .byte $00               ; 6E
000314r 4  00                          .byte $00               ; 6F
000315r 4  30                          .byte $30               ; 70 kp 0
000316r 4  2E                          .byte $2E               ; 71 kp .
000317r 4  32                          .byte $32               ; 72 kp 2
000318r 4  35                          .byte $35               ; 73 kp 5
000319r 4  36                          .byte $36               ; 74 kp 6
00031Ar 4  38                          .byte $38               ; 75 kp 8
00031Br 4  1B                          .byte $1B               ; 76 esc
00031Cr 4  00                          .byte $00               ; 77 num lock
00031Dr 4  8B                          .byte $8B               ; 78 F11
00031Er 4  2B                          .byte $2B               ; 79 kp +
00031Fr 4  33                          .byte $33               ; 7A kp 3
000320r 4  2D                          .byte $2D               ; 7B kp -
000321r 4  2A                          .byte $2A               ; 7C kp *
000322r 4  39                          .byte $39               ; 7D kp 9
000323r 4  8D                          .byte $8D               ; 7E scroll lock
000324r 4  00                          .byte $00               ; 7F
000325r 4               ;
000325r 4               ; Table for shifted scancodes
000325r 4               ;
000325r 4  00                          .byte $00               ; 80
000326r 4  C9                          .byte $C9               ; 81 F9
000327r 4  C7                          .byte $C7               ; 82 relocated F7
000328r 4  C5                          .byte $C5               ; 83 F5 (F7 actual scancode=83)
000329r 4  C3                          .byte $C3               ; 84 F3
00032Ar 4  C1                          .byte $C1               ; 85 F1
00032Br 4  C2                          .byte $C2               ; 86 F2
00032Cr 4  CC                          .byte $CC               ; 87 F12
00032Dr 4  00                          .byte $00               ; 88
00032Er 4  CA                          .byte $CA               ; 89 F10
00032Fr 4  C8                          .byte $C8               ; 8A F8
000330r 4  C6                          .byte $C6               ; 8B F6
000331r 4  C4                          .byte $C4               ; 8C F4
000332r 4  09                          .byte $09               ; 8D tab
000333r 4  7E                          .byte $7E               ; 8E `~
000334r 4  CF                          .byte $CF               ; 8F relocated Print Screen key
000335r 4  03                          .byte $03               ; 90 relocated Pause/Break key
000336r 4  A0                          .byte $A0               ; 91 left alt (right alt)
000337r 4  00                          .byte $00               ; 92 left shift
000338r 4  E0                          .byte $E0               ; 93 relocated Alt release code
000339r 4  00                          .byte $00               ; 94 left ctrl (and right ctrl)
00033Ar 4  51                          .byte $51               ; 95 qQ
00033Br 4  21                          .byte $21               ; 96 1!
00033Cr 4  00                          .byte $00               ; 97
00033Dr 4  00                          .byte $00               ; 98
00033Er 4  00                          .byte $00               ; 99
00033Fr 4  5A                          .byte $5A               ; 9A zZ
000340r 4  53                          .byte $53               ; 9B sS
000341r 4  41                          .byte $41               ; 9C aA
000342r 4  57                          .byte $57               ; 9D wW
000343r 4  22                          .byte $22               ; 9E 2"
000344r 4  E1                          .byte $E1               ; 9F Windows 98 menu key (left side)
000345r 4  02                          .byte $02               ; A0 relocated ctrl-break key
000346r 4  43                          .byte $43               ; A1 cC
000347r 4  58                          .byte $58               ; A2 xX
000348r 4  44                          .byte $44               ; A3 dD
000349r 4  45                          .byte $45               ; A4 eE
00034Ar 4  24                          .byte $24               ; A5 4$
00034Br 4  23                          .byte $23               ; A6 3#
00034Cr 4  E2                          .byte $E2               ; A7 Windows 98 menu key (right side)
00034Dr 4  00                          .byte $00               ; A8
00034Er 4  20                          .byte $20               ; A9 space
00034Fr 4  56                          .byte $56               ; AA vV
000350r 4  46                          .byte $46               ; AB fF
000351r 4  54                          .byte $54               ; AC tT
000352r 4  52                          .byte $52               ; AD rR
000353r 4  25                          .byte $25               ; AE 5%
000354r 4  E3                          .byte $E3               ; AF Windows 98 option key (right click, right side)
000355r 4  00                          .byte $00               ; B0
000356r 4  4E                          .byte $4E               ; B1 nN
000357r 4  42                          .byte $42               ; B2 bB
000358r 4  48                          .byte $48               ; B3 hH
000359r 4  47                          .byte $47               ; B4 gG
00035Ar 4  59                          .byte $59               ; B5 yY
00035Br 4  5E                          .byte $5E               ; B6 6^
00035Cr 4  00                          .byte $00               ; B7
00035Dr 4  00                          .byte $00               ; B8
00035Er 4  00                          .byte $00               ; B9
00035Fr 4  4D                          .byte $4D               ; BA mM
000360r 4  4A                          .byte $4A               ; BB jJ
000361r 4  55                          .byte $55               ; BC uU
000362r 4  2F                          .byte $2F               ; BD 7/
000363r 4  28                          .byte $28               ; BE 8(
000364r 4  00                          .byte $00               ; BF
000365r 4  00                          .byte $00               ; C0
000366r 4  3B                          .byte $3B               ; C1 ,;
000367r 4  4B                          .byte $4B               ; C2 kK
000368r 4  49                          .byte $49               ; C3 iI
000369r 4  4F                          .byte $4F               ; C4 oO
00036Ar 4  3D                          .byte $3D               ; C5 0=
00036Br 4  29                          .byte $29               ; C6 9)
00036Cr 4  00                          .byte $00               ; C7
00036Dr 4  00                          .byte $00               ; C8
00036Er 4  3A                          .byte $3A               ; C9 .:
00036Fr 4  5F                          .byte $5F               ; CA -_
000370r 4  4C                          .byte $4C               ; CB lL
000371r 4  3A                          .byte $3A               ; CC ;:
000372r 4  50                          .byte $50               ; CD pP
000373r 4  3F                          .byte $3F               ; CE +?
000374r 4  00                          .byte $00               ; CF
000375r 4  00                          .byte $00               ; D0
000376r 4  00                          .byte $00               ; D1
000377r 4  22                          .byte $22               ; D2 '"
000378r 4  00                          .byte $00               ; D3
000379r 4  7B                          .byte $7B               ; D4 [{
00037Ar 4  2B                          .byte $2B               ; D5 =+
00037Br 4  00                          .byte $00               ; D6
00037Cr 4  00                          .byte $00               ; D7
00037Dr 4  00                          .byte $00               ; D8 caps
00037Er 4  00                          .byte $00               ; D9 r shift
00037Fr 4  0D                          .byte $0D               ; DA <Enter>
000380r 4  7D                          .byte $7D               ; DB ]}
000381r 4  00                          .byte $00               ; DC
000382r 4  2A                          .byte $2A               ; DD '*
000383r 4  00                          .byte $00               ; DE
000384r 4  00                          .byte $00               ; DF
000385r 4  00                          .byte $00               ; E0
000386r 4  00                          .byte $00               ; E1
000387r 4  00                          .byte $00               ; E2
000388r 4  00                          .byte $00               ; E3
000389r 4  00                          .byte $00               ; E4
00038Ar 4  00                          .byte $00               ; E5
00038Br 4  08                          .byte $08               ; E6 bkspace
00038Cr 4  00                          .byte $00               ; E7
00038Dr 4  00                          .byte $00               ; E8
00038Er 4  91                          .byte $91               ; E9 kp 1
00038Fr 4  2F                          .byte $2f               ; EA kp / converted from E04A in code
000390r 4  94                          .byte $94               ; EB kp 4
000391r 4  97                          .byte $97               ; EC kp 7
000392r 4  00                          .byte $00               ; ED
000393r 4  00                          .byte $00               ; EE
000394r 4  00                          .byte $00               ; EF
000395r 4  90                          .byte $90               ; F0 kp 0
000396r 4  7F                          .byte $7F               ; F1 kp .
000397r 4  92                          .byte $92               ; F2 kp 2
000398r 4  95                          .byte $95               ; F3 kp 5
000399r 4  96                          .byte $96               ; F4 kp 6
00039Ar 4  98                          .byte $98               ; F5 kp 8
00039Br 4  1B                          .byte $1B               ; F6 esc
00039Cr 4  00                          .byte $00               ; F7 num lock
00039Dr 4  CB                          .byte $CB               ; F8 F11
00039Er 4  2B                          .byte $2B               ; F9 kp +
00039Fr 4  93                          .byte $93               ; FA kp 3
0003A0r 4  2D                          .byte $2D               ; FB kp -
0003A1r 4  2A                          .byte $2A               ; FC kp *
0003A2r 4  99                          .byte $99               ; FD kp 9
0003A3r 4  CD                          .byte $CD               ; FE scroll lock
0003A4r 4               ; NOT USED     .byte $00               ; FF
0003A4r 4               ; end
0003A4r 4               
0003A4r 3               
0003A4r 3               .SEGMENT "RAM"
000000r 3  xx               kb_byte:                            .res 1
000001r 3                   ; control byte:
000001r 3                   ; bit 0         - release
000001r 3                   ; bit 1         - extended
000001r 3                   ; bit 7         - shifted
000001r 3  xx               kb_control_byte:                    .res 1
000002r 3               
000002r 3               .code
00004Ar 3               
00004Ar 3               InterruptKeyboard:
00004Ar 3               
00004Ar 3  E2 30            shortr
00004Cr 3  AD rr rr         lda VIA1A                               ; read byte from VIA
00004Fr 3  8D rr rr         sta kb_byte
000052r 3               
000052r 3               ; DEBUG SCANCODE
000052r 3                   ; lda #'['
000052r 3                   ; jsl RA8875_WriteChar
000052r 3                   ; lda kb_byte
000052r 3                   ; jsl RA8875_WriteHex
000052r 3                   ; lda #']'
000052r 3                   ; jsl RA8875_WriteChar
000052r 3               
000052r 3                   ; Check control byte first
000052r 3  AD rr rr         lda kb_control_byte
000055r 3  29 01            and #KB_CONTROL_RELEASE
000057r 3  D0 5F            bne keyboardHandleRelease               ; Is release control set?
000059r 3  AD rr rr         lda kb_control_byte
00005Cr 3  29 02            and #KB_CONTROL_EXTENDED
00005Er 3  D0 79            bne keyboardHandleExtended              ; Is extended control set?
000060r 3               
000060r 3               
000060r 3  AD rr rr         lda kb_byte
000063r 3               
000063r 3  20 rr rr         jsr keyboardCommandTest                 ; Test for non printable scan codes
000066r 3  F0 03            beq InterruptKeyboardReturn             ; 0 means key is handled as command
000068r 3               
000068r 3               
000068r 3  20 rr rr         jsr keyboardHandleAscii                 ; Handle as ASCII
00006Br 3               
00006Br 3               InterruptKeyboardReturn:
00006Br 3  2C rr rr         bit VIA1A
00006Er 3               
00006Er 3  60               rts
00006Fr 3               
00006Fr 3               .A8
00006Fr 3               .I8
00006Fr 3               keyboardHandleAscii:
00006Fr 3  AD rr rr         lda kb_control_byte
000072r 3  29 80            and #KB_CONTROL_SHIFTED                 ; Set bit 7 is shifted
000074r 3  0D rr rr         ora kb_byte
000077r 3               
000077r 3  AA               tax
000078r 3  BD rr rr         lda ASCIITBL,x
00007Br 3               
00007Br 3  A2 00            ldx #STREAM_STDIN
00007Dr 3                   ;jsl RA8875_WriteChar                    ; TODO: Do not print here
00007Dr 3  22 rr rr rr      jsl StreamPutC                          ; Put in standard in stream
000081r 3               
000081r 3               
000081r 3               ; DEBUG SINGLE KEY COMMANDS. TODO REMOVE THIS
000081r 3  C9 69            cmp #$69
000083r 3  D0 0E            bne @next1
000085r 3  AD rr rr         lda TaskSwitches+1
000088r 3  22 rr rr rr      jsl RA8875_WriteHex
00008Cr 3  AD rr rr         lda TaskSwitches
00008Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000093r 3               @next1:
000093r 3  C9 6A            cmp #$6A
000095r 3  D0 0E            bne @next2
000097r 3  AD rr rr         lda TimerCounter+1
00009Ar 3  22 rr rr rr      jsl RA8875_WriteHex
00009Er 3  AD rr rr         lda TimerCounter
0000A1r 3  22 rr rr rr      jsl RA8875_WriteHex
0000A5r 3               
0000A5r 3               
0000A5r 3               @next2:
0000A5r 3  C9 6B            cmp #$6B
0000A7r 3  D0 0E            bne @return
0000A9r 3  AD rr rr         lda ClockCounter+1
0000ACr 3  22 rr rr rr      jsl RA8875_WriteHex
0000B0r 3  AD rr rr         lda ClockCounter
0000B3r 3  22 rr rr rr      jsl RA8875_WriteHex
0000B7r 3               ; END DEBUG
0000B7r 3               
0000B7r 3               @return:
0000B7r 3  60               rts
0000B8r 3               
0000B8r 3               keyboardHandleRelease:
0000B8r 3  AD rr rr         lda kb_control_byte
0000BBr 3  29 FE            and #KB_CONTROL_RELEASE_INV
0000BDr 3  8D rr rr         sta kb_control_byte
0000C0r 3                   ; TODO: Toggle released key
0000C0r 3                   ;       Have a map of which keys are pressed
0000C0r 3               
0000C0r 3                   ; TODO Handle control release
0000C0r 3  AD rr rr         lda kb_byte
0000C3r 3  C9 12            cmp #$12                                ; left shift released
0000C5r 3  F0 07            beq kbClearShifted
0000C7r 3  C9 59            cmp #$59                                ; right shift released
0000C9r 3  F0 03            beq kbClearShifted
0000CBr 3               keyboardHandleReleaseCont1:
0000CBr 3  4C rr rr         jmp InterruptKeyboardReturn
0000CEr 3               
0000CEr 3               kbClearShifted:
0000CEr 3  AD rr rr         lda kb_control_byte
0000D1r 3  29 7F            and #KB_CONTROL_SHIFTED_INV
0000D3r 3  8D rr rr         sta kb_control_byte
0000D6r 3  4C rr rr         jmp keyboardHandleReleaseCont1
0000D9r 3               
0000D9r 3               keyboardHandleExtended:
0000D9r 3  AD rr rr         lda kb_control_byte
0000DCr 3  29 FD            and #KB_CONTROL_EXTENDED_INV
0000DEr 3  8D rr rr         sta kb_control_byte
0000E1r 3                   ; TODO: Handle extended key
0000E1r 3  4C rr rr         jmp InterruptKeyboardReturn
0000E4r 3               
0000E4r 3               keyboardCommandTest:
0000E4r 3  A2 04            ldx #$04
0000E6r 3               keyboardCommandTestLoop:
0000E6r 3  DD rr rr         cmp kbcommands,x
0000E9r 3  F0 04            beq keyboardCommandRun
0000EBr 3  CA               dex
0000ECr 3  10 F8            bpl keyboardCommandTestLoop
0000EEr 3  60               rts
0000EFr 3               
0000EFr 3               keyboardCommandRun:
0000EFr 3  8A               txa
0000F0r 3  0A               asl                                 ; *2 to get address from lookup table
0000F1r 3  AA               tax
0000F2r 3  7C rr rr         jmp (kbCommandRoutines,x)           ; Jmp to the command routine
0000F5r 3               
0000F5r 3               kbcommands:
0000F5r 3  12               .byte $12       ; left shift
0000F6r 3  59               .byte $59       ; right shift
0000F7r 3  14               .byte $14       ; left ctrl
0000F8r 3  E0               .byte $E0       ; extended
0000F9r 3  F0               .byte $F0       ; break
0000FAr 3                   ; TODO: Add right control
0000FAr 3               
0000FAr 3               kbCommandRoutines:
0000FAr 3  rr rr            .word kbSetShifted
0000FCr 3  rr rr            .word kbSetShifted
0000FEr 3  rr rr            .word kbnull                        ; TODO: Handle left control
000100r 3  rr rr            .word kbSetExtended
000102r 3  rr rr            .word kbSetBreak
000104r 3               
000104r 3               kbSetExtended:
000104r 3  AD rr rr         lda kb_control_byte
000107r 3  09 02            ora #KB_CONTROL_EXTENDED
000109r 3  8D rr rr         sta kb_control_byte
00010Cr 3  4C rr rr         jmp kbnull
00010Fr 3               
00010Fr 3               kbSetShifted:
00010Fr 3  AD rr rr         lda kb_control_byte
000112r 3  09 80            ora #KB_CONTROL_SHIFTED
000114r 3  8D rr rr         sta kb_control_byte
000117r 3  4C rr rr         jmp kbnull
00011Ar 3               
00011Ar 3               kbSetBreak:
00011Ar 3  AD rr rr         lda kb_control_byte
00011Dr 3  09 01            ora #KB_CONTROL_RELEASE
00011Fr 3  8D rr rr         sta kb_control_byte
000122r 3  4C rr rr         jmp kbnull
000125r 3               
000125r 3               kbnull:
000125r 3  A9 00            lda #$00
000127r 3  60               rts
000128r 3               
000128r 3               ; Initialize Keyboard driver
000128r 3               InitKeyboard:
000128r 3  E2 30            shortr
00012Ar 3  9C rr rr         stz kb_control_byte
00012Dr 3  9C rr rr         stz kb_byte
000130r 3               
000130r 3  9C rr rr         stz VIA1A_DIRECTION             ; read input
000133r 3  A9 82            lda #%10000010
000135r 3  8D rr rr         sta VIA1_IER
000138r 3               
000138r 3  A9 00            lda #$00
00013Ar 3  8D rr rr         sta VIA1_PCR
00013Dr 3  C2 30            longr
00013Fr 3               
00013Fr 3  60               rts
000140r 3               
000140r 3               
000140r 3               
000140r 2               .include "drivers/ra8875/ra8875.asm"     ; include Driver for RA8875
000140r 3               .SEGMENT "KERNEL"
000003r 3  xx xx            string_ptr:                 .res 2
000005r 3  xx xx            cursor_x:                   .res 2
000007r 3  xx xx            cursor_y:                   .res 2
000009r 3               
000009r 3  xx               control_sequence_param_1:   .res 1
00000Ar 3  xx               control_sequence_param_2:   .res 1
00000Br 3               
00000Br 3               .code
000140r 3               .A8
000140r 3               .I8
000140r 3                   .include "ra8875.inc"
000140r 4               SPI_DEVICE_RA8875 = $04
000140r 4               
000140r 4               RA8875_DATAWRITE = $00
000140r 4               RA8875_DATAREAD = $40
000140r 4               RA8875_CMDWRITE = $80
000140r 4               
000140r 4               RA8875_SYSR = $10
000140r 4               RA8875_SYSR_8BPP = $00
000140r 4               RA8875_SYSR_16BPP = $0C
000140r 4               RA8875_SYSR_MCU8 = $00
000140r 4               
000140r 4               RA8875_PLLC1 = $88
000140r 4               RA8875_PLLC1_PLLDIV2 = $80
000140r 4               RA8875_PLLC1_PLLDIV1 = $00
000140r 4               
000140r 4               RA8875_PLLC2 = $89
000140r 4               RA8875_PLLC2_DIV4 = $02
000140r 4               
000140r 4               RA8875_PCSR = $04
000140r 4               RA8875_PCSR_PDATL = $80
000140r 4               RA8875_PCSR_2CLK = $01
000140r 4               
000140r 4               RA8875_HDWR = $14
000140r 4               RA8875_HNDFTR = $15
000140r 4               RA8875_HNDFTR_DE_HIGH = $00
000140r 4               RA8875_HNDR = $16
000140r 4               RA8875_HSTR = $17
000140r 4               RA8875_HPWR = $18
000140r 4               RA8875_HPWR_LOW = $00
000140r 4               
000140r 4               RA8875_VDHR0 = $19
000140r 4               RA8875_VDHR1 = $1A
000140r 4               RA8875_VNDR0 = $1B
000140r 4               RA8875_VNDR1 = $1C
000140r 4               RA8875_VSTR0 = $1D
000140r 4               RA8875_VSTR1 = $1E
000140r 4               RA8875_VPWR = $1F
000140r 4               RA8875_VPWR_LOW = $00
000140r 4               
000140r 4               RA8875_HSAW0 = $30
000140r 4               RA8875_HSAW1 = $31
000140r 4               RA8875_HEAW0 = $34
000140r 4               RA8875_HEAW1 = $35
000140r 4               
000140r 4               RA8875_VSAW0 = $32
000140r 4               RA8875_VSAW1 = $33
000140r 4               RA8875_VEAW0 = $36
000140r 4               RA8875_VEAW1 = $37
000140r 4               
000140r 4               RA8875_FGCR0 = $63
000140r 4               RA8875_FGCR1 = $64
000140r 4               RA8875_FGCR2 = $65
000140r 4               
000140r 4               RA8875_MCLR = $8E
000140r 4               RA8875_MCLR_START = $80
000140r 4               RA8875_MCLR_FULL = $00
000140r 4               
000140r 4               RA8875_PWRR = $01
000140r 4               RA8875_PWRR_NORMAL = $00
000140r 4               RA8875_PWRR_DISPON = $80
000140r 4               
000140r 4               RA8875_P1CR = $8A
000140r 4               RA8875_P1CR_ENABLE = $80
000140r 4               RA8875_PWM_CLK_DIV1024 = $0A
000140r 4               RA8875_PWM_CLK_DIV8 = $03
000140r 4               
000140r 4               RA8875_P1DCR = $8B
000140r 4               
000140r 4               RA8875_MWCR0 = $40
000140r 4               RA8875_MWCR0_TXTMODE = $80
000140r 4               
000140r 4               RA8875_MWCR0_CURSOR = $40
000140r 4               RA8875_MWCR0_BLINK = $20
000140r 4               
000140r 4               RA8875_F_CURXL = $2A
000140r 4               RA8875_F_CURXH = $2B
000140r 4               RA8875_F_CURYL = $2C
000140r 4               RA8875_F_CURYH = $2D
000140r 4               
000140r 4               RA8875_BTCR = $44
000140r 4               
000140r 4               RA8875_FNCR0 = $21
000140r 4               
000140r 4               RA8875_MRWC = $02
000140r 4               
000140r 4               RA8875_GPIOX = $C7
000140r 4               
000140r 4               
000140r 4               RA8875_WIDTH = 800
000140r 4               RA8875_HEIGHT = 480
000140r 4               RA8875_hsync_nondisp = 26
000140r 4               RA8875_hsync_start = 32
000140r 4               RA8875_hsync_pw = 96
000140r 4               RA8875_hsync_finetune = 0
000140r 4               RA8875_vsync_nondisp = 32
000140r 4               RA8875_vsync_start = 23
000140r 4               RA8875_vsync_pw = 2
000140r 4               
000140r 4               RA_1 = $20
000140r 4               RA_2 = $21
000140r 4               
000140r 3               
000140r 3               ; Write Data  destroy A
000140r 3               ; in
000140r 3               ;   A - Data
000140r 3               RA8875WriteData:
000140r 3  48               PHA
000141r 3  A9 04            LDA #SPI_DEVICE_RA8875
000143r 3  20 rr rr         JSR SpiDeviceSelect
000146r 3  A9 00            LDA #RA8875_DATAWRITE
000148r 3  20 rr rr         JSR SpiByte
00014Br 3  68               PLA
00014Cr 3  20 rr rr         JSR SpiByte
00014Fr 3  20 rr rr         JSR SpiDeviceDeselect
000152r 3  60               RTS
000153r 3               
000153r 3               ; Write Command  destroy A
000153r 3               ; in
000153r 3               ;   A - Data
000153r 3               RA8875WriteCommand:
000153r 3  48               PHA
000154r 3  A9 04            LDA #SPI_DEVICE_RA8875
000156r 3  20 rr rr         JSR SpiDeviceSelect
000159r 3  A9 80            LDA #RA8875_CMDWRITE
00015Br 3  20 rr rr         JSR SpiByte
00015Er 3  68               PLA
00015Fr 3  20 rr rr         JSR SpiByte
000162r 3  20 rr rr         JSR SpiDeviceDeselect
000165r 3  60               RTS
000166r 3               
000166r 3               ; Read Command  destroy A
000166r 3               ; in
000166r 3               ;   A - Register to read
000166r 3               ; out
000166r 3               ;   A - Data from register
000166r 3               RA8875ReadCommand:
000166r 3  20 rr rr         JSR RA8875WriteCommand
000169r 3  A9 04            LDA #SPI_DEVICE_RA8875
00016Br 3  20 rr rr         JSR SpiDeviceSelect
00016Er 3  A9 40            LDA #RA8875_DATAREAD
000170r 3  20 rr rr         JSR SpiByte
000173r 3  20 rr rr         JSR SpiByte
000176r 3  20 rr rr         JSR SpiDeviceDeselect
000179r 3  60               RTS
00017Ar 3               
00017Ar 3               ; Initialize the RA8875  destroy AX
00017Ar 3               InitRA8875:
00017Ar 3               
00017Ar 3               ; PLL settings
00017Ar 3  A9 88            LDA #RA8875_PLLC1
00017Cr 3  20 rr rr         JSR RA8875WriteCommand
00017Fr 3  A9 0A            LDA #(RA8875_PLLC1_PLLDIV1+10)
000181r 3  20 rr rr         JSR RA8875WriteData
000184r 3               
000184r 3  20 rr rr         JSR LongDelay
000187r 3               
000187r 3  A9 89            LDA #RA8875_PLLC2
000189r 3  20 rr rr         JSR RA8875WriteCommand
00018Cr 3  A9 02            LDA #RA8875_PLLC2_DIV4
00018Er 3  20 rr rr         JSR RA8875WriteData
000191r 3               
000191r 3  20 rr rr         JSR LongDelay
000194r 3               ; Color mode  MCU size
000194r 3  A9 10            LDA #RA8875_SYSR
000196r 3  20 rr rr         JSR RA8875WriteCommand
000199r 3                   ; For 16 bit color
000199r 3                   ; LDA #(RA8875_SYSR_16BPP | RA8875_SYSR_MCU8)
000199r 3  A9 00            LDA #(RA8875_SYSR_8BPP | RA8875_SYSR_MCU8)
00019Br 3  20 rr rr         JSR RA8875WriteData
00019Er 3               
00019Er 3  20 rr rr         JSR LongDelay
0001A1r 3               
0001A1r 3               ; Pixel clock
0001A1r 3  A9 04            LDA #RA8875_PCSR
0001A3r 3  20 rr rr         JSR RA8875WriteCommand
0001A6r 3  A9 81            LDA #(RA8875_PCSR_PDATL | RA8875_PCSR_2CLK)
0001A8r 3  20 rr rr         JSR RA8875WriteData
0001ABr 3               
0001ABr 3  20 rr rr         JSR LongDelay
0001AEr 3               
0001AEr 3               ; Horizontal settings
0001AEr 3  A9 14            LDA #RA8875_HDWR
0001B0r 3  20 rr rr         JSR RA8875WriteCommand
0001B3r 3  A9 63            LDA #((RA8875_WIDTH / 8) - 1)
0001B5r 3  20 rr rr         JSR RA8875WriteData
0001B8r 3               
0001B8r 3  A9 15            LDA #RA8875_HNDFTR
0001BAr 3  20 rr rr         JSR RA8875WriteCommand
0001BDr 3  A9 00            LDA #(RA8875_HNDFTR_DE_HIGH + RA8875_hsync_finetune)
0001BFr 3  20 rr rr         JSR RA8875WriteData
0001C2r 3               
0001C2r 3  A9 16            LDA #RA8875_HNDR
0001C4r 3  20 rr rr         JSR RA8875WriteCommand
0001C7r 3  A9 03            LDA #((RA8875_hsync_nondisp - RA8875_hsync_finetune - 2) / 8)
0001C9r 3  20 rr rr         JSR RA8875WriteData
0001CCr 3               
0001CCr 3  A9 17            LDA #RA8875_HSTR
0001CEr 3  20 rr rr         JSR RA8875WriteCommand
0001D1r 3  A9 03            LDA #((RA8875_hsync_start / 8) - 1)
0001D3r 3  20 rr rr         JSR RA8875WriteData
0001D6r 3               
0001D6r 3  A9 18            LDA #RA8875_HPWR
0001D8r 3  20 rr rr         JSR RA8875WriteCommand
0001DBr 3  A9 0B            LDA #(RA8875_HPWR_LOW + ((RA8875_hsync_pw / 8) - 1))
0001DDr 3  20 rr rr         JSR RA8875WriteData
0001E0r 3               
0001E0r 3               ; Vertical settings
0001E0r 3  A9 19            LDA #RA8875_VDHR0
0001E2r 3  20 rr rr         JSR RA8875WriteCommand
0001E5r 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
0001E7r 3  20 rr rr         JSR RA8875WriteData
0001EAr 3               
0001EAr 3  A9 1A            LDA #RA8875_VDHR1
0001ECr 3  20 rr rr         JSR RA8875WriteCommand
0001EFr 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
0001F1r 3  20 rr rr         JSR RA8875WriteData
0001F4r 3               
0001F4r 3  A9 1B            LDA #RA8875_VNDR0
0001F6r 3  20 rr rr         JSR RA8875WriteCommand
0001F9r 3  A9 1F            LDA #(RA8875_vsync_nondisp - 1)
0001FBr 3  20 rr rr         JSR RA8875WriteData
0001FEr 3               
0001FEr 3  A9 1C            LDA #RA8875_VNDR1
000200r 3  20 rr rr         JSR RA8875WriteCommand
000203r 3  A9 00            LDA #(RA8875_vsync_nondisp >> 8)
000205r 3  20 rr rr         JSR RA8875WriteData
000208r 3               
000208r 3  A9 1D            LDA #RA8875_VSTR0
00020Ar 3  20 rr rr         JSR RA8875WriteCommand
00020Dr 3  A9 16            LDA #(RA8875_vsync_start - 1)
00020Fr 3  20 rr rr         JSR RA8875WriteData
000212r 3               
000212r 3  A9 1E            LDA #RA8875_VSTR1
000214r 3  20 rr rr         JSR RA8875WriteCommand
000217r 3  A9 00            LDA #(RA8875_vsync_start >> 8)
000219r 3  20 rr rr         JSR RA8875WriteData
00021Cr 3               
00021Cr 3  A9 1F            LDA #RA8875_VPWR
00021Er 3  20 rr rr         JSR RA8875WriteCommand
000221r 3  A9 01            LDA #(RA8875_VPWR_LOW + RA8875_vsync_pw - 1)
000223r 3  20 rr rr         JSR RA8875WriteData
000226r 3               
000226r 3               ; Set active window X
000226r 3               
000226r 3  A9 30            LDA #RA8875_HSAW0
000228r 3  20 rr rr         JSR RA8875WriteCommand
00022Br 3  A9 00            LDA #0
00022Dr 3  20 rr rr         JSR RA8875WriteData
000230r 3               
000230r 3  A9 31            LDA #RA8875_HSAW1
000232r 3  20 rr rr         JSR RA8875WriteCommand
000235r 3  A9 00            LDA #0
000237r 3  20 rr rr         JSR RA8875WriteData
00023Ar 3               
00023Ar 3  A9 34            LDA #RA8875_HEAW0
00023Cr 3  20 rr rr         JSR RA8875WriteCommand
00023Fr 3  A9 1F            LDA #((RA8875_WIDTH - 1) & $FF)
000241r 3  20 rr rr         JSR RA8875WriteData
000244r 3               
000244r 3  A9 35            LDA #RA8875_HEAW1
000246r 3  20 rr rr         JSR RA8875WriteCommand
000249r 3  A9 03            LDA #((RA8875_WIDTH - 1) >> 8)
00024Br 3  20 rr rr         JSR RA8875WriteData
00024Er 3               
00024Er 3               ; Set active window Y
00024Er 3               
00024Er 3  A9 32            LDA #RA8875_VSAW0
000250r 3  20 rr rr         JSR RA8875WriteCommand
000253r 3  A9 00            LDA #0
000255r 3  20 rr rr         JSR RA8875WriteData
000258r 3               
000258r 3  A9 33            LDA #RA8875_VSAW1
00025Ar 3  20 rr rr         JSR RA8875WriteCommand
00025Dr 3  A9 00            LDA #0
00025Fr 3  20 rr rr         JSR RA8875WriteData
000262r 3               
000262r 3  A9 36            LDA #RA8875_VEAW0
000264r 3  20 rr rr         JSR RA8875WriteCommand
000267r 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
000269r 3  20 rr rr         JSR RA8875WriteData
00026Cr 3               
00026Cr 3  A9 37            LDA #RA8875_VEAW1
00026Er 3  20 rr rr         JSR RA8875WriteCommand
000271r 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
000273r 3  20 rr rr         JSR RA8875WriteData
000276r 3               
000276r 3               ; Clear entire screen
000276r 3               
000276r 3  A9 8E            LDA #RA8875_MCLR
000278r 3  20 rr rr         JSR RA8875WriteCommand
00027Br 3  A9 80            LDA #(RA8875_MCLR_START | RA8875_MCLR_FULL)
00027Dr 3  20 rr rr         JSR RA8875WriteData
000280r 3               
000280r 3  20 rr rr         JSR LongDelay
000283r 3               
000283r 3               ; Display on
000283r 3  A9 01            LDA #RA8875_PWRR
000285r 3  20 rr rr         JSR RA8875WriteCommand
000288r 3               
000288r 3  A9 80            LDA #(RA8875_PWRR_NORMAL | RA8875_PWRR_DISPON)
00028Ar 3  20 rr rr         JSR RA8875WriteData
00028Dr 3               
00028Dr 3               ; GPIOX on    enable tft
00028Dr 3  A9 C7            LDA #RA8875_GPIOX
00028Fr 3  20 rr rr         JSR RA8875WriteCommand
000292r 3  A9 01            LDA #1
000294r 3  20 rr rr         JSR RA8875WriteData
000297r 3               
000297r 3               
000297r 3               ; PWM1 Config backlight
000297r 3  A9 8A            LDA #RA8875_P1CR
000299r 3  20 rr rr         JSR RA8875WriteCommand
00029Cr 3  A9 8A            LDA #(RA8875_P1CR_ENABLE | (RA8875_PWM_CLK_DIV1024 & $F))
00029Er 3  20 rr rr         JSR RA8875WriteData
0002A1r 3               
0002A1r 3               ; Backlight clock
0002A1r 3  A9 8B            LDA #RA8875_P1DCR
0002A3r 3  20 rr rr         JSR RA8875WriteCommand
0002A6r 3  A9 FF            LDA #255
0002A8r 3  20 rr rr         JSR RA8875WriteData
0002ABr 3               
0002ABr 3               ; Set text mode
0002ABr 3  20 rr rr         JSR RA8875_TextMode
0002AEr 3               
0002AEr 3  9C rr rr         STZ cursor_x
0002B1r 3               
0002B1r 3  9C rr rr         STZ cursor_x + 1
0002B4r 3               
0002B4r 3  9C rr rr         STZ cursor_y
0002B7r 3               
0002B7r 3  9C rr rr         STZ cursor_y + 1
0002BAr 3               
0002BAr 3  20 rr rr         JSR RA8875_SetTextCursor
0002BDr 3               
0002BDr 3  A9 FF            LDA #$FF
0002BFr 3  20 rr rr         JSR RA8875_SetForegroundColor
0002C2r 3               
0002C2r 3  60               RTS
0002C3r 3               
0002C3r 3               RA8875_CursorBlink:
0002C3r 3               
0002C3r 3  A9 40            LDA #RA8875_MWCR0
0002C5r 3  20 rr rr         JSR RA8875WriteCommand
0002C8r 3               
0002C8r 3  A9 C0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR)
0002CAr 3  20 rr rr         JSR RA8875WriteData
0002CDr 3               
0002CDr 3  A9 40            LDA #RA8875_MWCR0
0002CFr 3  20 rr rr         JSR RA8875WriteCommand
0002D2r 3               
0002D2r 3  A9 E0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR | RA8875_MWCR0_BLINK)
0002D4r 3  20 rr rr         JSR RA8875WriteData
0002D7r 3               
0002D7r 3  A9 44            LDA #RA8875_BTCR
0002D9r 3  20 rr rr         JSR RA8875WriteCommand
0002DCr 3               
0002DCr 3  A9 20            LDA #32                        ; Blink rate 1-255 1 is fast
0002DEr 3  20 rr rr         JSR RA8875WriteData
0002E1r 3               
0002E1r 3  60               RTS
0002E2r 3               
0002E2r 3               RA8875_CursorHide:
0002E2r 3               
0002E2r 3  A9 40            LDA #RA8875_MWCR0
0002E4r 3  20 rr rr         JSR RA8875WriteCommand
0002E7r 3               
0002E7r 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
0002E9r 3  20 rr rr         JSR RA8875WriteData
0002ECr 3               
0002ECr 3  60               RTS
0002EDr 3               
0002EDr 3               RA8875_GetTextCursorX:
0002EDr 3  A9 2B            LDA #RA8875_F_CURXH
0002EFr 3  20 rr rr         JSR RA8875ReadCommand
0002F2r 3  8D rr rr         STA cursor_x+1
0002F5r 3               
0002F5r 3  A9 2A            LDA #RA8875_F_CURXL
0002F7r 3  20 rr rr         JSR RA8875ReadCommand
0002FAr 3  8D rr rr         STA cursor_x
0002FDr 3               
0002FDr 3  60               RTS
0002FEr 3               
0002FEr 3               RA8875_GetTextCursorY:
0002FEr 3  A9 2D            LDA #RA8875_F_CURYH
000300r 3  20 rr rr         JSR RA8875ReadCommand
000303r 3  8D rr rr         STA cursor_y+1
000306r 3               
000306r 3  A9 2C            LDA #RA8875_F_CURYL
000308r 3  20 rr rr         JSR RA8875ReadCommand
00030Br 3  8D rr rr         STA cursor_y
00030Er 3               
00030Er 3  60               RTS
00030Fr 3               
00030Fr 3               RA8875_SetTextCursor:
00030Fr 3  A9 2A            LDA #RA8875_F_CURXL
000311r 3  20 rr rr         JSR RA8875WriteCommand
000314r 3  AD rr rr         LDA cursor_x
000317r 3  20 rr rr         JSR RA8875WriteData
00031Ar 3               
00031Ar 3  A9 2B            LDA #RA8875_F_CURXH
00031Cr 3  20 rr rr         JSR RA8875WriteCommand
00031Fr 3  AD rr rr         LDA cursor_x+1
000322r 3  20 rr rr         JSR RA8875WriteData
000325r 3               
000325r 3               
000325r 3  A9 2C            LDA #RA8875_F_CURYL
000327r 3  20 rr rr         JSR RA8875WriteCommand
00032Ar 3  AD rr rr         LDA cursor_y
00032Dr 3  20 rr rr         JSR RA8875WriteData
000330r 3               
000330r 3  A9 2D            LDA #RA8875_F_CURYH
000332r 3  20 rr rr         JSR RA8875WriteCommand
000335r 3  AD rr rr         LDA cursor_y+1
000338r 3  20 rr rr         JSR RA8875WriteData
00033Br 3               
00033Br 3  60               RTS
00033Cr 3               
00033Cr 3               .A8
00033Cr 3               .I8
00033Cr 3               RA8875_TextMode:
00033Cr 3  A9 40            LDA #RA8875_MWCR0
00033Er 3  20 rr rr         JSR RA8875WriteCommand
000341r 3               
000341r 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
000343r 3  20 rr rr         JSR RA8875WriteData
000346r 3               
000346r 3               ; select internal font
000346r 3  A9 21            LDA #RA8875_FNCR0
000348r 3  20 rr rr         JSR RA8875WriteCommand
00034Br 3               
00034Br 3  A9 00            LDA #0
00034Dr 3  20 rr rr         JSR RA8875WriteData
000350r 3               
000350r 3  60               RTS
000351r 3               
000351r 3               RA8875_SetForegroundColor:
000351r 3  48               PHA
000352r 3  48               PHA
000353r 3                       ; writeCommand(0x63);
000353r 3                       ; writeData((foreColor & 0xf800) >> 11);
000353r 3                       ; writeCommand(0x64);
000353r 3                       ; writeData((foreColor & 0x07e0) >> 5);
000353r 3                       ; writeCommand(0x65);
000353r 3                       ; writeData((foreColor & 0x001f));
000353r 3  A9 65            LDA #RA8875_FGCR2
000355r 3  20 rr rr         JSR RA8875WriteCommand
000358r 3               
000358r 3  68               PLA
000359r 3  20 rr rr         JSR RA8875WriteData
00035Cr 3               
00035Cr 3  A9 64            LDA #RA8875_FGCR1
00035Er 3  20 rr rr         JSR RA8875WriteCommand
000361r 3               
000361r 3  68               PLA
000362r 3  4A               lsr
000363r 3  4A               lsr
000364r 3  48               PHA
000365r 3               
000365r 3  20 rr rr         JSR RA8875WriteData
000368r 3               
000368r 3  A9 63            LDA #RA8875_FGCR0
00036Ar 3  20 rr rr         JSR RA8875WriteCommand
00036Dr 3               
00036Dr 3  68               PLA
00036Er 3               
00036Er 3  4A               lsr
00036Fr 3  4A               lsr
000370r 3  4A               lsr
000371r 3               
000371r 3  20 rr rr         JSR RA8875WriteData
000374r 3  60               RTS
000375r 3               
000375r 3               ; Handle a single char
000375r 3               RA8875_SingleChar:
000375r 3  C9 20            CMP #$20                        ; $20 or greater
000377r 3  B0 18            BCS RA8875_WriteStringChar      ; then print character
000379r 3  C9 0A            CMP #$0A                        ; Compare to 0x0A   line feed
00037Br 3  D0 04            BNE @check_1                    ; != 0x0A
00037Dr 3  20 rr rr         JSR RA8875_ControlLineFeed      ; Handle as line feed
000380r 3  60               rts                             ; Do not print
000381r 3               @check_1:
000381r 3  C9 0D            CMP #$0D                         ; Compare to 0D   carriage return
000383r 3  D0 04            BNE @check_2                      ; != 0x0D
000385r 3  20 rr rr         JSR RA8875_ControlCarriageReturn ; handle as carriage return
000388r 3  60               rts                             ; Do not print
000389r 3               @check_2:
000389r 3  C9 1B            CMP #$1B                         ; Compare to 1B   escape
00038Br 3  D0 04            BNE RA8875_WriteStringChar       ; != 0x1B
00038Dr 3  20 rr rr         JSR RA8875_ControlEscape         ; handle as escape sequence
000390r 3  60               rts                             ; Do not print
000391r 3               
000391r 3               RA8875_WriteStringChar:
000391r 3  20 rr rr         JSR RA8875WriteData
000394r 3  60               RTS
000395r 3               
000395r 3               RA8875_ControlLineFeed:
000395r 3  9C rr rr         STZ cursor_x                    ; Control char LINE FEED
000398r 3  9C rr rr         STZ cursor_x+1
00039Br 3  20 rr rr         JSR RA8875_GetTextCursorY
00039Er 3  18               CLC
00039Fr 3  69 10            ADC #16
0003A1r 3  8D rr rr         STA cursor_y
0003A4r 3  AD rr rr         LDA cursor_y+1
0003A7r 3  69 00            ADC #$00
0003A9r 3  8D rr rr         STA cursor_y+1
0003ACr 3                   ; TODO: It overflows here. Needs two bytes to handle cursor value
0003ACr 3  20 rr rr         JSR RA8875_SetTextCursor
0003AFr 3  A9 02            LDA #RA8875_MRWC
0003B1r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
0003B4r 3  60               RTS
0003B5r 3               
0003B5r 3               RA8875_ControlCarriageReturn:
0003B5r 3  9C rr rr         STZ cursor_x                    ; Control char LINE FEED
0003B8r 3  9C rr rr         STZ cursor_x+1
0003BBr 3  20 rr rr         JSR RA8875_GetTextCursorY
0003BEr 3  20 rr rr         JSR RA8875_SetTextCursor
0003C1r 3  A9 02            LDA #RA8875_MRWC
0003C3r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
0003C6r 3  60               RTS
0003C7r 3               
0003C7r 3               RA8875_ControlEscape:
0003C7r 3  C8               INY                             ; Look at next character
0003C8r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003CAr 3  F0 2C            BEQ SkipControl
0003CCr 3  C9 5B            CMP #$5B                        ; CSI look for [
0003CEr 3  D0 28            BNE SkipControl
0003D0r 3  C8               INY                             ; Next char
0003D1r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003D3r 3               
0003D3r 3  C9 33            CMP #$33
0003D5r 3  D0 1B            BNE @not_foreground
0003D7r 3  C8               INY                             ; Next char
0003D8r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003DAr 3  C9 37            CMP #$37
0003DCr 3  D0 08            BNE @nextcol1
0003DEr 3  A9 FF            LDA #%11111111
0003E0r 3  20 rr rr         jsr RA8875_SetForegroundColor
0003E3r 3  4C rr rr         jmp @done
0003E6r 3               @nextcol1:
0003E6r 3  C9 32            CMP #$32
0003E8r 3  D0 08            BNE @nextcol2
0003EAr 3  A9 1C            LDA #%00011100
0003ECr 3  20 rr rr         jsr RA8875_SetForegroundColor
0003EFr 3  4C rr rr         jmp @done
0003F2r 3               @nextcol2:
0003F2r 3               
0003F2r 3               @not_foreground:
0003F2r 3               
0003F2r 3               
0003F2r 3               @done:
0003F2r 3  C8               INY
0003F3r 3               
0003F3r 3  98               tya
0003F4r 3  22 rr rr rr      jsl RA8875_WriteHex
0003F8r 3               
0003F8r 3               
0003F8r 3               SkipControl:
0003F8r 3  60               RTS
0003F9r 3               
0003F9r 2               .include "drivers/ra8875/ra8875_api.asm" ; include API for RA8875
0003F9r 3               .A16
0003F9r 3               .I16
0003F9r 3               RA8875_WriteString16_ARG = 8
0003F9r 3               RA8875_WriteString16:
0003F9r 3  5A               PHY
0003FAr 3  DA               PHX
0003FBr 3  E2 30            shortr
0003FDr 3  A0 00            LDY #$00
0003FFr 3  A9 02            LDA #RA8875_MRWC
000401r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
000404r 3               RA8875_WriteString16_0:
000404r 3  B3 08            LDA (RA8875_WriteString16_ARG,s),Y
000406r 3  F0 06            BEQ RA8875_WriteStringEnd16       ; Is char 0 then end write
000408r 3               
000408r 3  20 rr rr         JSR RA8875_SingleChar           ; Handle single character
00040Br 3               
00040Br 3  C8               INY
00040Cr 3  D0 F6            BNE RA8875_WriteString16_0
00040Er 3               RA8875_WriteStringEnd16:
00040Er 3  C2 30            longr
000410r 3  FA               PLX
000411r 3  7A               PLY
000412r 3  6B               RTL
000413r 3               
000413r 3               .A8
000413r 3               .I8
000413r 3               RA8875_WriteChar:
000413r 3  DA               PHX
000414r 3  F0 0A            BEQ RA8875_WriteCharEnd         ; Is char 0 then end write
000416r 3  48               PHA
000417r 3  A9 02            LDA #RA8875_MRWC
000419r 3  20 rr rr         JSR RA8875WriteCommand
00041Cr 3  68               PLA
00041Dr 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
000420r 3               RA8875_WriteCharEnd:
000420r 3  FA               PLX
000421r 3  6B               RTL
000422r 3               
000422r 3               .A16
000422r 3               .I16
000422r 3               RA8875_WriteChar16:
000422r 3  F0 12            BEQ RA8875_WriteChar16End         ; Is char 0 then end write
000424r 3  48               PHA
000425r 3  E2 30            shortr
000427r 3  A9 02            LDA #RA8875_MRWC
000429r 3  20 rr rr         JSR RA8875WriteCommand
00042Cr 3  C2 30            longr
00042Er 3  68               PLA
00042Fr 3  E2 30            shortr
000431r 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
000434r 3  C2 30            longr
000436r 3               RA8875_WriteChar16End:
000436r 3  6B               RTL
000437r 3               
000437r 3               .A8
000437r 3               .I8
000437r 3               RA8875_WriteNumber:
000437r 3  A2 FF            LDX #$FF
000439r 3  38               SEC                             ; Prepare for subtraction
00043Ar 3               RA8875_WriteNumber100:
00043Ar 3  E8               INX
00043Br 3  E9 64            SBC #100
00043Dr 3  B0 FB            BCS RA8875_WriteNumber100       ; Count how many 100s
00043Fr 3  69 64            ADC #100
000441r 3  20 rr rr         JSR RA8875_WriteDigit           ; Print the 100s
000444r 3  A2 FF            LDX #$FF
000446r 3  38               SEC                             ; Prepare for subtraction
000447r 3               RA8875_WriteNumber10:
000447r 3  E8               INX
000448r 3  E9 0A            SBC #10
00044Ar 3  B0 FB            BCS RA8875_WriteNumber10         ; Count how many 10s
00044Cr 3  69 0A            ADC #10
00044Er 3  20 rr rr         JSR RA8875_WriteDigit            ; Print the 10s
000451r 3  AA               TAX                              ; Pass 1s into X
000452r 3               RA8875_WriteDigit:
000452r 3  48               PHA
000453r 3  8A               TXA                             ; Save A pass digit to A
000454r 3  09 30            ORA #$30                        ; ASCII 0
000456r 3  22 rr rr rr      JSL RA8875_WriteChar            ; Convert to character and print it
00045Ar 3  68               PLA
00045Br 3  60               RTS                             ; Restore A and return
00045Cr 3               
00045Cr 3               .A8
00045Cr 3               .I8
00045Cr 3               RA8875_WriteHex:
00045Cr 3  48               PHA                     ; Save A for LSD.
00045Dr 3  4A               LSR
00045Er 3  4A               LSR
00045Fr 3  4A               LSR                     ; MSD to LSD position.
000460r 3  4A               LSR
000461r 3  22 rr rr rr      JSL RA8875_WriteHex1    ; Output hex digit.
000465r 3  68               PLA                     ; Restore A.
000466r 3               RA8875_WriteHex1:
000466r 3  DA               PHX
000467r 3  48               PHA
000468r 3  18               CLC
000469r 3  29 0F            AND #$0F                ; Mask LSD for hex print.
00046Br 3  09 30            ORA #$30                ; Add "0".
00046Dr 3  C9 3A            CMP #$3A                ; Digit?
00046Fr 3  90 02            BCC RA8875_WriteHex2    ; Yes, output it.
000471r 3  69 06            ADC #$06                ; Add offset for letter.
000473r 3               RA8875_WriteHex2:
000473r 3  22 rr rr rr      JSL RA8875_WriteChar
000477r 3  68               PLA
000478r 3  FA               PLX
000479r 3  6B               RTL                    ; Return.
00047Ar 3               
00047Ar 3               .A16
00047Ar 3               .I16
00047Ar 3               RA8875_WriteHex16:
00047Ar 3  E2 30            shortr
00047Cr 3  EB               xba                     ; switch high and low A
00047Dr 3  22 rr rr rr      jsl RA8875_WriteHex     ; print first byte
000481r 3  EB               xba                     ; switch high and low A
000482r 3  22 rr rr rr      jsl RA8875_WriteHex     ; print second byte
000486r 3  C2 30            longr
000488r 3  6B               RTL
000489r 3               
000489r 3               
000489r 3               
000489r 3               ; CURSOR
000489r 3               
000489r 3               
000489r 3               .A16
000489r 3               .I16
000489r 3               ; takes 16 bit value in A and sets as cursor X
000489r 3               RA8875_SetTextCursorX:
000489r 3  78               SEI
00048Ar 3  48               PHA
00048Br 3  48               PHA
00048Cr 3  E2 30        shortr
00048Er 3  A9 2A            LDA #RA8875_F_CURXL
000490r 3  20 rr rr         JSR RA8875WriteCommand
000493r 3  C2 30        longr
000495r 3  68               PLA
000496r 3  E2 30        shortr
000498r 3  20 rr rr         JSR RA8875WriteData
00049Br 3               
00049Br 3  A9 2B            LDA #RA8875_F_CURXH
00049Dr 3  20 rr rr         JSR RA8875WriteCommand
0004A0r 3  C2 30        longr
0004A2r 3  68               PLA
0004A3r 3  EB               XBA
0004A4r 3  E2 30        shortr
0004A6r 3  20 rr rr         JSR RA8875WriteData
0004A9r 3  C2 30        longr
0004ABr 3  58               CLI
0004ACr 3  6B               RTL
0004ADr 3               
0004ADr 3               
0004ADr 3               .A16
0004ADr 3               .I16
0004ADr 3               RA8875_SetTextCursorY:
0004ADr 3  78               SEI
0004AEr 3  48               PHA
0004AFr 3  48               PHA
0004B0r 3  E2 30        shortr
0004B2r 3  A9 2C            LDA #RA8875_F_CURYL
0004B4r 3  20 rr rr         JSR RA8875WriteCommand
0004B7r 3  C2 30        longr
0004B9r 3  68               PLA
0004BAr 3  E2 30        shortr
0004BCr 3  20 rr rr         JSR RA8875WriteData
0004BFr 3               
0004BFr 3  A9 2D            LDA #RA8875_F_CURYH
0004C1r 3  20 rr rr         JSR RA8875WriteCommand
0004C4r 3  C2 30        longr
0004C6r 3  68               PLA
0004C7r 3  EB               XBA
0004C8r 3  E2 30        shortr
0004CAr 3  20 rr rr         JSR RA8875WriteData
0004CDr 3  C2 30        longr
0004CFr 3  58               CLI
0004D0r 3  6B               RTL
0004D1r 3               
0004D1r 2               
0004D1r 2               .include "ramtest.asm"
0004D1r 3               .RODATA
0003A4r 3               
0003A4r 3  52 75 6E 6E  ram_test_start: .asciiz "Running ram test"
0003A8r 3  69 6E 67 20  
0003ACr 3  72 61 6D 20  
0003B5r 3               
0003B5r 3               
0003B5r 3               .code
0004D1r 3               .A16
0004D1r 3               .I16
0004D1r 3               RamTestRun:
0004D1r 3  78 F4 rr rr      write ram_test_start
0004D5r 3  22 rr rr rr  
0004D9r 3  68 58        
0004DBr 3               
0004DBr 3  E2 30            shortr
0004DDr 3               ; Single cell at $0300
0004DDr 3  A9 42            LDA #$42
0004DFr 3  8D 00 03         STA $0300
0004E2r 3  A9 00            LDA #$00
0004E4r 3  AD 00 03         LDA $0300
0004E7r 3  C9 42            CMP #$42
0004E9r 3  D0 40            BNE RamTestFail
0004EBr 3               ; Single cell at $0300
0004EBr 3  A9 66            LDA #$66
0004EDr 3  8D 98 98         STA $9898
0004F0r 3  A9 00            LDA #$00
0004F2r 3  AD 98 98         LDA $9898
0004F5r 3  C9 66            CMP #$66
0004F7r 3  D0 32            BNE RamTestFail
0004F9r 3               
0004F9r 3               ; All of zero page
0004F9r 3  A2 00            ldx #0                ;ZP location index
0004FBr 3  8A               txa                   ;initialize
0004FCr 3  38               sec                   ;test "bit"
0004FDr 3               
0004FDr 3               loop0010:
0004FDr 3  95 00            sta $00,x             ;clear test cell
0004FFr 3  A0 09            ldy #9                ;bit shift iterations
000501r 3               
000501r 3               loop0020:
000501r 3  36 00            rol $00,x             ;rotate away
000503r 3  88               dey                   ;step counter
000504r 3  D0 FB            bne loop0020          ;not done
000506r 3               
000506r 3  90 23            bcc RamTestFail       ;RAM defective...abort
000508r 3               
000508r 3  B5 00            lda $0,x              ;any "stuck" bits?
00050Ar 3  D0 1F            bne RamTestFail       ;yes, bad RAM...abort
00050Cr 3               
00050Cr 3  E8               inx                   ;we done?
00050Dr 3  D0 EE            bne loop0010          ;no, do next
00050Fr 3               
00050Fr 3  C2 30            longr
000511r 3  78 F4 rr rr      write ok_string
000515r 3  22 rr rr rr  
000519r 3  68 58        
00051Br 3               
00051Br 3  A9 00 00         lda #$00
00051Er 3  A2 00 00         ldx #$0000
000521r 3               @loop:
000521r 3  9D 00 A0         sta $A000,x
000524r 3               
000524r 3  E8               inx
000525r 3  E0 00 10         cpx #$1000
000528r 3  D0 F7            bne @loop
00052Ar 3               
00052Ar 3  6B               RTL
00052Br 3               
00052Br 3               
00052Br 3               RamTestFail:
00052Br 3  C2 30            longr
00052Dr 3  78 F4 rr rr      write fail_string
000531r 3  22 rr rr rr  
000535r 3  68 58        
000537r 3  6B               RTL
000538r 3               
000538r 2               .include "ramtest_wide.asm"
000538r 3               .RODATA
0003B5r 3               
0003B5r 3  52 75 6E 6E  ram_test_start_wide: .asciiz "Running wide ram test"
0003B9r 3  69 6E 67 20  
0003BDr 3  77 69 64 65  
0003CBr 3  2E 00        ram_test_progress: .asciiz "."
0003CDr 3  31 36 20 62  bit16_registers: .asciiz "16 bit registers"
0003D1r 3  69 74 20 72  
0003D5r 3  65 67 69 73  
0003DEr 3               
0003DEr 3               .code
000538r 3               .A16
000538r 3               .I16
000538r 3               RamTestWideRun:
000538r 3               
000538r 3  78 F4 rr rr      write ram_test_start_wide
00053Cr 3  22 rr rr rr  
000540r 3  68 58        
000542r 3               
000542r 3  E2 30            shortr
000544r 3  A9 42            LDA #$42
000546r 3  8F 34 12 01      STA $011234
00054Ar 3  A9 11            LDA #$11
00054Cr 3  AF 34 12 01      LDA $011234
000550r 3  C9 42            CMP #$42
000552r 3  D0 31            BNE RamTestFailWide
000554r 3  A9 F6            LDA #$F6
000556r 3  8F 34 12 02      STA $021234
00055Ar 3  AF 34 12 01      LDA $011234
00055Er 3  C9 42            CMP #$42
000560r 3  D0 23            BNE RamTestFailWide
000562r 3  AF 34 12 02      LDA $021234
000566r 3  C9 F6            CMP #$F6
000568r 3  D0 1B            BNE RamTestFailWide
00056Ar 3  A9 55            LDA #$55
00056Cr 3  8F 34 12 03      STA $031234
000570r 3  AF 34 12 01      LDA $011234
000574r 3  C9 42            CMP #$42
000576r 3  D0 0D            BNE RamTestFailWide
000578r 3               
000578r 3  C2 30            longr
00057Ar 3  78 F4 rr rr      write ok_string
00057Er 3  22 rr rr rr  
000582r 3  68 58        
000584r 3  60               rts
000585r 3               
000585r 3               RamTestFailWide:
000585r 3  C2 30            longr
000587r 3  78 F4 rr rr      write fail_string
00058Br 3  22 rr rr rr  
00058Fr 3  68 58        
000591r 3  60               rts
000592r 3               
000592r 3               .A16
000592r 3               .I16
000592r 3               RamTestWideRegistersRun:
000592r 3               
000592r 3  78 F4 rr rr      write bit16_registers
000596r 3  22 rr rr rr  
00059Ar 3  68 58        
00059Cr 3               
00059Cr 3  A9 34 12         LDA #$1234
00059Fr 3  8F 00 04 04      STA $040400
0005A3r 3  A9 76 98         LDA #$9876
0005A6r 3  AF 00 04 04      LDA $040400
0005AAr 3  C9 34 12         CMP #$1234
0005ADr 3  D0 D6            BNE RamTestFailWide
0005AFr 3               
0005AFr 3  78 F4 rr rr      write ok_string
0005B3r 3  22 rr rr rr  
0005B7r 3  68 58        
0005B9r 3               
0005B9r 3  60               rts
0005BAr 3               
0005BAr 2               
0005BAr 2               .A8
0005BAr 2               .I8
0005BAr 2               InitBIOS:
0005BAr 2  20 rr rr         JSR InitSPI
0005BDr 2  20 rr rr         JSR InitRA8875
0005C0r 2  20 rr rr         JSR InitKeyboard
0005C3r 2               
0005C3r 2               
0005C3r 2               ; switch out of emulation mode
0005C3r 2  18               clc
0005C4r 2  FB               xce
0005C5r 2               
0005C5r 2  C2 30            longr
0005C7r 2                   ;pea test_bios
0005C7r 2                   ;jsl RA8875_WriteString16
0005C7r 2                   ;pla
0005C7r 2               
0005C7r 2                   ;shortr
0005C7r 2                   ;LDA #%01101111
0005C7r 2                   ;jsr RA8875_SetForegroundColor
0005C7r 2                   ;longr
0005C7r 2               
0005C7r 2               
0005C7r 2  78 F4 rr rr      write welcome_logo1
0005CBr 2  22 rr rr rr  
0005CFr 2  68 58        
0005D1r 2  78 F4 rr rr      write welcome_logo2
0005D5r 2  22 rr rr rr  
0005D9r 2  68 58        
0005DBr 2  78 F4 rr rr      write welcome_logo3
0005DFr 2  22 rr rr rr  
0005E3r 2  68 58        
0005E5r 2  78 F4 rr rr      write welcome_logo4
0005E9r 2  22 rr rr rr  
0005EDr 2  68 58        
0005EFr 2  78 F4 rr rr      write welcome_logo5
0005F3r 2  22 rr rr rr  
0005F7r 2  68 58        
0005F9r 2  78 F4 rr rr      write welcome_logo6
0005FDr 2  22 rr rr rr  
000601r 2  68 58        
000603r 2  78 F4 rr rr      write welcome_logo7
000607r 2  22 rr rr rr  
00060Br 2  68 58        
00060Dr 2               
00060Dr 2                   ;lda #$0A
00060Dr 2                   ;jsl RA8875_WriteChar16
00060Dr 2               
00060Dr 2                   ;shortr
00060Dr 2                   ;LDA #%11111111
00060Dr 2                   ;jsr RA8875_SetForegroundColor
00060Dr 2                   ;longr
00060Dr 2               
00060Dr 2  22 rr rr rr      JSL RamTestRun
000611r 2               
000611r 2               
000611r 2               
000611r 2                   ; jsr RamTestWideRegistersRun
000611r 2                   ; jsr RamTestWideRun
000611r 2               
000611r 2                   ;shortr
000611r 2                   ;LDA #%00011100
000611r 2                   ;jsr RA8875_SetForegroundColor
000611r 2  C2 30            longr
000613r 2               
000613r 2  78 F4 rr rr      write bios_init
000617r 2  22 rr rr rr  
00061Br 2  68 58        
00061Dr 2  78 F4 rr rr      write ok_string
000621r 2  22 rr rr rr  
000625r 2  68 58        
000627r 2               
000627r 2                   ;shortr
000627r 2                   ;LDA #%11111111
000627r 2                   ;jsr RA8875_SetForegroundColor
000627r 2                   ;longr
000627r 2               
000627r 2  78 F4 rr rr      write ansi_string
00062Br 2  22 rr rr rr  
00062Fr 2  68 58        
000631r 2               
000631r 2  E2 30            shortr
000633r 2  60               RTS
000634r 2               
000634r 1               .include "kernel/kernel.asm"
000634r 2               
000634r 2               .include "tasks.asm"
000634r 3               NUMBER_OF_TASKS = 16
000634r 3               
000634r 3               TASK_STATUS_NONE = 0
000634r 3               TASK_STATUS_RUNNING = 1
000634r 3               TASK_STATUS_RUNNABLE = 2
000634r 3               TASK_STATUS_EXITED = 6          ; everything above this can be taken by a new task
000634r 3               TASK_STATUS_KILLED = 7
000634r 3               
000634r 3               TASK_EXIT_CODE_KILLED = 7
000634r 3               
000634r 3               .include "scheduler.asm"
000634r 4               ; IRQ steps
000634r 4               ; Push to the stack:
000634r 4               ;
000634r 4               ;   PB  - Program Bank           - 1 byte
000634r 4               ;   PCH - Program Counter High   - 1 byte
000634r 4               ;   PCL - Program Counter Low    - 1 byte
000634r 4               ;   SR  - Status Register        - 1 byte
000634r 4               ;
000634r 4               ; PB set to $00
000634r 4               
000634r 4               
000634r 4               ; Stacks and direct page
000634r 4               ; 0000-00FF : kernel direct page
000634r 4               ; 0100-01FF : kernel stack
000634r 4               
000634r 4               ; 9000-90FF : task 0  - direct
000634r 4               ; A000-A0FF : task 0  - stack
000634r 4               ; 9F00-9FFF : task 16 - direct
000634r 4               ; AF00-AFFF : task 16 - stack
000634r 4               
000634r 4               
000634r 4               ; NOT USED! THIS IS A TEST:
000634r 4               ; 0000-00FF : kernel direct page
000634r 4               ; 0100-01FF : kernel stack
000634r 4               ; 0200-02FF : task 1 DP
000634r 4               ; 0300-03FF : task 1 stack
000634r 4               
000634r 4               ; B000-C000 : I/O
000634r 4               InterruptStackY = 3+1
000634r 4               InterruptStackX = InterruptStackY+2
000634r 4               InterruptStackA = InterruptStackX+2
000634r 4               InterruptDP = InterruptStackA+2
000634r 4               InterruptDB = InterruptDP+2
000634r 4               InterruptStatusRegister = InterruptDB+1
000634r 4               InterruptPC = InterruptStatusRegister+1
000634r 4               InterruptPB = InterruptPC+2
000634r 4               
000634r 4               .SEGMENT "KERNEL"
00000Br 4               
00000Br 4  xx           SchedulerCount: .res 1
00000Cr 4               
00000Cr 4  xx xx        TimerCounter: .res 2
00000Er 4  xx xx        TaskSwitches: .res 2
000010r 4               
000010r 4  xx           TempStackReturnBank: .res 1
000011r 4  xx xx        TempStackReturnPC: .res 2
000013r 4               
000013r 4               .code
000634r 4               
000634r 4               
000634r 4               
000634r 4               .A8
000634r 4               .I8
000634r 4               Scheduler_NextTask:
000634r 4  78               sei
000635r 4               
000635r 4  AE rr rr         ldx ActiveTask
000638r 4               
000638r 4  BD rr rr         lda TaskStatus,x
00063Br 4  C9 01            cmp #TASK_STATUS_RUNNING
00063Dr 4  D0 4E            bne @loop
00063Fr 4               
00063Fr 4  A9 02            lda #TASK_STATUS_RUNNABLE               ; if running then set to runnable
000641r 4  9D rr rr         sta TaskStatus,x
000644r 4               
000644r 4               ; save current task stage
000644r 4                   ;longr
000644r 4                   ;write task_save_old
000644r 4                   ;write test_string
000644r 4                   ;shortr
000644r 4               
000644r 4                   ;ldx ActiveTask
000644r 4                   ;txa
000644r 4                   ;jsl RA8875_WriteHex
000644r 4                   ;lda #' '
000644r 4                   ;jsl RA8875_WriteChar
000644r 4                   ;lda #$A
000644r 4                   ;jsl RA8875_WriteChar
000644r 4                   ;lda #'o'
000644r 4                   ;jsl RA8875_WriteChar
000644r 4                   ;longr
000644r 4                   ;jsl DumpStack
000644r 4                   ;shortr
000644r 4                   ;ldx ActiveTask
000644r 4               
000644r 4  A3 0C            lda InterruptDB,s
000646r 4  9D rr rr         sta TaskDataBank,x
000649r 4               
000649r 4  A3 10            lda InterruptPB,s
00064Br 4  9D rr rr         sta TaskProgramBank,x
00064Er 4               
00064Er 4  A3 0D            lda InterruptStatusRegister,s
000650r 4  9D rr rr         sta TaskStatusRegister,x
000653r 4               
000653r 4               
000653r 4               
000653r 4                   ;ldx ActiveTask
000653r 4  8A               txa
000654r 4  0A               asl
000655r 4  AA               tax
000656r 4               
000656r 4               ; SAVE STACK POINTER
000656r 4  C2 20            longa
000658r 4  3B               tsc                                 ; A = stack pointer
000659r 4  18               clc
00065Ar 4  69 10 00         adc #InterruptPB                 ; A = stack pointer - ...
00065Dr 4  9D rr rr         sta TaskStackPointer,x
000660r 4  E2 20            shorta
000662r 4               
000662r 4                   ; lda TaskStackPointer+1,x
000662r 4                   ; jsl RA8875_WriteHex
000662r 4                   ; lda #' '
000662r 4                   ; jsl RA8875_WriteChar
000662r 4                   ; lda TaskStackPointer,x
000662r 4                   ; jsl RA8875_WriteHex
000662r 4                   ; lda #' '
000662r 4                   ; jsl RA8875_WriteChar
000662r 4               
000662r 4  A3 08            lda InterruptStackA,s
000664r 4  9D rr rr         sta TaskA,x
000667r 4  A3 09            lda InterruptStackA+1,s
000669r 4  9D rr rr         sta TaskA+1,x
00066Cr 4  A3 06            lda InterruptStackX,s
00066Er 4  9D rr rr         sta TaskX,x
000671r 4  A3 07            lda InterruptStackX+1,s
000673r 4  9D rr rr         sta TaskX+1,x
000676r 4  A3 04            lda InterruptStackY,s
000678r 4  9D rr rr         sta TaskY,x
00067Br 4  A3 05            lda InterruptStackY+1,s
00067Dr 4  9D rr rr         sta TaskY+1,x
000680r 4               
000680r 4               
000680r 4  A3 0E            lda InterruptPC,s
000682r 4  9D rr rr         sta TaskProgramPointer,x
000685r 4               
000685r 4                   ;jsl RA8875_WriteHex
000685r 4                   ;lda #' '
000685r 4                   ;jsl RA8875_WriteChar
000685r 4               
000685r 4  A3 0F            lda InterruptPC+1,s
000687r 4  9D rr rr         sta TaskProgramPointer+1,x
00068Ar 4               
00068Ar 4                   ;jsl RA8875_WriteHex
00068Ar 4                   ;lda #$A
00068Ar 4                   ;jsl RA8875_WriteChar
00068Ar 4               
00068Ar 4  AE rr rr         ldx ActiveTask
00068Dr 4               @loop:
00068Dr 4  E8               inx
00068Er 4  E0 10            cpx #NUMBER_OF_TASKS
000690r 4  D0 05            bne @fine
000692r 4  A2 FF            ldx #$FF     ; will roll to 0 on inx
000694r 4  4C rr rr         jmp @loop
000697r 4               @fine:
000697r 4               
000697r 4  BD rr rr         lda TaskStatus,x
00069Ar 4               
00069Ar 4  F0 F1            beq @loop
00069Cr 4               
00069Cr 4  C9 02            cmp #TASK_STATUS_RUNNABLE
00069Er 4  F0 1E            beq @task_switch
0006A0r 4  C9 01            cmp #TASK_STATUS_RUNNING
0006A2r 4  F0 17            beq @goreturn
0006A4r 4               
0006A4r 4  22 rr rr rr      jsl RA8875_WriteHex
0006A8r 4  8A               txa
0006A9r 4  22 rr rr rr      jsl RA8875_WriteHex
0006ADr 4  C2 30            longr
0006AFr 4  78 F4 rr rr      write task_unknown_status
0006B3r 4  22 rr rr rr  
0006B7r 4  68 58        
0006B9r 4  E2 30            shortr
0006BBr 4               @goreturn:
0006BBr 4  4C rr rr         jmp @return
0006BEr 4               
0006BEr 4               @task_switch:
0006BEr 4               
0006BEr 4               
0006BEr 4               ; SWITCH TO NEW TASK
0006BEr 4               
0006BEr 4  8E rr rr         stx ActiveTask
0006C1r 4               
0006C1r 4                ;   lda #$A
0006C1r 4                ;   jsl RA8875_WriteChar
0006C1r 4                ;   lda #'s'
0006C1r 4               ;    jsl RA8875_WriteChar
0006C1r 4               ;    longr
0006C1r 4               ;    jsl DumpStack
0006C1r 4               ;    shortr
0006C1r 4               
0006C1r 4               
0006C1r 4                   ;longr
0006C1r 4                   ;write task_switching_task
0006C1r 4                   ;shortr
0006C1r 4               
0006C1r 4                   ;ldx ActiveTask
0006C1r 4                   ;txa
0006C1r 4                   ;jsl RA8875_WriteHex
0006C1r 4                   ;lda #' '
0006C1r 4                   ;jsl RA8875_WriteChar
0006C1r 4               
0006C1r 4                   ;ldx ActiveTask
0006C1r 4               
0006C1r 4  A9 01            lda #TASK_STATUS_RUNNING               ; if running then set to runnable
0006C3r 4  9D rr rr         sta TaskStatus,x
0006C6r 4               
0006C6r 4  A3 01            lda 1,s
0006C8r 4  8D rr rr         sta TempStackReturnPC+1
0006CBr 4  A3 02            lda 2,s
0006CDr 4  8D rr rr         sta TempStackReturnPC
0006D0r 4  A3 03            lda 3,s
0006D2r 4  8D rr rr         sta TempStackReturnBank
0006D5r 4               ; Set up stack
0006D5r 4  8A               txa
0006D6r 4  0A               asl
0006D7r 4  AA               tax
0006D8r 4  C2 30            longr
0006DAr 4  BD rr rr         lda TaskStackPointer,x
0006DDr 4  18               clc
0006DEr 4  E9 10 00         sbc #InterruptPB
0006E1r 4  1B               tcs
0006E2r 4  E2 30            shortr
0006E4r 4               
0006E4r 4  AD rr rr         lda TempStackReturnPC+1
0006E7r 4  83 01            sta 1,s
0006E9r 4  AD rr rr         lda TempStackReturnPC
0006ECr 4  83 02            sta 2,s
0006EEr 4  AD rr rr         lda TempStackReturnBank
0006F1r 4  83 03            sta 3,s
0006F3r 4               
0006F3r 4  AE rr rr         ldx ActiveTask
0006F6r 4               
0006F6r 4  BD rr rr         lda TaskProgramBank,x
0006F9r 4  83 10            sta InterruptPB,s
0006FBr 4               
0006FBr 4  BD rr rr         lda TaskDataBank,x
0006FEr 4  83 0C            sta InterruptDB,s
000700r 4               
000700r 4  BD rr rr         lda TaskStatusRegister,x
000703r 4  83 0D            sta InterruptStatusRegister,s
000705r 4               
000705r 4  8A               txa
000706r 4  0A               asl
000707r 4  AA               tax
000708r 4               ; Set Direct Page to $9x00
000708r 4  AD rr rr         lda ActiveTask
00070Br 4               
00070Br 4  18               clc
00070Cr 4  69 90            adc #$90                                ; A = $9x
00070Er 4               
00070Er 4  83 0B            sta InterruptDP+1,s
000710r 4               
000710r 4               ; Set registers
000710r 4  BD rr rr         lda TaskA,x
000713r 4  83 08            sta InterruptStackA,s
000715r 4  BD rr rr         lda TaskA+1,x
000718r 4  83 09            sta InterruptStackA+1,s
00071Ar 4  BD rr rr         lda TaskY,x
00071Dr 4  83 04            sta InterruptStackY,s
00071Fr 4  BD rr rr         lda TaskY+1,x
000722r 4  83 05            sta InterruptStackY+1,s
000724r 4  BD rr rr         lda TaskX,x
000727r 4  83 06            sta InterruptStackX,s
000729r 4  BD rr rr         lda TaskX+1,x
00072Cr 4  83 07            sta InterruptStackX+1,s
00072Er 4               
00072Er 4               
00072Er 4  BD rr rr         lda TaskProgramPointer+1,x
000731r 4  83 0F            sta InterruptPC+1,s
000733r 4                   ;jsl RA8875_WriteHex
000733r 4               
000733r 4  BD rr rr         lda TaskProgramPointer,x
000736r 4  83 0E            sta InterruptPC,s
000738r 4                   ;jsl RA8875_WriteHex
000738r 4               
000738r 4                   ;lda #$A
000738r 4                   ;jsl RA8875_WriteChar
000738r 4               
000738r 4                   ;lda #'n'
000738r 4                   ;jsl RA8875_WriteChar
000738r 4                   ;longr
000738r 4                   ;jsl DumpStack
000738r 4                   ;shortr
000738r 4                   ;lda #$A
000738r 4                   ;jsl RA8875_WriteChar
000738r 4  4C rr rr         jmp @return
00073Br 4               
00073Br 4               
00073Br 4               @return:
00073Br 4               
00073Br 4               
00073Br 4  58               cli
00073Cr 4  6B               rtl
00073Dr 4               
00073Dr 4               
00073Dr 4               .A16
00073Dr 4               .I16
00073Dr 4               InitScheduler:
00073Dr 4               
00073Dr 4  9C rr rr         stz TimerCounter        ; set interrupt timer counter to 0
000740r 4  9C rr rr         stz TaskSwitches        ; set task switch count to 0
000743r 4               
000743r 4               ; should be approx 256 times per second
000743r 4  A9 A8 26         lda #9896
000746r 4  8D rr rr         sta VIA1_T1CL
000749r 4               
000749r 4  E2 30            shortr
00074Br 4  AD rr rr         lda  VIA1_ACR       ; Clear the ACR's bit that
00074Er 4  29 7F            AND  #%01111111      ; tells T1 to toggle PB7 upon time-out, and
000750r 4  09 40            ORA  #%01000000      ; set the bit that tells T1 to automatically
000752r 4  8D rr rr         STA  VIA1_ACR       ; produce an interrupt at every time-out and
000755r 4                                       ; just reload from the latches and keep going.
000755r 4  A9 C0            LDA  #%11000000
000757r 4  8D rr rr         STA  VIA1_IER       ; Enable the T1 interrupt in the VIA.
00075Ar 4               
00075Ar 4  C2 30            longr
00075Cr 4  60               rts
00075Dr 4               
00075Dr 3               .include "tasks.inc"
00075Dr 4               
00075Dr 4               .RODATA
0003DEr 4               
0003DEr 4  4E 6F 20 66  task_no_free_slot:           .asciiz "No free task slot!\n"
0003E2r 4  72 65 65 20  
0003E6r 4  74 61 73 6B  
0003F2r 4  55 6E 6B 6E  task_unknown_status:           .asciiz "Unknown task status!\n"
0003F6r 4  6F 77 6E 20  
0003FAr 4  74 61 73 6B  
000408r 4  4E 65 77 3A  task_switching_task:           .asciiz "New: "
00040Cr 4  20 00        
00040Er 4  4F 6C 64 3A  task_save_old:               .asciiz "Old: "
000412r 4  20 00        
000414r 4               
000414r 3               
000414r 3               .SEGMENT "KERNEL"
000013r 3               
000013r 3  xx           KernelSp: .res 1
000014r 3  xx           ActiveTask: .res 1
000015r 3  xx xx xx xx  TaskStatus: .res NUMBER_OF_TASKS
000019r 3  xx xx xx xx  
00001Dr 3  xx xx xx xx  
000025r 3  xx xx xx xx  TaskExitCode: .res NUMBER_OF_TASKS
000029r 3  xx xx xx xx  
00002Dr 3  xx xx xx xx  
000035r 3  xx xx xx xx  TaskStackPointer: .res NUMBER_OF_TASKS * 2
000039r 3  xx xx xx xx  
00003Dr 3  xx xx xx xx  
000055r 3  xx xx xx xx  TaskDataBank: .res NUMBER_OF_TASKS
000059r 3  xx xx xx xx  
00005Dr 3  xx xx xx xx  
000065r 3  xx xx xx xx  TaskProgramBank: .res NUMBER_OF_TASKS
000069r 3  xx xx xx xx  
00006Dr 3  xx xx xx xx  
000075r 3  xx xx xx xx  TaskProgramPointer: .res NUMBER_OF_TASKS * 2
000079r 3  xx xx xx xx  
00007Dr 3  xx xx xx xx  
000095r 3  xx xx xx xx  TaskStatusRegister: .res NUMBER_OF_TASKS
000099r 3  xx xx xx xx  
00009Dr 3  xx xx xx xx  
0000A5r 3  xx xx xx xx  TaskA: .res NUMBER_OF_TASKS * 2
0000A9r 3  xx xx xx xx  
0000ADr 3  xx xx xx xx  
0000C5r 3  xx xx xx xx  TaskX: .res NUMBER_OF_TASKS * 2
0000C9r 3  xx xx xx xx  
0000CDr 3  xx xx xx xx  
0000E5r 3  xx xx xx xx  TaskY: .res NUMBER_OF_TASKS * 2
0000E9r 3  xx xx xx xx  
0000EDr 3  xx xx xx xx  
000105r 3               
000105r 3               
000105r 3               .code
00075Dr 3               
00075Dr 3               ; Initialize tasks
00075Dr 3               .A16
00075Dr 3               .I16
00075Dr 3               InitTasks:
00075Dr 3  E2 30                shortr
00075Fr 3  A2 10                ldx #NUMBER_OF_TASKS
000761r 3                   @clrloop:
000761r 3  CA                   dex
000762r 3  9E rr rr             stz TaskStatus,x
000765r 3  9E rr rr             stz TaskExitCode,x
000768r 3  9E rr rr             stz TaskStatusRegister,x
00076Br 3  9E rr rr             stz TaskProgramBank,x
00076Er 3  9E rr rr             stz TaskDataBank,x
000771r 3  C2 30                longr
000773r 3  9E rr rr             stz TaskStackPointer, x
000776r 3  9E rr rr             stz TaskProgramPointer, x
000779r 3  9E rr rr             stz TaskA, x
00077Cr 3  9E rr rr             stz TaskX, x
00077Fr 3  9E rr rr             stz TaskY, x
000782r 3  E2 30                shortr
000784r 3  D0 DB            bne @clrloop
000786r 3               
000786r 3  A9 FF                lda #$FF
000788r 3  8D rr rr             sta ActiveTask
00078Br 3               
00078Br 3  C2 30                longr
00078Dr 3  60                   rts
00078Er 3               
00078Er 3               
00078Er 3               
00078Er 3               ; Spawn a new task
00078Er 3               TaskSpawnArg_Addr = 1+3+6      ; jsl 3 bytes return
00078Er 3               .A16
00078Er 3               .I16
00078Er 3               TaskSpawn:
00078Er 3  48                   pha
00078Fr 3  DA                   phx
000790r 3  5A                   phy
000791r 3  E2 30                shortr
000793r 3  20 rr rr             jsr TaskFindUnusedTask
000796r 3  B0 3C                bcs @no_unused_tasks
000798r 3               
000798r 3                       ;txa
000798r 3                       ;jsl RA8875_WriteHex
000798r 3               
000798r 3  9E rr rr             stz TaskExitCode,x
00079Br 3               
00079Br 3  A9 02                lda #TASK_STATUS_RUNNABLE
00079Dr 3  9D rr rr             sta TaskStatus,x
0007A0r 3               
0007A0r 3  A3 0C                lda TaskSpawnArg_Addr+2,s
0007A2r 3  9D rr rr             sta TaskProgramBank,x
0007A5r 3               
0007A5r 3  8A                   txa
0007A6r 3  A8                   tay
0007A7r 3  0A                   asl
0007A8r 3  AA                   tax
0007A9r 3  98                   tya
0007AAr 3  18                   clc
0007ABr 3  69 A0                adc #$A0
0007ADr 3  9D rr rr             sta TaskStackPointer+1,x
0007B0r 3  A9 FF                lda #$FF
0007B2r 3  9D rr rr             sta TaskStackPointer,x            ; Stack pointer: $AxFF
0007B5r 3               
0007B5r 3               
0007B5r 3  A3 0A                lda TaskSpawnArg_Addr,s
0007B7r 3  9D rr rr             sta TaskProgramPointer,x
0007BAr 3               
0007BAr 3  A3 0B                lda TaskSpawnArg_Addr+1,s
0007BCr 3  9D rr rr             sta TaskProgramPointer+1,x
0007BFr 3               
0007BFr 3               
0007BFr 3  9E rr rr             stz TaskA,x
0007C2r 3  9E rr rr             stz TaskA+1,x
0007C5r 3  9E rr rr             stz TaskY,x
0007C8r 3  9E rr rr             stz TaskY+1,x
0007CBr 3  9E rr rr             stz TaskX,x
0007CEr 3  9E rr rr             stz TaskX+1,x
0007D1r 3               
0007D1r 3               
0007D1r 3  4C rr rr             jmp @return
0007D4r 3               
0007D4r 3                   @no_unused_tasks:
0007D4r 3  C2 30                longr
0007D6r 3  78 F4 rr rr          write task_no_free_slot
0007DAr 3  22 rr rr rr  
0007DEr 3  68 58        
0007E0r 3  4C rr rr             jmp @return
0007E3r 3                   @return:
0007E3r 3  C2 30                longr
0007E5r 3  7A                   ply
0007E6r 3  FA                   plx
0007E7r 3  68                   pla
0007E8r 3  6B                   rtl
0007E9r 3               
0007E9r 3               
0007E9r 3               
0007E9r 3               ; Find task slot not used. First try to find a slot with status 0
0007E9r 3               ; if none with status 0 is found then find a exited or killed slot
0007E9r 3               ; input: n/a
0007E9r 3               ; output:
0007E9r 3               ;   x - slot number that's empty
0007E9r 3               ;   carry set if error
0007E9r 3               .A8
0007E9r 3               .I8
0007E9r 3               TaskFindUnusedTask:
0007E9r 3  18                   clc
0007EAr 3  48                   pha
0007EBr 3  A2 00                ldx #0
0007EDr 3                   @loop:
0007EDr 3  BD rr rr             lda TaskStatus,x
0007F0r 3  F0 14                beq @return
0007F2r 3  E8                   inx
0007F3r 3  E0 10                cpx #NUMBER_OF_TASKS         ; Reach end of tasks list?
0007F5r 3  D0 F6                bne @loop
0007F7r 3                   ; No slot found. Try one killed or exited
0007F7r 3  A2 00                ldx #$0
0007F9r 3                   @loop2:
0007F9r 3  BD rr rr             lda TaskStatus,x
0007FCr 3  C9 06                cmp #TASK_STATUS_EXITED
0007FEr 3  B0 06                bcs @return
000800r 3  E8                   inx
000801r 3  E0 10                cpx #NUMBER_OF_TASKS
000803r 3  D0 F4                bne @loop2
000805r 3  38                   sec                         ; reached the end the second time.
000806r 3                                                   ; no slots available. return with carry set
000806r 3                   @return:
000806r 3  68                   pla
000807r 3  60                   rts
000808r 3               
000808r 3               
000808r 3               
000808r 3               ; Mark current task as exited. Go into nop-loop until
000808r 3               ; next task is chosen by scheduler
000808r 3               ; input:
000808r 3               ;   A - exit code
000808r 3               ; output: n/a
000808r 3               .A16
000808r 3               .I16
000808r 3               TaskExit:
000808r 3  AE rr rr             ldx ActiveTask
00080Br 3               
00080Br 3  9D rr rr             sta TaskExitCode,x              ; store the exit code
00080Er 3               
00080Er 3  A9 06 00             lda #TASK_STATUS_EXITED
000811r 3  9D rr rr             sta TaskStatus,x                ; mark the task as exited
000814r 3               
000814r 3                       @loop:                          ; go into infinite loop
000814r 3  EA                       nop                         ; until scheduler picks
000815r 3  4C rr rr                 jmp @loop                   ; the next task
000818r 3               
000818r 3               
000818r 3               
000818r 3               ; exit task from outside the task itself
000818r 3               ; input:
000818r 3               ;   x - task number to kill
000818r 3               ; output: n/a
000818r 3               .A16
000818r 3               .I16
000818r 3               TaskKill:
000818r 3  A9 07 00             lda #TASK_STATUS_KILLED
00081Br 3  9D rr rr             sta TaskStatus,x
00081Er 3  9D rr rr             sta TaskExitCode,x
000821r 3               
000821r 3  6B                   rtl
000822r 3               
000822r 2               .include "interrupt.asm"
000822r 3               .code
000822r 3               .A16
000822r 3               .I16
000822r 3               InterruptVector:
000822r 3  8B               phb                   ;save DB - data bank
000823r 3  0B               phd                   ;save DP - direct page
000824r 3  C2 30            longr                 ;select 16 bit registers
000826r 3  48               pha                   ;save .C
000827r 3  DA               phx                   ;save .X
000828r 3  5A               phy                   ;save .Y
000829r 3               
000829r 3  E2 30            shortr
00082Br 3               
00082Br 3  AD rr rr         lda VIA1_IFR
00082Er 3  2D rr rr         and VIA1_IER            ; zero those that were not allowed to pull IRQ down.
000831r 3  0A               asl ; timer 1
000832r 3  30 0A            bmi  InterruptTimer1
000834r 3  0A               asl ; timer 2
000835r 3  0A               asl ; cb1
000836r 3  0A               asl ; cb2
000837r 3  0A               asl ; shift reg
000838r 3  0A               asl ; ca1
000839r 3               
000839r 3  30 2A            bmi InterruptKB
00083Br 3               
00083Br 3               
00083Br 3               
00083Br 3  4C rr rr         jmp crti
00083Er 3               
00083Er 3               InterruptTimer1:
00083Er 3  2C rr rr         bit VIA1_T1CL
000841r 3  EE rr rr         inc TimerCounter
000844r 3  D0 03            BNE @lowcnt    ; Branch to end if the low byte didn't roll over to 00.
000846r 3  EE rr rr         inc TimerCounter+1
000849r 3               @lowcnt:
000849r 3  EE rr rr         inc SchedulerCount
00084Cr 3  AD rr rr         lda SchedulerCount
00084Fr 3  C9 06            cmp #$06
000851r 3  D0 0F            bne @noschedule
000853r 3  9C rr rr         stz SchedulerCount
000856r 3  EE rr rr         inc TaskSwitches
000859r 3  D0 03            BNE @lowcntSwitch    ; Branch to end if the low byte didn't roll over to 00.
00085Br 3  EE rr rr         inc TaskSwitches+1
00085Er 3               @lowcntSwitch:
00085Er 3  22 rr rr rr      jsl Scheduler_NextTask
000862r 3               @noschedule:
000862r 3               
000862r 3  4C rr rr         jmp crti
000865r 3               
000865r 3               InterruptKB:
000865r 3  20 rr rr         jsr InterruptKeyboard
000868r 3               
000868r 3               crti:
000868r 3  C2 30            longr
00086Ar 3  7A               ply                   ;restore .Y
00086Br 3  FA               plx                   ;restore .X
00086Cr 3  68               pla                   ;restore .C
00086Dr 3  2B               pld                   ;restore DP
00086Er 3  AB               plb                   ;restore DB
00086Fr 3  40               rti                   ;resume foreground task
000870r 3               
000870r 2               .include "streams.asm"
000870r 3               
000870r 3               NUMBER_OF_STREAMS = 3           ; Number of streams
000870r 3               SIZE_OF_STREAM = 16             ; Number of bytes per stream
000870r 3               
000870r 3               STREAM_STDIN = 0
000870r 3               
000870r 3               .SEGMENT "KERNEL"
000105r 3               
000105r 3               StreamLookupHead:
000105r 3  xx xx xx         .res NUMBER_OF_STREAMS
000108r 3               StreamLookupTail:
000108r 3  xx xx xx         .res NUMBER_OF_STREAMS
00010Br 3               StreamData:
00010Br 3  xx xx xx xx      .res SIZE_OF_STREAM * NUMBER_OF_STREAMS
00010Fr 3  xx xx xx xx  
000113r 3  xx xx xx xx  
00013Br 3               
00013Br 3               .code
000870r 3               
000870r 3               ; Initialize streams
000870r 3               ; Zeroes out head, tail, data
000870r 3               .A16
000870r 3               .I16
000870r 3               InitStreams:
000870r 3  E2 30            shortr
000872r 3  A2 03            ldx #NUMBER_OF_STREAMS
000874r 3               @clrloop:
000874r 3  CA               dex
000875r 3  9E rr rr         stz StreamLookupHead, x
000878r 3  9E rr rr         stz StreamLookupTail, x
00087Br 3               
00087Br 3  D0 F7            bne @clrloop
00087Dr 3  A2 10            ldx #SIZE_OF_STREAM
00087Fr 3               @clrloop2:
00087Fr 3  CA               dex
000880r 3  9E rr rr         stz StreamData, x
000883r 3  9E rr rr         stz StreamData+SIZE_OF_STREAM, x
000886r 3  9E rr rr         stz StreamData+SIZE_OF_STREAM+SIZE_OF_STREAM, x
000889r 3               
000889r 3               
000889r 3  D0 F4            bne @clrloop2
00088Br 3               
00088Br 3  C2 30            longr
00088Dr 3  60               rts
00088Er 3               
00088Er 3               ; Put byte to stream
00088Er 3               ; in:
00088Er 3               ;   A - byte to put
00088Er 3               ;   X - stream id
00088Er 3               ; out:
00088Er 3               .A8
00088Er 3               .I8
00088Er 3               StreamPutC:
00088Er 3  48               pha
00088Fr 3  78               sei
000890r 3  BC rr rr         ldy StreamLookupTail,x      ; fetch current tail
000893r 3  5A               phy                         ; stack: [tail]
000894r 3               
000894r 3  BC rr rr         ldy StreamLookupHead,x      ; fetch current head
000897r 3  5A               phy                         ; stack: [tail, head]
000898r 3               
000898r 3  DA               phx                         ; stack: [tail, head, stream id]
000899r 3  48               pha                         ; stack: [tail, head, stream id, A-byte]
00089Ar 3  8A               txa
00089Br 3               
00089Br 3  0A               asl                         ; *  2
00089Cr 3  0A               asl                         ; *  4
00089Dr 3  0A               asl                         ; *  8
00089Er 3  0A               asl                         ; * 16
00089Fr 3  63 03            adc 3,s                     ; + head_offset
0008A1r 3  AA               tax                         ; X = X * 16 + head_offset
0008A2r 3               
0008A2r 3  68               pla                         ; stack: [tail, head, stream id], a = A-byte
0008A3r 3               
0008A3r 3  9D rr rr         sta StreamData,x            ; Store byte in stream
0008A6r 3               
0008A6r 3               ; increment head_offset
0008A6r 3  FA               plx                         ; stack: [tail, head], x=stream id
0008A7r 3  7A               ply                         ; stack: [tail], y = head
0008A8r 3  C8               iny                         ; increment head
0008A9r 3  98               tya
0008AAr 3               
0008AAr 3  C9 10            cmp #SIZE_OF_STREAM         ; head overflow?
0008ACr 3  D0 02            bne @checktail
0008AEr 3  A9 00            lda #0
0008B0r 3               @checktail:
0008B0r 3  9D rr rr         sta StreamLookupHead,x      ; store head
0008B3r 3               
0008B3r 3               ; this is untested.
0008B3r 3               ; if the stream wraps around
0008B3r 3  C3 01            cmp 1,s                     ; is head == stack[1]/tail?
0008B5r 3  D0 09            bne @tailnothead
0008B7r 3  7A               ply                         ; if yes increment tail
0008B8r 3  C8               iny
0008B9r 3  98               tya
0008BAr 3  9D rr rr         sta StreamLookupTail,x
0008BDr 3  4C rr rr         jmp @done
0008C0r 3               
0008C0r 3               
0008C0r 3               @tailnothead:
0008C0r 3  FA               plx ; clear tail from stack. not used pt
0008C1r 3               @done:
0008C1r 3  58               cli
0008C2r 3  68               pla
0008C3r 3  6B               rtl
0008C4r 3               
0008C4r 3               ; Get byte from stream
0008C4r 3               ; in:
0008C4r 3               ;   X - stream id
0008C4r 3               ; out:
0008C4r 3               ;   A: read byte
0008C4r 3               ;       0: nothing
0008C4r 3               ;       x: read byte
0008C4r 3               .A8
0008C4r 3               .I8
0008C4r 3               StreamGetC:
0008C4r 3  78               sei
0008C5r 3  BD rr rr         lda StreamLookupTail,x
0008C8r 3  DD rr rr         cmp StreamLookupHead,x
0008CBr 3  D0 05            bne @readc                  ; tail !== head
0008CDr 3  A9 00            lda #0                      ; set A to 0 (nothing read)
0008CFr 3  4C rr rr         jmp @done
0008D2r 3               @readc:
0008D2r 3               
0008D2r 3  48               pha                         ; s:[tail]
0008D3r 3  18               clc
0008D4r 3  69 01            adc #1                      ; tail = tail + 1
0008D6r 3  C9 10            cmp #SIZE_OF_STREAM         ; tail === 16?
0008D8r 3  D0 02            bne @savetail               ; if not skip next
0008DAr 3  A9 00            lda #0                      ; tail = 0
0008DCr 3               @savetail:
0008DCr 3  9D rr rr         sta StreamLookupTail,x      ; save tail
0008DFr 3               
0008DFr 3  8A               txa
0008E0r 3               
0008E0r 3  0A               asl                         ; *  2
0008E1r 3  0A               asl                         ; *  4
0008E2r 3  0A               asl                         ; *  8
0008E3r 3  0A               asl                         ; * 16
0008E4r 3  63 01            adc 1,s                     ; + tail_offset
0008E6r 3  AA               tax                         ; X = X * 16 + tail_offset
0008E7r 3  7A               ply                         ; s:[]
0008E8r 3               
0008E8r 3  BD rr rr         lda StreamData,x
0008EBr 3               
0008EBr 3               @done:
0008EBr 3  58               cli
0008ECr 3  6B               rtl
0008EDr 3               
0008EDr 2               .include "syscalls.asm"
0008EDr 3               .I8
0008EDr 3               .A8
0008EDr 3               Sys_GetPID:
0008EDr 3  AD rr rr         LDA ActiveTask
0008F0r 3  6B               RTL
0008F1r 3               
0008F1r 2               
0008F1r 2               .A16
0008F1r 2               .I16
0008F1r 2               InitKernel:
0008F1r 2  20 rr rr         jsr InitTasks
0008F4r 2                   ;write init_kernel_tasks_done
0008F4r 2  20 rr rr         jsr InitScheduler
0008F7r 2                   ;write init_kernel_scheduler_done
0008F7r 2  20 rr rr         jsr InitStreams
0008FAr 2                   ;write init_kernel_streams_done
0008FAr 2                   ;write init_kernel_done
0008FAr 2  60               rts
0008FBr 2               ;;;
0008FBr 2               ; Long Delay
0008FBr 2               ;;;
0008FBr 2               
0008FBr 2               .A8
0008FBr 2               .I8
0008FBr 2               LongDelay:
0008FBr 2  A2 FF            ldx #$FF
0008FDr 2               LongDelayLoop1:
0008FDr 2  A0 FF            ldy #$FF
0008FFr 2               LongDelayLoop2:
0008FFr 2  88               dey
000900r 2  D0 FD            bne LongDelayLoop2
000902r 2  CA               dex
000903r 2  D0 F8            bne LongDelayLoop1
000905r 2  60               rts
000906r 2               
000906r 2               ;;;
000906r 2               ; Delay
000906r 2               ;;;
000906r 2               .A8
000906r 2               .I8
000906r 2               Delay:
000906r 2  A2 FF            ldx #$FF
000908r 2               DelayLoop1:
000908r 2  A0 FF            ldy #$FF
00090Ar 2               DelayLoop2:
00090Ar 2  88               dey
00090Br 2  D0 FD            bne DelayLoop2
00090Dr 2  CA               dex
00090Er 2  D0 F8            bne DelayLoop1
000910r 2  60               rts
000911r 2               
000911r 2               ;;;
000911r 2               ; Short Delay
000911r 2               ;;;
000911r 2               .A8
000911r 2               .I8
000911r 2  A2 AA        DelayShort:	ldx #$aa
000913r 2               DelayShortLoop1:
000913r 2  CA           	dex
000914r 2  D0 FD            bne DelayShortLoop1
000916r 2  60               rts
000917r 2               
000917r 1               
000917r 1               
000917r 1               .include "stdlib/stdlib.asm"
000917r 2               .include "stdlib.inc"
000917r 3               Std_StrLen = 1
000917r 3               Std_ReadNum = 2
000917r 3               Std_StrCompareUntilWhiteSpace = 3
000917r 3               
000917r 2               
000917r 2               .SEGMENT "STDLIB"
000000r 2               
000000r 2               StdLib:
000000r 2  C2 30            longr
000002r 2  48               pha
000003r 2  DA               phx
000004r 2  5A               phy
000005r 2               
000005r 2  29 FF 00         and #$00FF
000008r 2  3A               dec a                           ; 0 index function number
000009r 2  0A               asl a                           ; double function number to match words
00000Ar 2               
00000Ar 2  E2 30            shortr
00000Cr 2  AA               tax
00000Dr 2               
00000Dr 2  7C rr rr         jmp (StdLibTable,x)
000010r 2               
000010r 2               
000010r 2               StdLibTable:
000010r 2  rr rr            .word Stdlib_StrLen
000012r 2  rr rr            .word Stdlib_ReadNum
000014r 2  rr rr            .word StdLib_StrCompareUntilWhiteSpace
000016r 2               
000016r 2               
000016r 2               .include "strings.asm"
000016r 3               .RODATA
000414r 3  53 74 72 4C  	strlen: .asciiz "StrLen Called\n"
000418r 3  65 6E 20 43  
00041Cr 3  61 6C 6C 65  
000423r 3  52 65 61 64  	readnum: .asciiz "ReadNum Called\n"
000427r 3  4E 75 6D 20  
00042Br 3  43 61 6C 6C  
000433r 3               
000433r 3               .SEGMENT "STDLIB"
000016r 3               
000016r 3               
000016r 3               ;	STRING LENGTH
000016r 3               ; 		Return lenght of zero terminated string in A
000016r 3               ;	Input:
000016r 3               ;		stack: 2 bytes string address (0 terminated)
000016r 3               ;	Output:
000016r 3               ;		A: length of the string
000016r 3               Stdlib_StrLen:
000016r 3  18           		clc
000017r 3               
000017r 3  E2 30        		shortr
000019r 3               
000019r 3  A0 00        		ldy #0
00001Br 3               	@next:
00001Br 3  B3 0A        		lda (args_start,s),y
00001Dr 3  F0 04        		beq @result
00001Fr 3  C8           		iny
000020r 3  4C rr rr     		jmp @next
000023r 3               	@result:
000023r 3  98           		tya
000024r 3  83 05        		sta reg_a, s
000026r 3               
000026r 3               	;	shortr
000026r 3               	;	write strlen
000026r 3               
000026r 3  C2 30        		longr
000028r 3               
000028r 3  7A           		ply
000029r 3  FA           		plx
00002Ar 3  68           		pla
00002Br 3               
00002Br 3  6B           		rtl
00002Cr 3               
00002Cr 3               
00002Cr 3               
00002Cr 3               
00002Cr 3               ;	READ NUMBER
00002Cr 3               ; 		Return the decimal number read from string input
00002Cr 3               Stdlib_ReadNum_StackSize = 6
00002Cr 3               Stdlib_ReadNum_SingleDigit = 1
00002Cr 3               Stdlib_ReadNum_Result = Stdlib_ReadNum_SingleDigit + 2
00002Cr 3               Stdlib_ReadNum_LoopCounter = Stdlib_ReadNum_Result + 2
00002Cr 3               Stdlib_ReadNum:
00002Cr 3  C2 30        		longr
00002Er 3  A2 00 00     		ldx #0
000031r 3  A0 00 00     		ldy #0
000034r 3  5A           		phy
000035r 3  5A           		phy
000036r 3  5A           		phy
000037r 3               	@next:
000037r 3  E2 30        		shortr
000039r 3  B3 10        		lda (args_start+Stdlib_ReadNum_StackSize,s),y
00003Br 3  C2 30        		longr
00003Dr 3  C9 30 00     		cmp #$30
000040r 3  90 09        		bcc @numend						; less than $30
000042r 3  C9 40 00     		cmp #$40
000045r 3  B0 04        		bcs @numend						; more than $39
000047r 3  C8           		iny
000048r 3  4C rr rr     		jmp @next
00004Br 3               	@numend:
00004Br 3  98           		tya
00004Cr 3  F0 1F        		beq @done						; did we read 0 numbers? then end
00004Er 3  88           		dey								; subtract 1 for the last number
00004Fr 3  E2 30        		shortr
000051r 3  B3 10        		lda (args_start+Stdlib_ReadNum_StackSize,s),y
000053r 3  C2 30        		longr
000055r 3  18           		clc
000056r 3  E9 2F 00     		sbc #$2F
000059r 3  83 01        		sta Stdlib_ReadNum_SingleDigit,s
00005Br 3               
00005Br 3  A3 05        		lda Stdlib_ReadNum_LoopCounter,s ; how many times to multiply 10?
00005Dr 3  AA           		tax								; save in loop counter X
00005Er 3               	@mulloop:
00005Er 3  8A           		txa								; look at loop counter X
00005Fr 3  F0 18        		beq @donemul					; if 0 then skip multiply 10
000061r 3  A3 01        		lda Stdlib_ReadNum_SingleDigit,s
000063r 3               
000063r 3  22 rr rr rr  		jsl MulTen
000067r 3  83 01        		sta Stdlib_ReadNum_SingleDigit,s
000069r 3               
000069r 3  CA           		dex								; derement loop counter X
00006Ar 3  4C rr rr     		jmp @mulloop
00006Dr 3               
00006Dr 3               	@done:
00006Dr 3  A3 03        		lda Stdlib_ReadNum_Result,s
00006Fr 3  83 0B        		sta reg_a+Stdlib_ReadNum_StackSize, s
000071r 3               
000071r 3  18           		clc
000072r 3               
000072r 3  7A           		ply ; clear temp stack
000073r 3  7A           		ply ; clear temp stack
000074r 3  7A           		ply ; clear temp stack
000075r 3               
000075r 3  7A           		ply
000076r 3  FA           		plx
000077r 3  68           		pla
000078r 3               
000078r 3               
000078r 3  6B           		rtl
000079r 3               
000079r 3               
000079r 3               	@donemul:
000079r 3               
000079r 3  A3 01        		lda Stdlib_ReadNum_SingleDigit,s
00007Br 3  18           		clc
00007Cr 3  63 03        		adc Stdlib_ReadNum_Result,s
00007Er 3  83 03        		sta Stdlib_ReadNum_Result,s
000080r 3               
000080r 3  A3 05        		lda Stdlib_ReadNum_LoopCounter,s
000082r 3  18           		clc
000083r 3  69 01 00     		adc #1								; add one time multiply with 10
000086r 3  83 05        		sta Stdlib_ReadNum_LoopCounter,s
000088r 3  4C rr rr     		jmp @numend
00008Br 3               
00008Br 3               
00008Br 3               MulTen:
00008Br 3  5A           		phy
00008Cr 3  0A           		asl						;   *  2
00008Dr 3  48           		pha
00008Er 3  0A           		asl						;   *  4
00008Fr 3  0A           		asl		               	;   *  8
000090r 3  18           		clc
000091r 3  63 01        		adc 1,s               	;   + (*2)
000093r 3  7A           		ply
000094r 3  7A           		ply
000095r 3  6B           		rtl
000096r 3               
000096r 3               
000096r 3               
000096r 3               ; Compare the first token of string1 (delimited by whitespace) against string2
000096r 3               ; in:
000096r 3               ;    string1  - string tokenized by space
000096r 3               ;    string2  - string to compare first token of string1 against
000096r 3               ; example:
000096r 3               ;    first:  time test\0
000096r 3               ;    second: time\0
000096r 3               ;    This is a match
000096r 3               ; out:
000096r 3               ;   carry set if no match
000096r 3               ;	carry clear if match
000096r 3               StdLib_StrCompareUntilWhiteSpace_Arg_String2 = args_start
000096r 3               StdLib_StrCompareUntilWhiteSpace_Arg_String1 = args_start + 2
000096r 3               StdLib_StrCompareUntilWhiteSpace:
000096r 3  18           		clc
000097r 3  A0 00 00     		ldy #$00
00009Ar 3               	@strcmp_token_load:
00009Ar 3  B3 0C        		lda (StdLib_StrCompareUntilWhiteSpace_Arg_String1,s), Y
00009Cr 3  C9 20 00     		cmp #$20                                ; is whitespace?
00009Fr 3  F0 0D        		beq @strcmp_token_is_second_done		; yes then check if string2 is done
0000A1r 3  D3 0A        		cmp (StdLib_StrCompareUntilWhiteSpace_Arg_String2,s), Y
0000A3r 3  D0 13        		bne @strcmp_token_notequal				; is it equal to string2?
0000A5r 3  C8           		INY
0000A6r 3  C9 00 00     		CMP #0
0000A9r 3  D0 EF        		BNE @strcmp_token_load
0000ABr 3  4C rr rr     		jmp @return
0000AEr 3               
0000AEr 3               	@strcmp_token_is_second_done:
0000AEr 3  B3 0A        		lda (StdLib_StrCompareUntilWhiteSpace_Arg_String2,s), Y
0000B0r 3  C9 00 00     		cmp #0									; is string2 done?
0000B3r 3  F0 04        		beq @return								; yes then return match
0000B5r 3  4C rr rr     		jmp @strcmp_token_notequal				; no then return no match
0000B8r 3               	@strcmp_token_notequal:
0000B8r 3  38           		sec
0000B9r 3               	@return:
0000B9r 3  7A           		ply
0000BAr 3  FA           		plx
0000BBr 3  68           		pla
0000BCr 3  6B           		rtl
0000BDr 3               
0000BDr 2               
0000BDr 2               
0000BDr 2               ;    register stack frame...
0000BDr 2               ;
0000BDr 2               reg_y       =1                    ;16 bit .Y
0000BDr 2               reg_x       =reg_y+2              ;16 bit .X
0000BDr 2               reg_a       =reg_x+2              ;16 bit .A
0000BDr 2               reg_rtl     =reg_a+2              ;24 bit RTL address
0000BDr 2               
0000BDr 2               args_start  =reg_rtl+3
0000BDr 2               
0000BDr 2               ; ARGS      $10 args_start
0000BDr 2               ; RTS___    $07 reg_rts
0000BDr 2               ; AAAA      $05 reg_a
0000BDr 2               ; XXXX      $03 reg_x
0000BDr 2               ; YYYY      $01 reg_y
0000BDr 2               ;           current StackPointer
0000BDr 2               
0000BDr 1               
0000BDr 1               .include "programs/programs.inc"
0000BDr 2               
0000BDr 2               .include "shell.asm"
0000BDr 3               ; DIRECT PAGE LAYOUT
0000BDr 3               ; $00 - $7F   : Input Buffer
0000BDr 3               ; $80         : Input Buffer Index
0000BDr 3               
0000BDr 3               Shell_InputBufferStart = $00
0000BDr 3               Shell_InputBufferIndex = $80
0000BDr 3               
0000BDr 3               ShellExec:
0000BDr 3  E2 30                shortr
0000BFr 3                   @restart:
0000BFr 3  64 80                stz Shell_InputBufferIndex      ; reset input buffer
0000C1r 3  64 00                stz Shell_InputBufferStart      ; start buffer with 0-termination
0000C3r 3               
0000C3r 3  A9 3E                lda #'>'
0000C5r 3  22 rr rr rr          jsl RA8875_WriteChar
0000C9r 3  A9 20                lda #' '
0000CBr 3  22 rr rr rr          jsl RA8875_WriteChar
0000CFr 3               
0000CFr 3               
0000CFr 3                   @loop:
0000CFr 3  A6 00                ldx STREAM_STDIN                ; TODO: Get stream from Task Context (not hardcoded stdin)
0000D1r 3  22 rr rr rr          jsl StreamGetC
0000D5r 3  F0 F8                beq @loop                       ; Noting in stream (carry set)
0000D7r 3               
0000D7r 3  22 rr rr rr          jsl RA8875_WriteChar            ; Write to RA8875       - todo: write to stream (from task context) - stdout
0000DBr 3               
0000DBr 3  C5 0A                cmp $0A                         ; Is it LINE FEED?
0000DDr 3  F0 13                beq @execute                    ; yes - then execute input buffer
0000DFr 3               
0000DFr 3                       ; store in input buffer
0000DFr 3  A6 80                ldx Shell_InputBufferIndex
0000E1r 3  95 00                sta Shell_InputBufferStart,x
0000E3r 3  E8                   inx
0000E4r 3  C9 80                cmp #Shell_InputBufferIndex     ; compare to #128
0000E6r 3  D0 02                bne @cnt                        ; if not overflow then continue
0000E8r 3  64 80                stz Shell_InputBufferIndex
0000EAr 3               
0000EAr 3                   @cnt:
0000EAr 3  74 00                stz Shell_InputBufferStart,x    ; 0-terminate the end of the input buffer
0000ECr 3               
0000ECr 3  4C rr rr             jmp @loop
0000EFr 3               
0000EFr 3  C2 30                longr
0000F1r 3  60                   rts
0000F2r 3               
0000F2r 3                   @execute:
0000F2r 3               ; TODO: EXECUTE string in input buffer
0000F2r 3               
0000F2r 3                       ;lda #00                         ; put start of input buffer on stack
0000F2r 3                       ;pha
0000F2r 3                       ;pha
0000F2r 3               
0000F2r 3  4C rr rr             jmp @restart
0000F5r 3               
0000F5r 2               .include "clock.asm"
0000F5r 3               
0000F5r 3               .SEGMENT "RAM"
000002r 3               
000002r 3  xx xx        ClockCounter: .res 2
000004r 3               
000004r 3               .code
000917r 3               .A16
000917r 3               .I16
000917r 3               ClockExec:
000917r 3  E2 30            shortr
000919r 3  A9 00            lda #$0
00091Br 3  85 00            sta $0
00091Dr 3               @loop:
00091Dr 3  EE rr rr         inc ClockCounter
000920r 3  D0 03            BNE @lowonly    ; Branch to end if the low byte didn't roll over to 00.
000922r 3  EE rr rr         inc ClockCounter+1
000925r 3                   @lowonly:
000925r 3               
000925r 3               
000925r 3  4C rr rr         jmp @loop
000928r 3               
000928r 3  C2 30            longr
00092Ar 3  60               rts
00092Br 3               
00092Br 2               .include "diodeblink.asm"
00092Br 3               .RODATA
000433r 3               
000433r 3  0D 28 2A 2D  running_diode_0: .asciiz "\r(*------)"
000437r 3  2D 2D 2D 2D  
00043Br 3  2D 29 00     
00043Er 3  0D 28 2D 2A  running_diode_1: .asciiz "\r(-*-----)"
000442r 3  2D 2D 2D 2D  
000446r 3  2D 29 00     
000449r 3  0D 28 2D 2D  running_diode_2: .asciiz "\r(--*----)"
00044Dr 3  2A 2D 2D 2D  
000451r 3  2D 29 00     
000454r 3  0D 28 2D 2D  running_diode_3: .asciiz "\r(---*---)"
000458r 3  2D 2A 2D 2D  
00045Cr 3  2D 29 00     
00045Fr 3  0D 28 2D 2D  running_diode_4: .asciiz "\r(----*--)"
000463r 3  2D 2D 2A 2D  
000467r 3  2D 29 00     
00046Ar 3  0D 28 2D 2D  running_diode_5: .asciiz "\r(-----*-)"
00046Er 3  2D 2D 2D 2A  
000472r 3  2D 29 00     
000475r 3  0D 28 2D 2D  running_diode_6: .asciiz "\r(------*)"
000479r 3  2D 2D 2D 2D  
00047Dr 3  2A 29 00     
000480r 3               
000480r 3               .code
00092Br 3               .A16
00092Br 3               .I16
00092Br 3               LoaderExec:
00092Br 3  A9 0A 00         lda #$0A
00092Er 3  22 rr rr rr      jsl RA8875_WriteChar16          ; write new line
000932r 3  E2 30        shortr
000934r 3  22 rr rr rr      jsl Sys_GetPID
000938r 3  C2 30        longr
00093Ar 3  0A               asl
00093Br 3  0A               asl
00093Cr 3  0A               asl
00093Dr 3  0A               asl
00093Er 3  18               clc
00093Fr 3  69 D0 00         adc #(16*13)
000942r 3  85 00            sta $00
000944r 3               
000944r 3               
000944r 3  A5 00            lda $00
000946r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
00094Ar 3               
00094Ar 3  22 rr rr rr      jsl RA8875_WriteHex16
00094Er 3               
00094Er 3  A9 0A 00         lda #$0A
000951r 3  22 rr rr rr      jsl RA8875_WriteChar16          ; write new line
000955r 3               LoaderLoop:
000955r 3               
000955r 3  A5 00            lda $00
000957r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
00095Br 3  78 F4 rr rr      write running_diode_0
00095Fr 3  22 rr rr rr  
000963r 3  68 58        
000965r 3  20 rr rr         jsr LongDelayLoaderExec
000968r 3               
000968r 3  A5 00            lda $00
00096Ar 3  22 rr rr rr      jsl RA8875_SetTextCursorY
00096Er 3  78 F4 rr rr      write running_diode_1
000972r 3  22 rr rr rr  
000976r 3  68 58        
000978r 3  20 rr rr         jsr LongDelayLoaderExec
00097Br 3               
00097Br 3  A5 00            lda $00
00097Dr 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000981r 3  78 F4 rr rr      write running_diode_2
000985r 3  22 rr rr rr  
000989r 3  68 58        
00098Br 3  20 rr rr         jsr LongDelayLoaderExec
00098Er 3               
00098Er 3  A5 00            lda $00
000990r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000994r 3  78 F4 rr rr      write running_diode_3
000998r 3  22 rr rr rr  
00099Cr 3  68 58        
00099Er 3  20 rr rr         jsr LongDelayLoaderExec
0009A1r 3               
0009A1r 3  A5 00            lda $00
0009A3r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009A7r 3  78 F4 rr rr      write running_diode_4
0009ABr 3  22 rr rr rr  
0009AFr 3  68 58        
0009B1r 3  20 rr rr         jsr LongDelayLoaderExec
0009B4r 3               
0009B4r 3  A5 00            lda $00
0009B6r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009BAr 3  78 F4 rr rr      write running_diode_5
0009BEr 3  22 rr rr rr  
0009C2r 3  68 58        
0009C4r 3  20 rr rr         jsr LongDelayLoaderExec
0009C7r 3               
0009C7r 3  A5 00            lda $00
0009C9r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009CDr 3  78 F4 rr rr      write running_diode_6
0009D1r 3  22 rr rr rr  
0009D5r 3  68 58        
0009D7r 3  20 rr rr         jsr LongDelayLoaderExec
0009DAr 3               
0009DAr 3  A5 00            lda $00
0009DCr 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009E0r 3  78 F4 rr rr      write running_diode_5
0009E4r 3  22 rr rr rr  
0009E8r 3  68 58        
0009EAr 3  20 rr rr         jsr LongDelayLoaderExec
0009EDr 3               
0009EDr 3  A5 00            lda $00
0009EFr 3  22 rr rr rr      jsl RA8875_SetTextCursorY
0009F3r 3  78 F4 rr rr      write running_diode_4
0009F7r 3  22 rr rr rr  
0009FBr 3  68 58        
0009FDr 3  20 rr rr         jsr LongDelayLoaderExec
000A00r 3               
000A00r 3  A5 00            lda $00
000A02r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000A06r 3  78 F4 rr rr      write running_diode_3
000A0Ar 3  22 rr rr rr  
000A0Er 3  68 58        
000A10r 3  20 rr rr         jsr LongDelayLoaderExec
000A13r 3               
000A13r 3  A5 00            lda $00
000A15r 3  22 rr rr rr      jsl RA8875_SetTextCursorY
000A19r 3  78 F4 rr rr      write running_diode_2
000A1Dr 3  22 rr rr rr  
000A21r 3  68 58        
000A23r 3  20 rr rr         jsr LongDelayLoaderExec
000A26r 3  78 F4 rr rr      write running_diode_1
000A2Ar 3  22 rr rr rr  
000A2Er 3  68 58        
000A30r 3  20 rr rr         jsr LongDelayLoaderExec
000A33r 3               
000A33r 3  5C rr rr rr      JML LoaderLoop
000A37r 3               
000A37r 3               LongDelayLoaderExec:
000A37r 3  E2 30            shortr
000A39r 3  20 rr rr         jsr LogDelayLoader
000A3Cr 3  20 rr rr         jsr LogDelayLoader
000A3Fr 3  20 rr rr         jsr LogDelayLoader
000A42r 3  C2 30            longr
000A44r 3  60               rts
000A45r 3               
000A45r 3               .A8
000A45r 3               .I8
000A45r 3               LogDelayLoader:
000A45r 3  A2 FF            ldx #$FF
000A47r 3               LogDelayLoaderLoop1:
000A47r 3  A0 FF            ldy #$FF
000A49r 3               LogDelayLoaderLoop2:
000A49r 3  88               dey
000A4Ar 3  D0 FD            bne LogDelayLoaderLoop2
000A4Cr 3  CA               dex
000A4Dr 3  D0 F8            bne LogDelayLoaderLoop1
000A4Fr 3  60               rts
000A50r 3               
000A50r 2               .include "taskprinter.asm"
000A50r 3               .code
000A50r 3               
000A50r 3               TaskPrinterExec:
000A50r 3  E2 30        shortr
000A52r 3  22 rr rr rr      jsl Sys_GetPID
000A56r 3  85 00            sta $00
000A58r 3               
000A58r 3               @loop:
000A58r 3               
000A58r 3  A5 00            lda $00
000A5Ar 3  22 rr rr rr      jsl RA8875_WriteHex
000A5Er 3  20 rr rr         jsr LongDelayTaskPrinterExec
000A61r 3               
000A61r 3  5C rr rr rr      JML @loop
000A65r 3               
000A65r 3               LongDelayTaskPrinterExec:
000A65r 3  20 rr rr         jsr LogDelayTaskPrinter
000A68r 3  20 rr rr         jsr LogDelayTaskPrinter
000A6Br 3  20 rr rr         jsr LogDelayTaskPrinter
000A6Er 3  60               rts
000A6Fr 3               
000A6Fr 3               .A8
000A6Fr 3               .I8
000A6Fr 3               LogDelayTaskPrinter:
000A6Fr 3  A2 FF            ldx #$FF
000A71r 3               LogDelayTaskPrinterLoop1:
000A71r 3  A0 FF            ldy #$FF
000A73r 3               LogDelayTaskPrinterLoop2:
000A73r 3  88               dey
000A74r 3  D0 FD            bne LogDelayTaskPrinterLoop2
000A76r 3  CA               dex
000A77r 3  D0 F8            bne LogDelayTaskPrinterLoop1
000A79r 3  60               rts
000A7Ar 3               
000A7Ar 2               .include "dump.asm"
000A7Ar 3               DumpExec:
000A7Ar 3  20 rr rr         jsr RA8875_WriteHex
000A7Dr 3  60               rts
000A7Er 3               
000A7Er 2               .include "dumpstack.asm"
000A7Er 3               .I16
000A7Er 3               .A16
000A7Er 3               DumpStack:
000A7Er 3  E2 30            shortr
000A80r 3                 ;  lda 1,s           ;get mode
000A80r 3                 ;  jsl RA8875_WriteHex
000A80r 3                 ;  lda 2,s           ;get mode
000A80r 3                 ;  jsl RA8875_WriteHex
000A80r 3               
000A80r 3                 ;  lda #' '
000A80r 3                 ;  jsl RA8875_WriteChar
000A80r 3               
000A80r 3                   ;lda #$A
000A80r 3                   ;jsl RA8875_WriteChar
000A80r 3               
000A80r 3  C2 30            longr
000A82r 3  3B               tsc
000A83r 3  18               clc
000A84r 3  69 04 00         adc #4
000A87r 3  22 rr rr rr      jsl RA8875_WriteHex16
000A8Br 3  E2 30            shortr
000A8Dr 3  A9 20            lda #' '
000A8Fr 3  22 rr rr rr      jsl RA8875_WriteChar
000A93r 3               
000A93r 3  C2 30            longr
000A95r 3  3B               tsc
000A96r 3  18               clc
000A97r 3  69 06 00         adc #6
000A9Ar 3  22 rr rr rr      jsl RA8875_WriteHex16
000A9Er 3  E2 30            shortr
000AA0r 3  A9 20            lda #' '
000AA2r 3  22 rr rr rr      jsl RA8875_WriteChar
000AA6r 3               
000AA6r 3  C2 30            longr
000AA8r 3  3B               tsc
000AA9r 3  18               clc
000AAAr 3  69 08 00         adc #8
000AADr 3  22 rr rr rr      jsl RA8875_WriteHex16
000AB1r 3  E2 30            shortr
000AB3r 3  A9 20            lda #' '
000AB5r 3  22 rr rr rr      jsl RA8875_WriteChar
000AB9r 3               
000AB9r 3               
000AB9r 3  C2 30            longr
000ABBr 3  3B               tsc
000ABCr 3  18               clc
000ABDr 3  69 0A 00         adc #10
000AC0r 3  22 rr rr rr      jsl RA8875_WriteHex16
000AC4r 3  E2 30            shortr
000AC6r 3  A9 20            lda #' '
000AC8r 3  22 rr rr rr      jsl RA8875_WriteChar
000ACCr 3               
000ACCr 3               
000ACCr 3               
000ACCr 3  C2 30            longr
000ACEr 3  3B               tsc
000ACFr 3  18               clc
000AD0r 3  69 0C 00         adc #12
000AD3r 3  22 rr rr rr      jsl RA8875_WriteHex16
000AD7r 3  E2 30            shortr
000AD9r 3  A9 20            lda #' '
000ADBr 3  22 rr rr rr      jsl RA8875_WriteChar
000ADFr 3  C2 30            longr
000AE1r 3  3B               tsc
000AE2r 3  18               clc
000AE3r 3  69 0E 00         adc #14
000AE6r 3  22 rr rr rr      jsl RA8875_WriteHex16
000AEAr 3  E2 30            shortr
000AECr 3  A9 20            lda #' '
000AEEr 3  22 rr rr rr      jsl RA8875_WriteChar
000AF2r 3               
000AF2r 3  C2 30            longr
000AF4r 3  3B               tsc
000AF5r 3  18               clc
000AF6r 3  69 10 00         adc #16
000AF9r 3  22 rr rr rr      jsl RA8875_WriteHex16
000AFDr 3  E2 30            shortr
000AFFr 3  A9 20            lda #' '
000B01r 3  22 rr rr rr      jsl RA8875_WriteChar
000B05r 3               
000B05r 3  C2 30            longr
000B07r 3  3B               tsc
000B08r 3  18               clc
000B09r 3  69 12 00         adc #18
000B0Cr 3  22 rr rr rr      jsl RA8875_WriteHex16
000B10r 3  E2 30            shortr
000B12r 3  A9 20            lda #' '
000B14r 3  22 rr rr rr      jsl RA8875_WriteChar
000B18r 3               
000B18r 3  C2 30            longr
000B1Ar 3  3B               tsc
000B1Br 3  18               clc
000B1Cr 3  69 14 00         adc #20
000B1Fr 3  22 rr rr rr      jsl RA8875_WriteHex16
000B23r 3  E2 30            shortr
000B25r 3  A9 20            lda #' '
000B27r 3  22 rr rr rr      jsl RA8875_WriteChar
000B2Br 3               
000B2Br 3  A9 0A            lda #$A
000B2Dr 3  22 rr rr rr      jsl RA8875_WriteChar
000B31r 3               
000B31r 3               ; Skip the first two as they are DumpStack return
000B31r 3  A3 04            lda 4,s           ;get mode
000B33r 3  22 rr rr rr      jsl RA8875_WriteHex
000B37r 3  A3 05            lda 5,s           ;get mode
000B39r 3  22 rr rr rr      jsl RA8875_WriteHex
000B3Dr 3               
000B3Dr 3  A9 20            lda #' '
000B3Fr 3  22 rr rr rr      jsl RA8875_WriteChar
000B43r 3               
000B43r 3               
000B43r 3  A3 06            lda 6,s           ;get mode
000B45r 3  22 rr rr rr      jsl RA8875_WriteHex
000B49r 3  A3 07            lda 7,s           ;get mode
000B4Br 3  22 rr rr rr      jsl RA8875_WriteHex
000B4Fr 3               
000B4Fr 3  A9 20            lda #' '
000B51r 3  22 rr rr rr      jsl RA8875_WriteChar
000B55r 3               
000B55r 3               
000B55r 3  A3 08            lda 8,s           ;get mode
000B57r 3  22 rr rr rr      jsl RA8875_WriteHex
000B5Br 3  A3 09            lda 9,s           ;get mode
000B5Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000B61r 3               
000B61r 3               
000B61r 3  A9 20            lda #' '
000B63r 3  22 rr rr rr      jsl RA8875_WriteChar
000B67r 3               
000B67r 3               
000B67r 3  A3 0A            lda 10,s           ;get mode
000B69r 3  22 rr rr rr      jsl RA8875_WriteHex
000B6Dr 3  A3 0B            lda 11,s           ;get mode
000B6Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000B73r 3               
000B73r 3  A9 20            lda #' '
000B75r 3  22 rr rr rr      jsl RA8875_WriteChar
000B79r 3               
000B79r 3               
000B79r 3  A3 0C            lda 12,s           ;get mode
000B7Br 3  22 rr rr rr      jsl RA8875_WriteHex
000B7Fr 3  A3 0D            lda 13,s           ;get mode
000B81r 3  22 rr rr rr      jsl RA8875_WriteHex
000B85r 3               
000B85r 3  A9 20            lda #' '
000B87r 3  22 rr rr rr      jsl RA8875_WriteChar
000B8Br 3               
000B8Br 3               
000B8Br 3  A3 0E            lda 14,s           ;get mode
000B8Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000B91r 3  A3 0F            lda 15,s           ;get mode
000B93r 3  22 rr rr rr      jsl RA8875_WriteHex
000B97r 3               
000B97r 3  A9 20            lda #' '
000B99r 3  22 rr rr rr      jsl RA8875_WriteChar
000B9Dr 3               
000B9Dr 3               
000B9Dr 3  A3 10            lda 16,s           ;get mode
000B9Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000BA3r 3  A3 11            lda 17,s           ;get mode
000BA5r 3  22 rr rr rr      jsl RA8875_WriteHex
000BA9r 3               
000BA9r 3               
000BA9r 3  A9 20            lda #' '
000BABr 3  22 rr rr rr      jsl RA8875_WriteChar
000BAFr 3               
000BAFr 3               
000BAFr 3  A3 12            lda 18,s           ;get mode
000BB1r 3  22 rr rr rr      jsl RA8875_WriteHex
000BB5r 3  A3 13            lda 19,s           ;get mode
000BB7r 3  22 rr rr rr      jsl RA8875_WriteHex
000BBBr 3               
000BBBr 3  A9 20            lda #' '
000BBDr 3  22 rr rr rr      jsl RA8875_WriteChar
000BC1r 3               
000BC1r 3               
000BC1r 3  A3 14            lda 20,s           ;get mode
000BC3r 3  22 rr rr rr      jsl RA8875_WriteHex
000BC7r 3  A3 15            lda 21,s           ;get mode
000BC9r 3  22 rr rr rr      jsl RA8875_WriteHex
000BCDr 3               
000BCDr 3  A9 20            lda #' '
000BCFr 3  22 rr rr rr      jsl RA8875_WriteChar
000BD3r 3               
000BD3r 3               
000BD3r 3  A3 16            lda 22,s           ;get mode
000BD5r 3  22 rr rr rr      jsl RA8875_WriteHex
000BD9r 3  A3 17            lda 23,s           ;get mode
000BDBr 3  22 rr rr rr      jsl RA8875_WriteHex
000BDFr 3               
000BDFr 3  A9 20            lda #' '
000BE1r 3  22 rr rr rr      jsl RA8875_WriteChar
000BE5r 3               
000BE5r 3               
000BE5r 3  A3 18            lda 24,s           ;get mode
000BE7r 3  22 rr rr rr      jsl RA8875_WriteHex
000BEBr 3  A3 19            lda 25,s           ;get mode
000BEDr 3  22 rr rr rr      jsl RA8875_WriteHex
000BF1r 3               
000BF1r 3               
000BF1r 3  A9 20            lda #' '
000BF3r 3  22 rr rr rr      jsl RA8875_WriteChar
000BF7r 3               
000BF7r 3               
000BF7r 3  A3 1A            lda 26,s           ;get mode
000BF9r 3  22 rr rr rr      jsl RA8875_WriteHex
000BFDr 3  A3 1B            lda 27,s           ;get mode
000BFFr 3  22 rr rr rr      jsl RA8875_WriteHex
000C03r 3               
000C03r 3  A9 0A            lda #$A
000C05r 3  22 rr rr rr      jsl RA8875_WriteChar
000C09r 3               
000C09r 3  C2 30            longr
000C0Br 3  6B               rtl
000C0Cr 3               
000C0Cr 2               .include "dumpregs.asm"
000C0Cr 3               .A8
000C0Cr 3               .I8
000C0Cr 3               DumpRegs:
000C0Cr 3  C2 30            longr
000C0Er 3  48               pha
000C0Fr 3  DA               phx
000C10r 3  5A               phy
000C11r 3               
000C11r 3  E2 30            shortr
000C13r 3               
000C13r 3  A9 41            lda #'A'
000C15r 3  22 rr rr rr      jsl RA8875_WriteChar
000C19r 3  A9 3A            lda #':'
000C1Br 3  22 rr rr rr      jsl RA8875_WriteChar
000C1Fr 3  A9 20            lda #' '
000C21r 3  22 rr rr rr      jsl RA8875_WriteChar
000C25r 3  A3 06            lda 6,s           ;get mode
000C27r 3  22 rr rr rr      jsl RA8875_WriteHex
000C2Br 3  A3 05            lda 5,s           ;get mode
000C2Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000C31r 3  A9 0A            lda #$0A
000C33r 3  22 rr rr rr      jsl RA8875_WriteChar
000C37r 3               
000C37r 3               
000C37r 3  A9 59            lda #'Y'
000C39r 3  22 rr rr rr      jsl RA8875_WriteChar
000C3Dr 3  A9 3A            lda #':'
000C3Fr 3  22 rr rr rr      jsl RA8875_WriteChar
000C43r 3  A9 20            lda #' '
000C45r 3  22 rr rr rr      jsl RA8875_WriteChar
000C49r 3  A3 02            lda 2,s           ;get mode
000C4Br 3  22 rr rr rr      jsl RA8875_WriteHex
000C4Fr 3  A3 01            lda 1,s           ;get mode
000C51r 3  22 rr rr rr      jsl RA8875_WriteHex
000C55r 3  A9 0A            lda #$0A
000C57r 3  22 rr rr rr      jsl RA8875_WriteChar
000C5Br 3               
000C5Br 3  A9 58            lda #'X'
000C5Dr 3  22 rr rr rr      jsl RA8875_WriteChar
000C61r 3  A9 3A            lda #':'
000C63r 3  22 rr rr rr      jsl RA8875_WriteChar
000C67r 3  A9 20            lda #' '
000C69r 3  22 rr rr rr      jsl RA8875_WriteChar
000C6Dr 3  A3 04            lda 4,s           ;get mode
000C6Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000C73r 3  A3 03            lda 3,s           ;get mode
000C75r 3  22 rr rr rr      jsl RA8875_WriteHex
000C79r 3  A9 0A            lda #$0A
000C7Br 3  22 rr rr rr      jsl RA8875_WriteChar
000C7Fr 3               
000C7Fr 3               
000C7Fr 3               
000C7Fr 3  C2 30            longr       ;select 16 bit registers
000C81r 3               
000C81r 3  7A               ply
000C82r 3  FA               plx
000C83r 3  68               pla
000C84r 3               
000C84r 3  60               rts
000C85r 3               
000C85r 2               
000C85r 1               .A8
000C85r 1               .I8
000C85r 1               ResetVector:
000C85r 1  A2 FF            ldx #$FF
000C87r 1  9A               txs
000C88r 1  D8               cld
000C89r 1  20 rr rr         jsr InitBIOS                    ; Entry point for boot
000C8Cr 1               
000C8Cr 1  C2 30            longr
000C8Er 1  20 rr rr         jsr InitKernel                  ; Kernel Init
000C91r 1               
000C91r 1               
000C91r 1  E2 30            shortr
000C93r 1  A9 00            lda #$00            ; push program bank of ShellExec
000C95r 1  48               pha
000C96r 1  C2 30            longr
000C98r 1  F4 rr rr         pea ShellExec       ; push 2byte addr of ShellExec
000C9Br 1  22 rr rr rr      jsl TaskSpawn
000C9Fr 1  68               pla
000CA0r 1  E2 30            shortr
000CA2r 1  68               pla
000CA3r 1               
000CA3r 1  A9 00            lda #$00            ; push program bank of ClockExec
000CA5r 1  48               pha
000CA6r 1  C2 30            longr
000CA8r 1  F4 rr rr         pea ClockExec       ; push 2byte addr of ClockExec
000CABr 1  22 rr rr rr      jsl TaskSpawn
000CAFr 1  68               pla
000CB0r 1  E2 30            shortr
000CB2r 1  68               pla ; clean up
000CB3r 1               
000CB3r 1               
000CB3r 1  A9 00            lda #$00            ; push program bank of LoaderExec
000CB5r 1  48               pha
000CB6r 1  C2 30            longr
000CB8r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000CBBr 1  22 rr rr rr      jsl TaskSpawn
000CBFr 1  68               pla
000CC0r 1  E2 30            shortr
000CC2r 1  68               pla ; clean up
000CC3r 1               
000CC3r 1               
000CC3r 1  A9 00            lda #$00            ; push program bank of LoaderExec
000CC5r 1  48               pha
000CC6r 1  C2 30            longr
000CC8r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000CCBr 1  22 rr rr rr      jsl TaskSpawn
000CCFr 1  68               pla
000CD0r 1  E2 30            shortr
000CD2r 1  68               pla ; clean up
000CD3r 1               
000CD3r 1  A9 00            lda #$00            ; push program bank of LoaderExec
000CD5r 1  48               pha
000CD6r 1  C2 30            longr
000CD8r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000CDBr 1  22 rr rr rr      jsl TaskSpawn
000CDFr 1  68               pla
000CE0r 1  E2 30            shortr
000CE2r 1  68               pla ; clean up
000CE3r 1               
000CE3r 1  A9 00            lda #$00            ; push program bank of LoaderExec
000CE5r 1  48               pha
000CE6r 1  C2 30            longr
000CE8r 1  F4 rr rr         pea TaskPrinterExec       ; push 2byte addr of LoaderExec
000CEBr 1  22 rr rr rr      jsl TaskSpawn
000CEFr 1  68               pla
000CF0r 1  E2 30            shortr
000CF2r 1  68               pla ; clean up
000CF3r 1               
000CF3r 1               
000CF3r 1               
000CF3r 1               
000CF3r 1                   ; debug printing of task
000CF3r 1                   ;lda TaskProgramBank+1
000CF3r 1                   ;jsl RA8875_WriteHex
000CF3r 1                   ;lda TaskProgramPointer+2
000CF3r 1                   ;jsl RA8875_WriteHex
000CF3r 1                   ;lda TaskProgramPointer+3
000CF3r 1                   ;jsl RA8875_WriteHex
000CF3r 1               
000CF3r 1               
000CF3r 1  58               cli
000CF4r 1               
000CF4r 1                   ;jsl Scheduler_NextTask
000CF4r 1                   ;jsr ShellExec                   ; Run shell program
000CF4r 1               
000CF4r 1               ; Blink Diode
000CF4r 1                   ;jsl LoaderExec
000CF4r 1               
000CF4r 1               Loop:
000CF4r 1  4C rr rr         jmp Loop
000CF7r 1               
000CF7r 1               .SEGMENT "NATIVE_VECTORS"
000000r 1  00 00            .word $0000                 ; COP
000002r 1  00 00            .word $0000                 ; BRK
000004r 1  00 00            .word $0000                 ; ABORTB
000006r 1  00 00            .word $0000                 ; NMIB
000008r 1  00 00            .word $0000                 ; RES
00000Ar 1               .SEGMENT "VECTORS"
000000r 1  rr rr            .word ResetVector           ; RESET
000002r 1  rr rr            .word InterruptVector       ; IRQB
000004r 1               
000004r 1               
