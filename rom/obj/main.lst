ca65 V2.18 - Ubuntu 2.19-1
Main file   : src/main.asm
Current file: src/main.asm

000000r 1               .setcpu "65816"
000000r 1               .P816
000000r 1               .smart
000000r 1               .feature string_escapes
000000r 1               
000000r 1               .zeropage
000000r 1               .include "drivers/spi/spi.zp.inc"
000000r 2  xx           spi_byte_out:               .res 1
000001r 2  xx           spi_byte_in:                .res 1
000002r 2  xx           spi_selected_device:        .res 1
000003r 2               
000003r 1               .include "drivers/ra8875/ra8875.zp.inc"
000003r 2               
000003r 2  xx xx        string_ptr:                 .res 2
000005r 2  xx           cursor_x:                   .res 1
000006r 2  xx           cursor_y:                   .res 1
000007r 2               
000007r 2  xx           control_sequence_param_1:   .res 1
000008r 2  xx           control_sequence_param_2:   .res 1
000009r 2               
000009r 1               
000009r 1               .RODATA
000000r 1               
000000r 1  0A 2D 2D 2D  test_string: .asciiz "\n---\n"
000004r 1  0A 00        
000006r 1  31 33 35 37  testlen_string: .asciiz "1357abcdefgh78"
00000Ar 1  61 62 63 64  
00000Er 1  65 66 67 68  
000015r 1               
000015r 1               .code
000000r 1               .include "kernel/kernel.inc"
000000r 2               .A16
000000r 2               .I16
000000r 2               .macro write str_addr
000000r 2                   pea str_addr
000000r 2                   JSL RA8875_WriteString16
000000r 2                   PLA
000000r 2               .endmacro
000000r 2               
000000r 2               .A8
000000r 2               .I8
000000r 2               .macro write_char char
000000r 2                   PHA
000000r 2                   LDA char
000000r 2                   JSR RA8875_WriteStringChar
000000r 2                   PLA
000000r 2               .endmacro
000000r 2               
000000r 2               .RODATA
000015r 2               
000015r 2  0A 00        newline:                    .asciiz "\n"
000017r 2  4B 45 52 4E  init_kernel_done:           .asciiz "KERNEL - OK\n"
00001Br 2  45 4C 20 2D  
00001Fr 2  20 4F 4B 0A  
000024r 2  4B 45 52 4E  init_kernel_streams_done:   .asciiz "KERNEL: Streams - OK\n"
000028r 2  45 4C 3A 20  
00002Cr 2  53 74 72 65  
00003Ar 2  4B 45 52 4E  init_kernel_tasks_done:     .asciiz "KERNEL: Tasks - OK\n"
00003Er 2  45 4C 3A 20  
000042r 2  54 61 73 6B  
00004Er 2  4B 45 52 4E  init_kernel_scheduler_done: .asciiz "KERNEL: Scheduler - OK\n"
000052r 2  45 4C 3A 20  
000056r 2  53 63 68 65  
000066r 2               .code
000000r 2               
000000r 1               .include "macros/macros.inc"
000000r 2               ; bmn
000000r 2               ;       Block move macro
000000r 2               
000000r 2               .macro  bmn     len,from,to
000000r 2                       lda     #len-1
000000r 2                       ldx     #(from & $FFFF)
000000r 2                       ldy     #(to   & $FFFF)
000000r 2                       mvn     (from & $FF0000),(to & $FF0000)
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               ;   Register Size Macros
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;   These macros are a convenient way to change the MPU's register sizes
000000r 2               ;   without having to remember the correct bit pattern for the REP & SEP
000000r 2               ;   instructions.  The assembler itself has no awareness of whether 8 or
000000r 2               ;   16 bit immediate mode operands are to be used.   Therefore, it is up
000000r 2               ;   to the programmer to use the appropriate instructions, & to be aware
000000r 2               ;   at all times of the MPU's register sizes.
000000r 2               ;   ————————————————————————————————————————————————————————————————————
000000r 2               ;
000000r 2               .macro  longa                ;16 bit accumulator & memory
000000r 2                       rep #$20
000000r 2               .A16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longr                ;16 bit all registers
000000r 2                       rep #$30
000000r 2               .A16
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  longi              ;16 bit index registers
000000r 2                       rep #$10
000000r 2               .I16
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorta                ;8 bit accumulator & memory
000000r 2                       sep #$20
000000r 2               .A8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shorti                ;8 bit index registers
000000r 2                       sep #$10
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               .macro  shortr                ;8 bit all registers
000000r 2                       sep #$30
000000r 2               .A8
000000r 2               .I8
000000r 2               .endmacro
000000r 2               ;
000000r 2               
000000r 1               
000000r 1               .include "bios/bios.asm"
000000r 2               .include "bios.inc"                         ; include BIOS includes
000000r 3               .RODATA
000066r 3               
000066r 3  42 49 4F 53  bios_init: .asciiz "BIOS Initialized"
00006Ar 3  20 49 6E 69  
00006Er 3  74 69 61 6C  
000077r 3  20 2D 20 4F  ok_string: .asciiz " - OK\n"
00007Br 3  4B 0A 00     
00007Er 3               
00007Er 3               
00007Er 3  43 4F 4C 4F  ansi_string: .byte "COLOR: ", $1B, $5B, "32mGREEN", $1B, $5B, "37m WHITE\n", $00
000082r 3  52 3A 20 1B  
000086r 3  5B 33 32 6D  
00009Cr 3               
00009Cr 3  49 4E 49 54  test_bios: .asciiz "INIT...\n"
0000A0r 3  2E 2E 2E 0A  
0000A4r 3  00           
0000A5r 3  20 2D 20 46  fail_string: .asciiz " - FAIL\n"
0000A9r 3  41 49 4C 0A  
0000ADr 3  00           
0000AEr 3               
0000AEr 3  20 5F 5F 5F  welcome_logo1: .asciiz " ______   ______   ______     ____     ______       ______   ______\n"
0000B2r 3  5F 5F 5F 20  
0000B6r 3  20 20 5F 5F  
0000F3r 3  2F 5F 5F 5F  welcome_logo2: .asciiz "/_____/\\ /_____/\\ /_____/\\   /___/\\   /_____/\\     /_____/\\ /_____/\\\n"
0000F7r 3  5F 5F 2F 5C  
0000FBr 3  20 2F 5F 5F  
000139r 3  5C 3A 3A 3A  welcome_logo3: .asciiz "\\:::__\\/ \\::::_\\/_\\:::_:\\ \\  \\_::\\ \\  \\:::__\\/     \\:::_ \\ \\\\::::_\\/_\n"
00013Dr 3  5F 5F 5C 2F  
000141r 3  20 5C 3A 3A  
000180r 3  20 5C 3A 5C  welcome_logo4: .asciiz " \\:\\ \\____\\:\\/___/\\\\:\\_\\:\\ \\   \\::\\ \\  \\:\\ \\____    \\:\\ \\ \\ \\\\:\\/___/\\\n"
000184r 3  20 5C 5F 5F  
000188r 3  5F 5F 5C 3A  
0001C8r 3  20 20 5C 3A  welcome_logo5: .asciiz "  \\::__::/\\\\_::._\\:\\\\::__:\\ \\  _\\: \\ \\__\\::__::/\\    \\:\\ \\ \\ \\\\_::._\\:\\\n"
0001CCr 3  3A 5F 5F 3A  
0001D0r 3  3A 2F 5C 5C  
000211r 3  20 20 20 5C  welcome_logo6: .asciiz "   \\:\\_\\:\\ \\/_____\\/ \\:\\_\\:\\ \\/__\\: \\__/\\\\:\\_\\:\\ \\    \\:\\_\\ \\ \\ /____\\:\\\n"
000215r 3  3A 5C 5F 5C  
000219r 3  3A 5C 20 5C  
00025Br 3  20 20 20 20  welcome_logo7: .asciiz "    \\_____\\/\\_____/   \\_____\\/\\________\\/ \\_____\\/     \\_____\\/ \\_____\\/\n"
00025Fr 3  5C 5F 5F 5F  
000263r 3  5F 5F 5C 2F  
0002A5r 3               
0002A5r 3               .code
000000r 3               
000000r 2               .include "via.inc"                          ; include VIA labels
000000r 3               
000000r 3                   .import __VIA1_START__
000000r 3                   .import __VIA2_START__
000000r 3               
000000r 3                   VIA1B = __VIA1_START__                            ; VIA PORT B input/output register
000000r 3                   VIA1A = __VIA1_START__ + 1                        ; VIA PORT A input/output register
000000r 3                   VIA1B_DIRECTION = __VIA1_START__ + 2              ; VIA PORT B direction register is $6002
000000r 3                   VIA1A_DIRECTION = __VIA1_START__ + 3              ; VIA PORT A direction register is $6003
000000r 3                   VIA1_T1CL = __VIA1_START__ + 4                    ; Timer 1 Low order latches
000000r 3                   VIA1_T1CH = __VIA1_START__ + 5                    ; Timer 1 High order counter
000000r 3                   VIA1_ACR = __VIA1_START__ + 11                    ; Auxillary Control Register
000000r 3                   VIA1_PCR = __VIA1_START__ + 12                    ; Peripheral Control Register
000000r 3                   VIA1_IFR = __VIA1_START__ + 13                    ; Interupt Flag Register
000000r 3                   VIA1_IER = __VIA1_START__ + 14                    ; Interupt Enable Register
000000r 3               
000000r 3                   VIA2B = __VIA2_START__                            ; VIA2 PORT B input/output register
000000r 3                   VIA2A = __VIA2_START__ + 1                        ; VIA2 PORT A input/output register
000000r 3                   VIA2B_DIRECTION = __VIA2_START__ + 2              ; VIA2 PORT B direction register is $5002
000000r 3                   VIA2A_DIRECTION = __VIA2_START__ + 3              ; VIA2 PORT A direction register is $5003
000000r 3               
000000r 2               .include "../drivers/spi/spi.asm"           ; include SPI code
000000r 3               .A8
000000r 3               .I8
000000r 3               SPI_VIA = VIA1B
000000r 3               
000000r 3               ; prepares spi VIA PORT A for input output
000000r 3               InitSPI:
000000r 3  A9 47            LDA #$47
000002r 3  8D rr rr         STA VIA1B_DIRECTION
000005r 3  A9 00            LDA #$00
000007r 3  8D rr rr         STA SPI_VIA
00000Ar 3  60               RTS
00000Br 3               
00000Br 3               ; select device for spi communication
00000Br 3               SpiDeviceSelect:
00000Br 3  85 rr            STA spi_selected_device
00000Dr 3  AD rr rr         LDA SPI_VIA
000010r 3  60               RTS
000011r 3               
000011r 3               ; deselect spi device
000011r 3               SpiDeviceDeselect:
000011r 3  64 rr            STZ spi_selected_device
000013r 3  9C rr rr         STZ SPI_VIA
000016r 3  60               RTS
000017r 3               
000017r 3               
000017r 3               ; Transmit one byte SPI data. Remember to select SPI device with SpiDeviceSelect
000017r 3               ; in:
000017r 3               ;   A - byte to send over SPI
000017r 3               ; out:
000017r 3               ;   A - byte received over SPI
000017r 3               
000017r 3               SpiByte:
000017r 3  85 rr            STA spi_byte_out                            ; store
000019r 3  64 rr            STZ spi_byte_in
00001Br 3  A2 08            LDX #8
00001Dr 3  A5 rr            LDA spi_selected_device
00001Fr 3               spibytelp:
00001Fr 3  06 rr            ASL spi_byte_out	                        ; (5) shift MSB in to carry
000021r 3  90 02            BCC spibyte1
000023r 3  09 40            ORA #$40                                    ; set MOSI if MSB set
000025r 3               spibyte1:
000025r 3  8D rr rr         STA SPI_VIA	                                ; output (MOSI    SCS low   SCLK low)
000028r 3               
000028r 3  A5 rr            LDA spi_selected_device                     ; set A to selected device bit (Do it here for delay reasons)
00002Ar 3  EE rr rr         INC SPI_VIA                                 ; toggle clock high (SCLK is bit 0)
00002Dr 3               
00002Dr 3  18               CLC                                         ; clear C (Not affected by bit)
00002Er 3  2C rr rr         BIT SPI_VIA                                 ; copy MISO (bit 7) in to N (and MOSI in to V)
000031r 3  10 01            BPL spibyte2
000033r 3  38               SEC		                                    ; set C is MISO bit is set (i.e. N)
000034r 3               spibyte2:
000034r 3  26 rr            ROL spi_byte_in		                        ; copy C (i.e. MISO bit) in to bit 0 of result
000036r 3  CE rr rr         DEC SPI_VIA                                 ; toggle clock low (SCLK is bit 0)
000039r 3               
000039r 3  CA               DEX
00003Ar 3  D0 E3            BNE spibytelp;
00003Cr 3  A5 rr            LDA spi_byte_in	                            ; load result into A
00003Er 3               
00003Er 3  60               RTS
00003Fr 3               
00003Fr 2               .include "../drivers/keyboard/keyboard.asm" ; include Keyboard driver
00003Fr 3               KB_CONTROL_RELEASE      = %00000001
00003Fr 3               KB_CONTROL_RELEASE_INV  = %11111110
00003Fr 3               KB_CONTROL_EXTENDED     = %00000010
00003Fr 3               KB_CONTROL_EXTENDED_INV = %11111101
00003Fr 3               KB_CONTROL_SHIFTED      = %10000000
00003Fr 3               KB_CONTROL_SHIFTED_INV  = %01111111
00003Fr 3               
00003Fr 3               .include "keyboard_layout_iso.inc"
00003Fr 4               
00003Fr 4               .rodata
0002A5r 4               ASCIITBL:
0002A5r 4  00                          .byte $00               ; 00 no key pressed
0002A6r 4  89                          .byte $89               ; 01 F9
0002A7r 4  87                          .byte $87               ; 02 relocated F7
0002A8r 4  85                          .byte $85               ; 03 F5
0002A9r 4  83                          .byte $83               ; 04 F3
0002AAr 4  81                          .byte $81               ; 05 F1
0002ABr 4  82                          .byte $82               ; 06 F2
0002ACr 4  8C                          .byte $8C               ; 07 F12
0002ADr 4  00                          .byte $00               ; 08
0002AEr 4  8A                          .byte $8A               ; 09 F10
0002AFr 4  88                          .byte $88               ; 0A F8
0002B0r 4  86                          .byte $86               ; 0B F6
0002B1r 4  84                          .byte $84               ; 0C F4
0002B2r 4  09                          .byte $09               ; 0D tab
0002B3r 4  60                          .byte $60               ; 0E `~
0002B4r 4  8F                          .byte $8F               ; 0F relocated Print Screen key
0002B5r 4  03                          .byte $03               ; 10 relocated Pause/Break key
0002B6r 4  A0                          .byte $A0               ; 11 left alt (right alt too)
0002B7r 4  00                          .byte $00               ; 12 left shift
0002B8r 4  E0                          .byte $E0               ; 13 relocated Alt release code
0002B9r 4  00                          .byte $00               ; 14 left ctrl (right ctrl too)
0002BAr 4  71                          .byte $71               ; 15 qQ
0002BBr 4  31                          .byte $31               ; 16 1!
0002BCr 4  00                          .byte $00               ; 17
0002BDr 4  00                          .byte $00               ; 18
0002BEr 4  00                          .byte $00               ; 19
0002BFr 4  7A                          .byte $7A               ; 1A zZ
0002C0r 4  73                          .byte $73               ; 1B sS
0002C1r 4  61                          .byte $61               ; 1C aA
0002C2r 4  77                          .byte $77               ; 1D wW
0002C3r 4  32                          .byte $32               ; 1E 2@
0002C4r 4  A1                          .byte $A1               ; 1F Windows 98 menu key (left side)
0002C5r 4  02                          .byte $02               ; 20 relocated ctrl-break key
0002C6r 4  63                          .byte $63               ; 21 cC
0002C7r 4  78                          .byte $78               ; 22 xX
0002C8r 4  64                          .byte $64               ; 23 dD
0002C9r 4  65                          .byte $65               ; 24 eE
0002CAr 4  34                          .byte $34               ; 25 4$
0002CBr 4  33                          .byte $33               ; 26 3#
0002CCr 4  A2                          .byte $A2               ; 27 Windows 98 menu key (right side)
0002CDr 4  00                          .byte $00               ; 28
0002CEr 4  20                          .byte $20               ; 29 space
0002CFr 4  76                          .byte $76               ; 2A vV
0002D0r 4  66                          .byte $66               ; 2B fF
0002D1r 4  74                          .byte $74               ; 2C tT
0002D2r 4  72                          .byte $72               ; 2D rR
0002D3r 4  35                          .byte $35               ; 2E 5%
0002D4r 4  A3                          .byte $A3               ; 2F Windows 98 option key (right click, right side)
0002D5r 4  00                          .byte $00               ; 30
0002D6r 4  6E                          .byte $6E               ; 31 nN
0002D7r 4  62                          .byte $62               ; 32 bB
0002D8r 4  68                          .byte $68               ; 33 hH
0002D9r 4  67                          .byte $67               ; 34 gG
0002DAr 4  79                          .byte $79               ; 35 yY
0002DBr 4  36                          .byte $36               ; 36 6^
0002DCr 4  00                          .byte $00               ; 37
0002DDr 4  00                          .byte $00               ; 38
0002DEr 4  00                          .byte $00               ; 39
0002DFr 4  6D                          .byte $6D               ; 3A mM
0002E0r 4  6A                          .byte $6A               ; 3B jJ
0002E1r 4  75                          .byte $75               ; 3C uU
0002E2r 4  37                          .byte $37               ; 3D 7/
0002E3r 4  38                          .byte $38               ; 3E 8(
0002E4r 4  00                          .byte $00               ; 3F
0002E5r 4  00                          .byte $00               ; 40
0002E6r 4  2C                          .byte $2C               ; 41 ,<
0002E7r 4  6B                          .byte $6B               ; 42 kK
0002E8r 4  69                          .byte $69               ; 43 iI
0002E9r 4  6F                          .byte $6F               ; 44 oO
0002EAr 4  30                          .byte $30               ; 45 0=
0002EBr 4  39                          .byte $39               ; 46 9)
0002ECr 4  00                          .byte $00               ; 47
0002EDr 4  00                          .byte $00               ; 48
0002EEr 4  2E                          .byte $2E               ; 49 .>
0002EFr 4  2D                          .byte $2D               ; 4A -_
0002F0r 4  6C                          .byte $6C               ; 4B lL
0002F1r 4  3B                          .byte $3B               ; 4C ;:
0002F2r 4  70                          .byte $70               ; 4D pP
0002F3r 4  2B                          .byte $2B               ; 4E +?
0002F4r 4  00                          .byte $00               ; 4F
0002F5r 4  00                          .byte $00               ; 50
0002F6r 4  00                          .byte $00               ; 51
0002F7r 4  27                          .byte $27               ; 52 '"
0002F8r 4  00                          .byte $00               ; 53
0002F9r 4  5B                          .byte $5B               ; 54 [{
0002FAr 4  3D                          .byte $3D               ; 55 =+
0002FBr 4  00                          .byte $00               ; 56
0002FCr 4  00                          .byte $00               ; 57
0002FDr 4  00                          .byte $00               ; 58 caps
0002FEr 4  00                          .byte $00               ; 59 r shift
0002FFr 4  0A                          .byte $0A               ; 5A <Enter>
000300r 4  5D                          .byte $5D               ; 5B ]}
000301r 4  00                          .byte $00               ; 5C
000302r 4  27                          .byte $27               ; 5D '*
000303r 4  00                          .byte $00               ; 5E
000304r 4  00                          .byte $00               ; 5F
000305r 4  00                          .byte $00               ; 60
000306r 4  00                          .byte $00               ; 61
000307r 4  00                          .byte $00               ; 62
000308r 4  00                          .byte $00               ; 63
000309r 4  00                          .byte $00               ; 64
00030Ar 4  00                          .byte $00               ; 65
00030Br 4  08                          .byte $08               ; 66 bkspace
00030Cr 4  00                          .byte $00               ; 67
00030Dr 4  00                          .byte $00               ; 68
00030Er 4  31                          .byte $31               ; 69 kp 1
00030Fr 4  2F                          .byte $2f               ; 6A kp / converted from E04A in code
000310r 4  34                          .byte $34               ; 6B kp 4
000311r 4  37                          .byte $37               ; 6C kp 7
000312r 4  00                          .byte $00               ; 6D
000313r 4  00                          .byte $00               ; 6E
000314r 4  00                          .byte $00               ; 6F
000315r 4  30                          .byte $30               ; 70 kp 0
000316r 4  2E                          .byte $2E               ; 71 kp .
000317r 4  32                          .byte $32               ; 72 kp 2
000318r 4  35                          .byte $35               ; 73 kp 5
000319r 4  36                          .byte $36               ; 74 kp 6
00031Ar 4  38                          .byte $38               ; 75 kp 8
00031Br 4  1B                          .byte $1B               ; 76 esc
00031Cr 4  00                          .byte $00               ; 77 num lock
00031Dr 4  8B                          .byte $8B               ; 78 F11
00031Er 4  2B                          .byte $2B               ; 79 kp +
00031Fr 4  33                          .byte $33               ; 7A kp 3
000320r 4  2D                          .byte $2D               ; 7B kp -
000321r 4  2A                          .byte $2A               ; 7C kp *
000322r 4  39                          .byte $39               ; 7D kp 9
000323r 4  8D                          .byte $8D               ; 7E scroll lock
000324r 4  00                          .byte $00               ; 7F
000325r 4               ;
000325r 4               ; Table for shifted scancodes
000325r 4               ;
000325r 4  00                          .byte $00               ; 80
000326r 4  C9                          .byte $C9               ; 81 F9
000327r 4  C7                          .byte $C7               ; 82 relocated F7
000328r 4  C5                          .byte $C5               ; 83 F5 (F7 actual scancode=83)
000329r 4  C3                          .byte $C3               ; 84 F3
00032Ar 4  C1                          .byte $C1               ; 85 F1
00032Br 4  C2                          .byte $C2               ; 86 F2
00032Cr 4  CC                          .byte $CC               ; 87 F12
00032Dr 4  00                          .byte $00               ; 88
00032Er 4  CA                          .byte $CA               ; 89 F10
00032Fr 4  C8                          .byte $C8               ; 8A F8
000330r 4  C6                          .byte $C6               ; 8B F6
000331r 4  C4                          .byte $C4               ; 8C F4
000332r 4  09                          .byte $09               ; 8D tab
000333r 4  7E                          .byte $7E               ; 8E `~
000334r 4  CF                          .byte $CF               ; 8F relocated Print Screen key
000335r 4  03                          .byte $03               ; 90 relocated Pause/Break key
000336r 4  A0                          .byte $A0               ; 91 left alt (right alt)
000337r 4  00                          .byte $00               ; 92 left shift
000338r 4  E0                          .byte $E0               ; 93 relocated Alt release code
000339r 4  00                          .byte $00               ; 94 left ctrl (and right ctrl)
00033Ar 4  51                          .byte $51               ; 95 qQ
00033Br 4  21                          .byte $21               ; 96 1!
00033Cr 4  00                          .byte $00               ; 97
00033Dr 4  00                          .byte $00               ; 98
00033Er 4  00                          .byte $00               ; 99
00033Fr 4  5A                          .byte $5A               ; 9A zZ
000340r 4  53                          .byte $53               ; 9B sS
000341r 4  41                          .byte $41               ; 9C aA
000342r 4  57                          .byte $57               ; 9D wW
000343r 4  22                          .byte $22               ; 9E 2"
000344r 4  E1                          .byte $E1               ; 9F Windows 98 menu key (left side)
000345r 4  02                          .byte $02               ; A0 relocated ctrl-break key
000346r 4  43                          .byte $43               ; A1 cC
000347r 4  58                          .byte $58               ; A2 xX
000348r 4  44                          .byte $44               ; A3 dD
000349r 4  45                          .byte $45               ; A4 eE
00034Ar 4  24                          .byte $24               ; A5 4$
00034Br 4  23                          .byte $23               ; A6 3#
00034Cr 4  E2                          .byte $E2               ; A7 Windows 98 menu key (right side)
00034Dr 4  00                          .byte $00               ; A8
00034Er 4  20                          .byte $20               ; A9 space
00034Fr 4  56                          .byte $56               ; AA vV
000350r 4  46                          .byte $46               ; AB fF
000351r 4  54                          .byte $54               ; AC tT
000352r 4  52                          .byte $52               ; AD rR
000353r 4  25                          .byte $25               ; AE 5%
000354r 4  E3                          .byte $E3               ; AF Windows 98 option key (right click, right side)
000355r 4  00                          .byte $00               ; B0
000356r 4  4E                          .byte $4E               ; B1 nN
000357r 4  42                          .byte $42               ; B2 bB
000358r 4  48                          .byte $48               ; B3 hH
000359r 4  47                          .byte $47               ; B4 gG
00035Ar 4  59                          .byte $59               ; B5 yY
00035Br 4  5E                          .byte $5E               ; B6 6^
00035Cr 4  00                          .byte $00               ; B7
00035Dr 4  00                          .byte $00               ; B8
00035Er 4  00                          .byte $00               ; B9
00035Fr 4  4D                          .byte $4D               ; BA mM
000360r 4  4A                          .byte $4A               ; BB jJ
000361r 4  55                          .byte $55               ; BC uU
000362r 4  2F                          .byte $2F               ; BD 7/
000363r 4  28                          .byte $28               ; BE 8(
000364r 4  00                          .byte $00               ; BF
000365r 4  00                          .byte $00               ; C0
000366r 4  3B                          .byte $3B               ; C1 ,;
000367r 4  4B                          .byte $4B               ; C2 kK
000368r 4  49                          .byte $49               ; C3 iI
000369r 4  4F                          .byte $4F               ; C4 oO
00036Ar 4  3D                          .byte $3D               ; C5 0=
00036Br 4  29                          .byte $29               ; C6 9)
00036Cr 4  00                          .byte $00               ; C7
00036Dr 4  00                          .byte $00               ; C8
00036Er 4  3A                          .byte $3A               ; C9 .:
00036Fr 4  5F                          .byte $5F               ; CA -_
000370r 4  4C                          .byte $4C               ; CB lL
000371r 4  3A                          .byte $3A               ; CC ;:
000372r 4  50                          .byte $50               ; CD pP
000373r 4  3F                          .byte $3F               ; CE +?
000374r 4  00                          .byte $00               ; CF
000375r 4  00                          .byte $00               ; D0
000376r 4  00                          .byte $00               ; D1
000377r 4  22                          .byte $22               ; D2 '"
000378r 4  00                          .byte $00               ; D3
000379r 4  7B                          .byte $7B               ; D4 [{
00037Ar 4  2B                          .byte $2B               ; D5 =+
00037Br 4  00                          .byte $00               ; D6
00037Cr 4  00                          .byte $00               ; D7
00037Dr 4  00                          .byte $00               ; D8 caps
00037Er 4  00                          .byte $00               ; D9 r shift
00037Fr 4  0D                          .byte $0D               ; DA <Enter>
000380r 4  7D                          .byte $7D               ; DB ]}
000381r 4  00                          .byte $00               ; DC
000382r 4  2A                          .byte $2A               ; DD '*
000383r 4  00                          .byte $00               ; DE
000384r 4  00                          .byte $00               ; DF
000385r 4  00                          .byte $00               ; E0
000386r 4  00                          .byte $00               ; E1
000387r 4  00                          .byte $00               ; E2
000388r 4  00                          .byte $00               ; E3
000389r 4  00                          .byte $00               ; E4
00038Ar 4  00                          .byte $00               ; E5
00038Br 4  08                          .byte $08               ; E6 bkspace
00038Cr 4  00                          .byte $00               ; E7
00038Dr 4  00                          .byte $00               ; E8
00038Er 4  91                          .byte $91               ; E9 kp 1
00038Fr 4  2F                          .byte $2f               ; EA kp / converted from E04A in code
000390r 4  94                          .byte $94               ; EB kp 4
000391r 4  97                          .byte $97               ; EC kp 7
000392r 4  00                          .byte $00               ; ED
000393r 4  00                          .byte $00               ; EE
000394r 4  00                          .byte $00               ; EF
000395r 4  90                          .byte $90               ; F0 kp 0
000396r 4  7F                          .byte $7F               ; F1 kp .
000397r 4  92                          .byte $92               ; F2 kp 2
000398r 4  95                          .byte $95               ; F3 kp 5
000399r 4  96                          .byte $96               ; F4 kp 6
00039Ar 4  98                          .byte $98               ; F5 kp 8
00039Br 4  1B                          .byte $1B               ; F6 esc
00039Cr 4  00                          .byte $00               ; F7 num lock
00039Dr 4  CB                          .byte $CB               ; F8 F11
00039Er 4  2B                          .byte $2B               ; F9 kp +
00039Fr 4  93                          .byte $93               ; FA kp 3
0003A0r 4  2D                          .byte $2D               ; FB kp -
0003A1r 4  2A                          .byte $2A               ; FC kp *
0003A2r 4  99                          .byte $99               ; FD kp 9
0003A3r 4  CD                          .byte $CD               ; FE scroll lock
0003A4r 4               ; NOT USED     .byte $00               ; FF
0003A4r 4               ; end
0003A4r 4               
0003A4r 3               
0003A4r 3               .SEGMENT "RAM"
000000r 3  xx               kb_byte:                            .res 1
000001r 3                   ; control byte:
000001r 3                   ; bit 0         - release
000001r 3                   ; bit 1         - extended
000001r 3                   ; bit 7         - shifted
000001r 3  xx               kb_control_byte:                    .res 1
000002r 3               
000002r 3               .code
00003Fr 3               
00003Fr 3               InterruptKeyboard:
00003Fr 3               
00003Fr 3  E2 30            shortr
000041r 3  AD rr rr         lda VIA1A                               ; read byte from VIA
000044r 3  8D rr rr         sta kb_byte
000047r 3               
000047r 3               ; DEBUG SCANCODE
000047r 3                   ; lda #'['
000047r 3                   ; jsl RA8875_WriteChar
000047r 3                   ; lda kb_byte
000047r 3                   ; jsl RA8875_WriteHex
000047r 3                   ; lda #']'
000047r 3                   ; jsl RA8875_WriteChar
000047r 3               
000047r 3                   ; Check control byte first
000047r 3  AD rr rr         lda kb_control_byte
00004Ar 3  29 01            and #KB_CONTROL_RELEASE
00004Cr 3  D0 43            bne keyboardHandleRelease               ; Is release control set?
00004Er 3  AD rr rr         lda kb_control_byte
000051r 3  29 02            and #KB_CONTROL_EXTENDED
000053r 3  D0 5D            bne keyboardHandleExtended              ; Is extended control set?
000055r 3               
000055r 3               
000055r 3  AD rr rr         lda kb_byte
000058r 3               
000058r 3  20 rr rr         jsr keyboardCommandTest                 ; Test for non printable scan codes
00005Br 3  F0 03            beq InterruptKeyboardReturn             ; 0 means key is handled as command
00005Dr 3               
00005Dr 3               
00005Dr 3  20 rr rr         jsr keyboardHandleAscii                 ; Handle as ASCII
000060r 3               
000060r 3               InterruptKeyboardReturn:
000060r 3  2C rr rr         bit VIA1A
000063r 3               
000063r 3  60               rts
000064r 3               
000064r 3               .A8
000064r 3               .I8
000064r 3               keyboardHandleAscii:
000064r 3  AD rr rr         lda kb_control_byte
000067r 3  29 80            and #KB_CONTROL_SHIFTED                 ; Set bit 7 is shifted
000069r 3  0D rr rr         ora kb_byte
00006Cr 3               
00006Cr 3  AA               tax
00006Dr 3  BD rr rr         lda ASCIITBL,x
000070r 3               
000070r 3  A2 00            ldx #STREAM_STDIN
000072r 3                   ;jsl RA8875_WriteChar                    ; TODO: Do not print here
000072r 3  22 rr rr rr      jsl StreamPutC                          ; Put in standard in stream
000076r 3               
000076r 3  C9 69            cmp #$69
000078r 3  D0 04            bne @next1
00007Ar 3  22 rr rr rr      jsl Scheduler_NextTask
00007Er 3               @next1:
00007Er 3  C9 6A            cmp #$6A
000080r 3  D0 0E            bne @return
000082r 3  AD rr rr         lda TimerCounter+1
000085r 3  22 rr rr rr      jsl RA8875_WriteHex
000089r 3  AD rr rr         lda TimerCounter
00008Cr 3  22 rr rr rr      jsl RA8875_WriteHex
000090r 3               
000090r 3               @return:
000090r 3  60               rts
000091r 3               
000091r 3               keyboardHandleRelease:
000091r 3  AD rr rr         lda kb_control_byte
000094r 3  29 FE            and #KB_CONTROL_RELEASE_INV
000096r 3  8D rr rr         sta kb_control_byte
000099r 3                   ; TODO: Toggle released key
000099r 3                   ;       Have a map of which keys are pressed
000099r 3               
000099r 3                   ; TODO Handle control release
000099r 3  AD rr rr         lda kb_byte
00009Cr 3  C9 12            cmp #$12                                ; left shift released
00009Er 3  F0 07            beq kbClearShifted
0000A0r 3  C9 59            cmp #$59                                ; right shift released
0000A2r 3  F0 03            beq kbClearShifted
0000A4r 3               keyboardHandleReleaseCont1:
0000A4r 3  4C rr rr         jmp InterruptKeyboardReturn
0000A7r 3               
0000A7r 3               kbClearShifted:
0000A7r 3  AD rr rr         lda kb_control_byte
0000AAr 3  29 7F            and #KB_CONTROL_SHIFTED_INV
0000ACr 3  8D rr rr         sta kb_control_byte
0000AFr 3  4C rr rr         jmp keyboardHandleReleaseCont1
0000B2r 3               
0000B2r 3               keyboardHandleExtended:
0000B2r 3  AD rr rr         lda kb_control_byte
0000B5r 3  29 FD            and #KB_CONTROL_EXTENDED_INV
0000B7r 3  8D rr rr         sta kb_control_byte
0000BAr 3                   ; TODO: Handle extended key
0000BAr 3  4C rr rr         jmp InterruptKeyboardReturn
0000BDr 3               
0000BDr 3               keyboardCommandTest:
0000BDr 3  A2 04            ldx #$04
0000BFr 3               keyboardCommandTestLoop:
0000BFr 3  DD rr rr         cmp kbcommands,x
0000C2r 3  F0 04            beq keyboardCommandRun
0000C4r 3  CA               dex
0000C5r 3  10 F8            bpl keyboardCommandTestLoop
0000C7r 3  60               rts
0000C8r 3               
0000C8r 3               keyboardCommandRun:
0000C8r 3  8A               txa
0000C9r 3  0A               asl                                 ; *2 to get address from lookup table
0000CAr 3  AA               tax
0000CBr 3  7C rr rr         jmp (kbCommandRoutines,x)           ; Jmp to the command routine
0000CEr 3               
0000CEr 3               kbcommands:
0000CEr 3  12               .byte $12       ; left shift
0000CFr 3  59               .byte $59       ; right shift
0000D0r 3  14               .byte $14       ; left ctrl
0000D1r 3  E0               .byte $E0       ; extended
0000D2r 3  F0               .byte $F0       ; break
0000D3r 3                   ; TODO: Add right control
0000D3r 3               
0000D3r 3               kbCommandRoutines:
0000D3r 3  rr rr            .word kbSetShifted
0000D5r 3  rr rr            .word kbSetShifted
0000D7r 3  rr rr            .word kbnull                        ; TODO: Handle left control
0000D9r 3  rr rr            .word kbSetExtended
0000DBr 3  rr rr            .word kbSetBreak
0000DDr 3               
0000DDr 3               kbSetExtended:
0000DDr 3  AD rr rr         lda kb_control_byte
0000E0r 3  09 02            ora #KB_CONTROL_EXTENDED
0000E2r 3  8D rr rr         sta kb_control_byte
0000E5r 3  4C rr rr         jmp kbnull
0000E8r 3               
0000E8r 3               kbSetShifted:
0000E8r 3  AD rr rr         lda kb_control_byte
0000EBr 3  09 80            ora #KB_CONTROL_SHIFTED
0000EDr 3  8D rr rr         sta kb_control_byte
0000F0r 3  4C rr rr         jmp kbnull
0000F3r 3               
0000F3r 3               kbSetBreak:
0000F3r 3  AD rr rr         lda kb_control_byte
0000F6r 3  09 01            ora #KB_CONTROL_RELEASE
0000F8r 3  8D rr rr         sta kb_control_byte
0000FBr 3  4C rr rr         jmp kbnull
0000FEr 3               
0000FEr 3               kbnull:
0000FEr 3  A9 00            lda #$00
000100r 3  60               rts
000101r 3               
000101r 3               ; Initialize Keyboard driver
000101r 3               InitKeyboard:
000101r 3  E2 30            shortr
000103r 3  9C rr rr         stz kb_control_byte
000106r 3  9C rr rr         stz kb_byte
000109r 3               
000109r 3  9C rr rr         stz VIA1A_DIRECTION             ; read input
00010Cr 3  A9 82            lda #%10000010
00010Er 3  8D rr rr         sta VIA1_IER
000111r 3               
000111r 3  A9 00            lda #$00
000113r 3  8D rr rr         sta VIA1_PCR
000116r 3  C2 30            longr
000118r 3               
000118r 3  60               rts
000119r 3               
000119r 3               
000119r 3               
000119r 2               .include "../drivers/ra8875/ra8875.asm"     ; include Driver for RA8875
000119r 3               .A8
000119r 3               .I8
000119r 3                   .include "ra8875.inc"
000119r 4               SPI_DEVICE_RA8875 = $04
000119r 4               
000119r 4               RA8875_DATAWRITE = $00
000119r 4               RA8875_DATAREAD = $40
000119r 4               RA8875_CMDWRITE = $80
000119r 4               
000119r 4               RA8875_SYSR = $10
000119r 4               RA8875_SYSR_8BPP = $00
000119r 4               RA8875_SYSR_16BPP = $0C
000119r 4               RA8875_SYSR_MCU8 = $00
000119r 4               
000119r 4               RA8875_PLLC1 = $88
000119r 4               RA8875_PLLC1_PLLDIV2 = $80
000119r 4               RA8875_PLLC1_PLLDIV1 = $00
000119r 4               
000119r 4               RA8875_PLLC2 = $89
000119r 4               RA8875_PLLC2_DIV4 = $02
000119r 4               
000119r 4               RA8875_PCSR = $04
000119r 4               RA8875_PCSR_PDATL = $80
000119r 4               RA8875_PCSR_2CLK = $01
000119r 4               
000119r 4               RA8875_HDWR = $14
000119r 4               RA8875_HNDFTR = $15
000119r 4               RA8875_HNDFTR_DE_HIGH = $00
000119r 4               RA8875_HNDR = $16
000119r 4               RA8875_HSTR = $17
000119r 4               RA8875_HPWR = $18
000119r 4               RA8875_HPWR_LOW = $00
000119r 4               
000119r 4               RA8875_VDHR0 = $19
000119r 4               RA8875_VDHR1 = $1A
000119r 4               RA8875_VNDR0 = $1B
000119r 4               RA8875_VNDR1 = $1C
000119r 4               RA8875_VSTR0 = $1D
000119r 4               RA8875_VSTR1 = $1E
000119r 4               RA8875_VPWR = $1F
000119r 4               RA8875_VPWR_LOW = $00
000119r 4               
000119r 4               RA8875_HSAW0 = $30
000119r 4               RA8875_HSAW1 = $31
000119r 4               RA8875_HEAW0 = $34
000119r 4               RA8875_HEAW1 = $35
000119r 4               
000119r 4               RA8875_VSAW0 = $32
000119r 4               RA8875_VSAW1 = $33
000119r 4               RA8875_VEAW0 = $36
000119r 4               RA8875_VEAW1 = $37
000119r 4               
000119r 4               RA8875_FGCR0 = $63
000119r 4               RA8875_FGCR1 = $64
000119r 4               RA8875_FGCR2 = $65
000119r 4               
000119r 4               RA8875_MCLR = $8E
000119r 4               RA8875_MCLR_START = $80
000119r 4               RA8875_MCLR_FULL = $00
000119r 4               
000119r 4               RA8875_PWRR = $01
000119r 4               RA8875_PWRR_NORMAL = $00
000119r 4               RA8875_PWRR_DISPON = $80
000119r 4               
000119r 4               RA8875_P1CR = $8A
000119r 4               RA8875_P1CR_ENABLE = $80
000119r 4               RA8875_PWM_CLK_DIV1024 = $0A
000119r 4               RA8875_PWM_CLK_DIV8 = $03
000119r 4               
000119r 4               RA8875_P1DCR = $8B
000119r 4               
000119r 4               RA8875_MWCR0 = $40
000119r 4               RA8875_MWCR0_TXTMODE = $80
000119r 4               
000119r 4               RA8875_MWCR0_CURSOR = $40
000119r 4               RA8875_MWCR0_BLINK = $20
000119r 4               
000119r 4               RA8875_F_CURXL = $2A
000119r 4               RA8875_F_CURXH = $2B
000119r 4               RA8875_F_CURYL = $2C
000119r 4               RA8875_F_CURYH = $2D
000119r 4               
000119r 4               RA8875_BTCR = $44
000119r 4               
000119r 4               RA8875_FNCR0 = $21
000119r 4               
000119r 4               RA8875_MRWC = $02
000119r 4               
000119r 4               RA8875_GPIOX = $C7
000119r 4               
000119r 4               
000119r 4               RA8875_WIDTH = 800
000119r 4               RA8875_HEIGHT = 480
000119r 4               RA8875_hsync_nondisp = 26
000119r 4               RA8875_hsync_start = 32
000119r 4               RA8875_hsync_pw = 96
000119r 4               RA8875_hsync_finetune = 0
000119r 4               RA8875_vsync_nondisp = 32
000119r 4               RA8875_vsync_start = 23
000119r 4               RA8875_vsync_pw = 2
000119r 4               
000119r 4               RA_1 = $20
000119r 4               RA_2 = $21
000119r 4               
000119r 3               
000119r 3               ; Write Data  destroy A
000119r 3               ; in
000119r 3               ;   A - Data
000119r 3               RA8875WriteData:
000119r 3  48               PHA
00011Ar 3  A9 04            LDA #SPI_DEVICE_RA8875
00011Cr 3  20 rr rr         JSR SpiDeviceSelect
00011Fr 3  A9 00            LDA #RA8875_DATAWRITE
000121r 3  20 rr rr         JSR SpiByte
000124r 3  68               PLA
000125r 3  20 rr rr         JSR SpiByte
000128r 3  20 rr rr         JSR SpiDeviceDeselect
00012Br 3  60               RTS
00012Cr 3               
00012Cr 3               ; Write Command  destroy A
00012Cr 3               ; in
00012Cr 3               ;   A - Data
00012Cr 3               RA8875WriteCommand:
00012Cr 3  48               PHA
00012Dr 3  A9 04            LDA #SPI_DEVICE_RA8875
00012Fr 3  20 rr rr         JSR SpiDeviceSelect
000132r 3  A9 80            LDA #RA8875_CMDWRITE
000134r 3  20 rr rr         JSR SpiByte
000137r 3  68               PLA
000138r 3  20 rr rr         JSR SpiByte
00013Br 3  20 rr rr         JSR SpiDeviceDeselect
00013Er 3  60               RTS
00013Fr 3               
00013Fr 3               ; Read Command  destroy A
00013Fr 3               ; in
00013Fr 3               ;   A - Register to read
00013Fr 3               ; out
00013Fr 3               ;   A - Data from register
00013Fr 3               RA8875ReadCommand:
00013Fr 3  20 rr rr         JSR RA8875WriteCommand
000142r 3  A9 04            LDA #SPI_DEVICE_RA8875
000144r 3  20 rr rr         JSR SpiDeviceSelect
000147r 3  A9 40            LDA #RA8875_DATAREAD
000149r 3  20 rr rr         JSR SpiByte
00014Cr 3  20 rr rr         JSR SpiByte
00014Fr 3  20 rr rr         JSR SpiDeviceDeselect
000152r 3  60               RTS
000153r 3               
000153r 3               ; Initialize the RA8875  destroy AX
000153r 3               InitRA8875:
000153r 3               
000153r 3               ; PLL settings
000153r 3  A9 88            LDA #RA8875_PLLC1
000155r 3  20 rr rr         JSR RA8875WriteCommand
000158r 3  A9 0A            LDA #(RA8875_PLLC1_PLLDIV1+10)
00015Ar 3  20 rr rr         JSR RA8875WriteData
00015Dr 3               
00015Dr 3  20 rr rr         JSR LongDelay
000160r 3               
000160r 3  A9 89            LDA #RA8875_PLLC2
000162r 3  20 rr rr         JSR RA8875WriteCommand
000165r 3  A9 02            LDA #RA8875_PLLC2_DIV4
000167r 3  20 rr rr         JSR RA8875WriteData
00016Ar 3               
00016Ar 3  20 rr rr         JSR LongDelay
00016Dr 3               ; Color mode  MCU size
00016Dr 3  A9 10            LDA #RA8875_SYSR
00016Fr 3  20 rr rr         JSR RA8875WriteCommand
000172r 3                   ; For 16 bit color
000172r 3                   ; LDA #(RA8875_SYSR_16BPP | RA8875_SYSR_MCU8)
000172r 3  A9 00            LDA #(RA8875_SYSR_8BPP | RA8875_SYSR_MCU8)
000174r 3  20 rr rr         JSR RA8875WriteData
000177r 3               
000177r 3  20 rr rr         JSR LongDelay
00017Ar 3               
00017Ar 3               ; Pixel clock
00017Ar 3  A9 04            LDA #RA8875_PCSR
00017Cr 3  20 rr rr         JSR RA8875WriteCommand
00017Fr 3  A9 81            LDA #(RA8875_PCSR_PDATL | RA8875_PCSR_2CLK)
000181r 3  20 rr rr         JSR RA8875WriteData
000184r 3               
000184r 3  20 rr rr         JSR LongDelay
000187r 3               
000187r 3               ; Horizontal settings
000187r 3  A9 14            LDA #RA8875_HDWR
000189r 3  20 rr rr         JSR RA8875WriteCommand
00018Cr 3  A9 63            LDA #((RA8875_WIDTH / 8) - 1)
00018Er 3  20 rr rr         JSR RA8875WriteData
000191r 3               
000191r 3  A9 15            LDA #RA8875_HNDFTR
000193r 3  20 rr rr         JSR RA8875WriteCommand
000196r 3  A9 00            LDA #(RA8875_HNDFTR_DE_HIGH + RA8875_hsync_finetune)
000198r 3  20 rr rr         JSR RA8875WriteData
00019Br 3               
00019Br 3  A9 16            LDA #RA8875_HNDR
00019Dr 3  20 rr rr         JSR RA8875WriteCommand
0001A0r 3  A9 03            LDA #((RA8875_hsync_nondisp - RA8875_hsync_finetune - 2) / 8)
0001A2r 3  20 rr rr         JSR RA8875WriteData
0001A5r 3               
0001A5r 3  A9 17            LDA #RA8875_HSTR
0001A7r 3  20 rr rr         JSR RA8875WriteCommand
0001AAr 3  A9 03            LDA #((RA8875_hsync_start / 8) - 1)
0001ACr 3  20 rr rr         JSR RA8875WriteData
0001AFr 3               
0001AFr 3  A9 18            LDA #RA8875_HPWR
0001B1r 3  20 rr rr         JSR RA8875WriteCommand
0001B4r 3  A9 0B            LDA #(RA8875_HPWR_LOW + ((RA8875_hsync_pw / 8) - 1))
0001B6r 3  20 rr rr         JSR RA8875WriteData
0001B9r 3               
0001B9r 3               ; Vertical settings
0001B9r 3  A9 19            LDA #RA8875_VDHR0
0001BBr 3  20 rr rr         JSR RA8875WriteCommand
0001BEr 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
0001C0r 3  20 rr rr         JSR RA8875WriteData
0001C3r 3               
0001C3r 3  A9 1A            LDA #RA8875_VDHR1
0001C5r 3  20 rr rr         JSR RA8875WriteCommand
0001C8r 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
0001CAr 3  20 rr rr         JSR RA8875WriteData
0001CDr 3               
0001CDr 3  A9 1B            LDA #RA8875_VNDR0
0001CFr 3  20 rr rr         JSR RA8875WriteCommand
0001D2r 3  A9 1F            LDA #(RA8875_vsync_nondisp - 1)
0001D4r 3  20 rr rr         JSR RA8875WriteData
0001D7r 3               
0001D7r 3  A9 1C            LDA #RA8875_VNDR1
0001D9r 3  20 rr rr         JSR RA8875WriteCommand
0001DCr 3  A9 00            LDA #(RA8875_vsync_nondisp >> 8)
0001DEr 3  20 rr rr         JSR RA8875WriteData
0001E1r 3               
0001E1r 3  A9 1D            LDA #RA8875_VSTR0
0001E3r 3  20 rr rr         JSR RA8875WriteCommand
0001E6r 3  A9 16            LDA #(RA8875_vsync_start - 1)
0001E8r 3  20 rr rr         JSR RA8875WriteData
0001EBr 3               
0001EBr 3  A9 1E            LDA #RA8875_VSTR1
0001EDr 3  20 rr rr         JSR RA8875WriteCommand
0001F0r 3  A9 00            LDA #(RA8875_vsync_start >> 8)
0001F2r 3  20 rr rr         JSR RA8875WriteData
0001F5r 3               
0001F5r 3  A9 1F            LDA #RA8875_VPWR
0001F7r 3  20 rr rr         JSR RA8875WriteCommand
0001FAr 3  A9 01            LDA #(RA8875_VPWR_LOW + RA8875_vsync_pw - 1)
0001FCr 3  20 rr rr         JSR RA8875WriteData
0001FFr 3               
0001FFr 3               ; Set active window X
0001FFr 3               
0001FFr 3  A9 30            LDA #RA8875_HSAW0
000201r 3  20 rr rr         JSR RA8875WriteCommand
000204r 3  A9 00            LDA #0
000206r 3  20 rr rr         JSR RA8875WriteData
000209r 3               
000209r 3  A9 31            LDA #RA8875_HSAW1
00020Br 3  20 rr rr         JSR RA8875WriteCommand
00020Er 3  A9 00            LDA #0
000210r 3  20 rr rr         JSR RA8875WriteData
000213r 3               
000213r 3  A9 34            LDA #RA8875_HEAW0
000215r 3  20 rr rr         JSR RA8875WriteCommand
000218r 3  A9 1F            LDA #((RA8875_WIDTH - 1) & $FF)
00021Ar 3  20 rr rr         JSR RA8875WriteData
00021Dr 3               
00021Dr 3  A9 35            LDA #RA8875_HEAW1
00021Fr 3  20 rr rr         JSR RA8875WriteCommand
000222r 3  A9 03            LDA #((RA8875_WIDTH - 1) >> 8)
000224r 3  20 rr rr         JSR RA8875WriteData
000227r 3               
000227r 3               ; Set active window Y
000227r 3               
000227r 3  A9 32            LDA #RA8875_VSAW0
000229r 3  20 rr rr         JSR RA8875WriteCommand
00022Cr 3  A9 00            LDA #0
00022Er 3  20 rr rr         JSR RA8875WriteData
000231r 3               
000231r 3  A9 33            LDA #RA8875_VSAW1
000233r 3  20 rr rr         JSR RA8875WriteCommand
000236r 3  A9 00            LDA #0
000238r 3  20 rr rr         JSR RA8875WriteData
00023Br 3               
00023Br 3  A9 36            LDA #RA8875_VEAW0
00023Dr 3  20 rr rr         JSR RA8875WriteCommand
000240r 3  A9 DF            LDA #((RA8875_HEIGHT - 1) & $FF)
000242r 3  20 rr rr         JSR RA8875WriteData
000245r 3               
000245r 3  A9 37            LDA #RA8875_VEAW1
000247r 3  20 rr rr         JSR RA8875WriteCommand
00024Ar 3  A9 01            LDA #((RA8875_HEIGHT - 1) >> 8)
00024Cr 3  20 rr rr         JSR RA8875WriteData
00024Fr 3               
00024Fr 3               ; Clear entire screen
00024Fr 3               
00024Fr 3  A9 8E            LDA #RA8875_MCLR
000251r 3  20 rr rr         JSR RA8875WriteCommand
000254r 3  A9 80            LDA #(RA8875_MCLR_START | RA8875_MCLR_FULL)
000256r 3  20 rr rr         JSR RA8875WriteData
000259r 3               
000259r 3  20 rr rr         JSR LongDelay
00025Cr 3               
00025Cr 3               ; Display on
00025Cr 3  A9 01            LDA #RA8875_PWRR
00025Er 3  20 rr rr         JSR RA8875WriteCommand
000261r 3               
000261r 3  A9 80            LDA #(RA8875_PWRR_NORMAL | RA8875_PWRR_DISPON)
000263r 3  20 rr rr         JSR RA8875WriteData
000266r 3               
000266r 3               ; GPIOX on    enable tft
000266r 3  A9 C7            LDA #RA8875_GPIOX
000268r 3  20 rr rr         JSR RA8875WriteCommand
00026Br 3  A9 01            LDA #1
00026Dr 3  20 rr rr         JSR RA8875WriteData
000270r 3               
000270r 3               
000270r 3               ; PWM1 Config backlight
000270r 3  A9 8A            LDA #RA8875_P1CR
000272r 3  20 rr rr         JSR RA8875WriteCommand
000275r 3  A9 8A            LDA #(RA8875_P1CR_ENABLE | (RA8875_PWM_CLK_DIV1024 & $F))
000277r 3  20 rr rr         JSR RA8875WriteData
00027Ar 3               
00027Ar 3               ; Backlight clock
00027Ar 3  A9 8B            LDA #RA8875_P1DCR
00027Cr 3  20 rr rr         JSR RA8875WriteCommand
00027Fr 3  A9 FF            LDA #255
000281r 3  20 rr rr         JSR RA8875WriteData
000284r 3               
000284r 3               ; Set text mode
000284r 3  20 rr rr         JSR RA8875_TextMode
000287r 3               
000287r 3  64 rr            STZ cursor_x
000289r 3               
000289r 3  64 rr            STZ cursor_x + 1
00028Br 3               
00028Br 3  64 rr            STZ cursor_y
00028Dr 3               
00028Dr 3  64 rr            STZ cursor_y + 1
00028Fr 3               
00028Fr 3  20 rr rr         JSR RA8875_SetTextCursor
000292r 3               
000292r 3  A9 FF            LDA #$FF
000294r 3  20 rr rr         JSR RA8875_SetForegroundColor
000297r 3               
000297r 3  60               RTS
000298r 3               
000298r 3               RA8875_CursorBlink:
000298r 3               
000298r 3  A9 40            LDA #RA8875_MWCR0
00029Ar 3  20 rr rr         JSR RA8875WriteCommand
00029Dr 3               
00029Dr 3  A9 C0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR)
00029Fr 3  20 rr rr         JSR RA8875WriteData
0002A2r 3               
0002A2r 3  A9 40            LDA #RA8875_MWCR0
0002A4r 3  20 rr rr         JSR RA8875WriteCommand
0002A7r 3               
0002A7r 3  A9 E0            LDA #(RA8875_MWCR0_TXTMODE | RA8875_MWCR0_CURSOR | RA8875_MWCR0_BLINK)
0002A9r 3  20 rr rr         JSR RA8875WriteData
0002ACr 3               
0002ACr 3  A9 44            LDA #RA8875_BTCR
0002AEr 3  20 rr rr         JSR RA8875WriteCommand
0002B1r 3               
0002B1r 3  A9 20            LDA #32                        ; Blink rate 1-255 1 is fast
0002B3r 3  20 rr rr         JSR RA8875WriteData
0002B6r 3               
0002B6r 3  60               RTS
0002B7r 3               
0002B7r 3               RA8875_CursorHide:
0002B7r 3               
0002B7r 3  A9 40            LDA #RA8875_MWCR0
0002B9r 3  20 rr rr         JSR RA8875WriteCommand
0002BCr 3               
0002BCr 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
0002BEr 3  20 rr rr         JSR RA8875WriteData
0002C1r 3               
0002C1r 3  60               RTS
0002C2r 3               
0002C2r 3               RA8875_GetTextCursorX:
0002C2r 3  A9 2B            LDA #RA8875_F_CURXH
0002C4r 3  20 rr rr         JSR RA8875ReadCommand
0002C7r 3  85 rr            STA cursor_x+1
0002C9r 3               
0002C9r 3  A9 2A            LDA #RA8875_F_CURXL
0002CBr 3  20 rr rr         JSR RA8875ReadCommand
0002CEr 3  85 rr            STA cursor_x
0002D0r 3               
0002D0r 3  60               RTS
0002D1r 3               
0002D1r 3               RA8875_GetTextCursorY:
0002D1r 3  A9 2D            LDA #RA8875_F_CURYH
0002D3r 3  20 rr rr         JSR RA8875ReadCommand
0002D6r 3  85 rr            STA cursor_y+1
0002D8r 3               
0002D8r 3  A9 2C            LDA #RA8875_F_CURYL
0002DAr 3  20 rr rr         JSR RA8875ReadCommand
0002DDr 3  85 rr            STA cursor_y
0002DFr 3               
0002DFr 3  60               RTS
0002E0r 3               
0002E0r 3               RA8875_SetTextCursor:
0002E0r 3  A9 2A            LDA #RA8875_F_CURXL
0002E2r 3  20 rr rr         JSR RA8875WriteCommand
0002E5r 3  A5 rr            LDA cursor_x
0002E7r 3  20 rr rr         JSR RA8875WriteData
0002EAr 3               
0002EAr 3  A9 2B            LDA #RA8875_F_CURXH
0002ECr 3  20 rr rr         JSR RA8875WriteCommand
0002EFr 3  A5 rr            LDA cursor_x+1
0002F1r 3  20 rr rr         JSR RA8875WriteData
0002F4r 3               
0002F4r 3               
0002F4r 3  A9 2C            LDA #RA8875_F_CURYL
0002F6r 3  20 rr rr         JSR RA8875WriteCommand
0002F9r 3  A5 rr            LDA cursor_y
0002FBr 3  20 rr rr         JSR RA8875WriteData
0002FEr 3               
0002FEr 3  A9 2D            LDA #RA8875_F_CURYH
000300r 3  20 rr rr         JSR RA8875WriteCommand
000303r 3  A5 rr            LDA cursor_y+1
000305r 3  20 rr rr         JSR RA8875WriteData
000308r 3               
000308r 3  60               RTS
000309r 3               
000309r 3               
000309r 3               RA8875_TextMode:
000309r 3  A9 40            LDA #RA8875_MWCR0
00030Br 3  20 rr rr         JSR RA8875WriteCommand
00030Er 3               
00030Er 3  A9 80            LDA #RA8875_MWCR0_TXTMODE
000310r 3  20 rr rr         JSR RA8875WriteData
000313r 3               
000313r 3               ; select internal font
000313r 3  A9 21            LDA #RA8875_FNCR0
000315r 3  20 rr rr         JSR RA8875WriteCommand
000318r 3               
000318r 3  A9 00            LDA #0
00031Ar 3  20 rr rr         JSR RA8875WriteData
00031Dr 3               
00031Dr 3  60               RTS
00031Er 3               
00031Er 3               RA8875_SetForegroundColor:
00031Er 3  48               PHA
00031Fr 3  48               PHA
000320r 3                       ; writeCommand(0x63);
000320r 3                       ; writeData((foreColor & 0xf800) >> 11);
000320r 3                       ; writeCommand(0x64);
000320r 3                       ; writeData((foreColor & 0x07e0) >> 5);
000320r 3                       ; writeCommand(0x65);
000320r 3                       ; writeData((foreColor & 0x001f));
000320r 3  A9 65            LDA #RA8875_FGCR2
000322r 3  20 rr rr         JSR RA8875WriteCommand
000325r 3               
000325r 3  68               PLA
000326r 3  20 rr rr         JSR RA8875WriteData
000329r 3               
000329r 3  A9 64            LDA #RA8875_FGCR1
00032Br 3  20 rr rr         JSR RA8875WriteCommand
00032Er 3               
00032Er 3  68               PLA
00032Fr 3  4A               lsr
000330r 3  4A               lsr
000331r 3  48               PHA
000332r 3               
000332r 3  20 rr rr         JSR RA8875WriteData
000335r 3               
000335r 3  A9 63            LDA #RA8875_FGCR0
000337r 3  20 rr rr         JSR RA8875WriteCommand
00033Ar 3               
00033Ar 3  68               PLA
00033Br 3               
00033Br 3  4A               lsr
00033Cr 3  4A               lsr
00033Dr 3  4A               lsr
00033Er 3               
00033Er 3  20 rr rr         JSR RA8875WriteData
000341r 3  60               RTS
000342r 3               
000342r 3               ; Handle a single char
000342r 3               RA8875_SingleChar:
000342r 3  C9 20            CMP #$20                        ; $20 or greater
000344r 3  B0 18            BCS RA8875_WriteStringChar      ; then print character
000346r 3  C9 0A            CMP #$0A                        ; Compare to 0x0A   line feed
000348r 3  D0 04            BNE @check_1                    ; != 0x0A
00034Ar 3  20 rr rr         JSR RA8875_ControlLineFeed      ; Handle as line feed
00034Dr 3  60               rts                             ; Do not print
00034Er 3               @check_1:
00034Er 3  C9 0D            CMP #$0D                         ; Compare to 0D   carriage return
000350r 3  D0 04            BNE @check_2                      ; != 0x0D
000352r 3  20 rr rr         JSR RA8875_ControlCarriageReturn ; handle as carriage return
000355r 3  60               rts                             ; Do not print
000356r 3               @check_2:
000356r 3  C9 1B            CMP #$1B                         ; Compare to 1B   escape
000358r 3  D0 04            BNE RA8875_WriteStringChar       ; != 0x1B
00035Ar 3  20 rr rr         JSR RA8875_ControlEscape         ; handle as escape sequence
00035Dr 3  60               rts                             ; Do not print
00035Er 3               
00035Er 3               RA8875_WriteStringChar:
00035Er 3  20 rr rr         JSR RA8875WriteData
000361r 3  60               RTS
000362r 3               
000362r 3               RA8875_ControlLineFeed:
000362r 3  64 rr            STZ cursor_x                    ; Control char LINE FEED
000364r 3  64 rr            STZ cursor_x+1
000366r 3  20 rr rr         JSR RA8875_GetTextCursorY
000369r 3  18               CLC
00036Ar 3  69 10            ADC #16
00036Cr 3  85 rr            STA cursor_y
00036Er 3  A5 rr            LDA cursor_y+1
000370r 3  69 00            ADC #$00
000372r 3  85 rr            STA cursor_y+1
000374r 3                   ; TODO: It overflows here. Needs two bytes to handle cursor value
000374r 3  20 rr rr         JSR RA8875_SetTextCursor
000377r 3  A9 02            LDA #RA8875_MRWC
000379r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
00037Cr 3  60               RTS
00037Dr 3               
00037Dr 3               RA8875_ControlCarriageReturn:
00037Dr 3  64 rr            STZ cursor_x                    ; Control char LINE FEED
00037Fr 3  64 rr            STZ cursor_x+1
000381r 3  20 rr rr         JSR RA8875_GetTextCursorY
000384r 3  20 rr rr         JSR RA8875_SetTextCursor
000387r 3  A9 02            LDA #RA8875_MRWC
000389r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
00038Cr 3  60               RTS
00038Dr 3               
00038Dr 3               RA8875_ControlEscape:
00038Dr 3  C8               INY                             ; Look at next character
00038Er 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
000390r 3  F0 2C            BEQ SkipControl
000392r 3  C9 5B            CMP #$5B                        ; CSI look for [
000394r 3  D0 28            BNE SkipControl
000396r 3  C8               INY                             ; Next char
000397r 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
000399r 3               
000399r 3  C9 33            CMP #$33
00039Br 3  D0 1B            BNE @not_foreground
00039Dr 3  C8               INY                             ; Next char
00039Er 3  B3 0C            LDA (RA8875_WriteString16_ARG+4,s),Y
0003A0r 3  C9 37            CMP #$37
0003A2r 3  D0 08            BNE @nextcol1
0003A4r 3  A9 FF            LDA #%11111111
0003A6r 3  20 rr rr         jsr RA8875_SetForegroundColor
0003A9r 3  4C rr rr         jmp @done
0003ACr 3               @nextcol1:
0003ACr 3  C9 32            CMP #$32
0003AEr 3  D0 08            BNE @nextcol2
0003B0r 3  A9 1C            LDA #%00011100
0003B2r 3  20 rr rr         jsr RA8875_SetForegroundColor
0003B5r 3  4C rr rr         jmp @done
0003B8r 3               @nextcol2:
0003B8r 3               
0003B8r 3               @not_foreground:
0003B8r 3               
0003B8r 3               
0003B8r 3               @done:
0003B8r 3  C8               INY
0003B9r 3               
0003B9r 3  98               tya
0003BAr 3  22 rr rr rr      jsl RA8875_WriteHex
0003BEr 3               
0003BEr 3               
0003BEr 3               SkipControl:
0003BEr 3  60               RTS
0003BFr 3               
0003BFr 2               .include "../drivers/ra8875/ra8875_api.asm" ; include API for RA8875
0003BFr 3               .A16
0003BFr 3               .I16
0003BFr 3               RA8875_WriteString16_ARG = 8
0003BFr 3               RA8875_WriteString16:
0003BFr 3  5A               PHY
0003C0r 3  DA               PHX
0003C1r 3  E2 30            shortr
0003C3r 3  A0 00            LDY #$00
0003C5r 3  A9 02            LDA #RA8875_MRWC
0003C7r 3  20 rr rr         JSR RA8875WriteCommand          ; write to memory write register
0003CAr 3               RA8875_WriteString16_0:
0003CAr 3  B3 08            LDA (RA8875_WriteString16_ARG,s),Y
0003CCr 3  F0 06            BEQ RA8875_WriteStringEnd16       ; Is char 0 then end write
0003CEr 3               
0003CEr 3  20 rr rr         JSR RA8875_SingleChar           ; Handle single character
0003D1r 3               
0003D1r 3  C8               INY
0003D2r 3  D0 F6            BNE RA8875_WriteString16_0
0003D4r 3               RA8875_WriteStringEnd16:
0003D4r 3  C2 30            longr
0003D6r 3  FA               PLX
0003D7r 3  7A               PLY
0003D8r 3  6B               RTL
0003D9r 3               
0003D9r 3               .A8
0003D9r 3               .I8
0003D9r 3               RA8875_WriteChar:
0003D9r 3  DA               PHX
0003DAr 3  F0 0A            BEQ RA8875_WriteCharEnd         ; Is char 0 then end write
0003DCr 3  48               PHA
0003DDr 3  A9 02            LDA #RA8875_MRWC
0003DFr 3  20 rr rr         JSR RA8875WriteCommand
0003E2r 3  68               PLA
0003E3r 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
0003E6r 3               RA8875_WriteCharEnd:
0003E6r 3  FA               PLX
0003E7r 3  6B               RTL
0003E8r 3               
0003E8r 3               .A16
0003E8r 3               .I16
0003E8r 3               RA8875_WriteChar16:
0003E8r 3  F0 12            BEQ RA8875_WriteChar16End         ; Is char 0 then end write
0003EAr 3  48               PHA
0003EBr 3  E2 30            shortr
0003EDr 3  A9 02            LDA #RA8875_MRWC
0003EFr 3  20 rr rr         JSR RA8875WriteCommand
0003F2r 3  C2 30            longr
0003F4r 3  68               PLA
0003F5r 3  E2 30            shortr
0003F7r 3  20 rr rr         JSR RA8875_SingleChar           ; handle single character
0003FAr 3  C2 30            longr
0003FCr 3               RA8875_WriteChar16End:
0003FCr 3  6B               RTL
0003FDr 3               
0003FDr 3               .A8
0003FDr 3               .I8
0003FDr 3               RA8875_WriteNumber:
0003FDr 3  A2 FF            LDX #$FF
0003FFr 3  38               SEC                             ; Prepare for subtraction
000400r 3               RA8875_WriteNumber100:
000400r 3  E8               INX
000401r 3  E9 64            SBC #100
000403r 3  B0 FB            BCS RA8875_WriteNumber100       ; Count how many 100s
000405r 3  69 64            ADC #100
000407r 3  20 rr rr         JSR RA8875_WriteDigit           ; Print the 100s
00040Ar 3  A2 FF            LDX #$FF
00040Cr 3  38               SEC                             ; Prepare for subtraction
00040Dr 3               RA8875_WriteNumber10:
00040Dr 3  E8               INX
00040Er 3  E9 0A            SBC #10
000410r 3  B0 FB            BCS RA8875_WriteNumber10         ; Count how many 10s
000412r 3  69 0A            ADC #10
000414r 3  20 rr rr         JSR RA8875_WriteDigit            ; Print the 10s
000417r 3  AA               TAX                              ; Pass 1s into X
000418r 3               RA8875_WriteDigit:
000418r 3  48               PHA
000419r 3  8A               TXA                             ; Save A pass digit to A
00041Ar 3  09 30            ORA #$30                        ; ASCII 0
00041Cr 3  22 rr rr rr      JSL RA8875_WriteChar            ; Convert to character and print it
000420r 3  68               PLA
000421r 3  60               RTS                             ; Restore A and return
000422r 3               
000422r 3               .A8
000422r 3               .I8
000422r 3               RA8875_WriteHex:
000422r 3  48               PHA                     ; Save A for LSD.
000423r 3  4A               LSR
000424r 3  4A               LSR
000425r 3  4A               LSR                     ; MSD to LSD position.
000426r 3  4A               LSR
000427r 3  22 rr rr rr      JSL RA8875_WriteHex1    ; Output hex digit.
00042Br 3  68               PLA                     ; Restore A.
00042Cr 3               RA8875_WriteHex1:
00042Cr 3  DA               PHX
00042Dr 3  48               PHA
00042Er 3  18               CLC
00042Fr 3  29 0F            AND #$0F                ; Mask LSD for hex print.
000431r 3  09 30            ORA #$30                ; Add "0".
000433r 3  C9 3A            CMP #$3A                ; Digit?
000435r 3  90 02            BCC RA8875_WriteHex2    ; Yes, output it.
000437r 3  69 06            ADC #$06                ; Add offset for letter.
000439r 3               RA8875_WriteHex2:
000439r 3  22 rr rr rr      JSL RA8875_WriteChar
00043Dr 3  68               PLA
00043Er 3  FA               PLX
00043Fr 3  6B               RTL                    ; Return.
000440r 3               
000440r 3               .A16
000440r 3               .I16
000440r 3               RA8875_WriteHex16:
000440r 3  E2 30            shortr
000442r 3  EB               xba                     ; switch high and low A
000443r 3  22 rr rr rr      jsl RA8875_WriteHex     ; print first byte
000447r 3  EB               xba                     ; switch high and low A
000448r 3  22 rr rr rr      jsl RA8875_WriteHex     ; print second byte
00044Cr 3  C2 30            longr
00044Er 3  6B               RTL
00044Fr 3               
00044Fr 2               
00044Fr 2               .include "ramtest.asm"
00044Fr 3               .RODATA
0003A4r 3               
0003A4r 3  52 75 6E 6E  ram_test_start: .asciiz "Running ram test"
0003A8r 3  69 6E 67 20  
0003ACr 3  72 61 6D 20  
0003B5r 3               
0003B5r 3               
0003B5r 3               .code
00044Fr 3               .A16
00044Fr 3               .I16
00044Fr 3               RamTestRun:
00044Fr 3  F4 rr rr 22      write ram_test_start
000453r 3  rr rr rr 68  
000457r 3               
000457r 3  E2 30            shortr
000459r 3               ; Single cell at $0300
000459r 3  A9 42            LDA #$42
00045Br 3  8D 00 03         STA $0300
00045Er 3  A9 00            LDA #$00
000460r 3  AD 00 03         LDA $0300
000463r 3  C9 42            CMP #$42
000465r 3  D0 3E            BNE RamTestFail
000467r 3               ; Single cell at $0300
000467r 3  A9 66            LDA #$66
000469r 3  8D 98 98         STA $9898
00046Cr 3  A9 00            LDA #$00
00046Er 3  AD 98 98         LDA $9898
000471r 3  C9 66            CMP #$66
000473r 3  D0 30            BNE RamTestFail
000475r 3               
000475r 3               ; All of zero page
000475r 3  A2 00            ldx #0                ;ZP location index
000477r 3  8A               txa                   ;initialize
000478r 3  38               sec                   ;test "bit"
000479r 3               
000479r 3               loop0010:
000479r 3  95 00            sta $00,x             ;clear test cell
00047Br 3  A0 09            ldy #9                ;bit shift iterations
00047Dr 3               
00047Dr 3               loop0020:
00047Dr 3  36 00            rol $00,x             ;rotate away
00047Fr 3  88               dey                   ;step counter
000480r 3  D0 FB            bne loop0020          ;not done
000482r 3               
000482r 3  90 21            bcc RamTestFail       ;RAM defective...abort
000484r 3               
000484r 3  B5 00            lda $0,x              ;any "stuck" bits?
000486r 3  D0 1D            bne RamTestFail       ;yes, bad RAM...abort
000488r 3               
000488r 3  E8               inx                   ;we done?
000489r 3  D0 EE            bne loop0010          ;no, do next
00048Br 3               
00048Br 3  C2 30            longr
00048Dr 3  F4 rr rr 22      write ok_string
000491r 3  rr rr rr 68  
000495r 3               
000495r 3  A9 00 00         lda #$00
000498r 3  A2 00 00         ldx #$0000
00049Br 3               @loop:
00049Br 3  9D 00 A0         sta $A000,x
00049Er 3               
00049Er 3  E8               inx
00049Fr 3  E0 00 10         cpx #$1000
0004A2r 3  D0 F7            bne @loop
0004A4r 3               
0004A4r 3  6B               RTL
0004A5r 3               
0004A5r 3               
0004A5r 3               RamTestFail:
0004A5r 3  C2 30            longr
0004A7r 3  F4 rr rr 22      write fail_string
0004ABr 3  rr rr rr 68  
0004AFr 3  6B               RTL
0004B0r 3               
0004B0r 2               .include "ramtest_wide.asm"
0004B0r 3               .RODATA
0003B5r 3               
0003B5r 3  52 75 6E 6E  ram_test_start_wide: .asciiz "Running wide ram test"
0003B9r 3  69 6E 67 20  
0003BDr 3  77 69 64 65  
0003CBr 3  2E 00        ram_test_progress: .asciiz "."
0003CDr 3  31 36 20 62  bit16_registers: .asciiz "16 bit registers"
0003D1r 3  69 74 20 72  
0003D5r 3  65 67 69 73  
0003DEr 3               
0003DEr 3               .code
0004B0r 3               .A16
0004B0r 3               .I16
0004B0r 3               RamTestWideRun:
0004B0r 3               
0004B0r 3  F4 rr rr 22      write ram_test_start_wide
0004B4r 3  rr rr rr 68  
0004B8r 3               
0004B8r 3  E2 30            shortr
0004BAr 3  A9 42            LDA #$42
0004BCr 3  8F 34 12 01      STA $011234
0004C0r 3  A9 11            LDA #$11
0004C2r 3  AF 34 12 01      LDA $011234
0004C6r 3  C9 42            CMP #$42
0004C8r 3  D0 2F            BNE RamTestFailWide
0004CAr 3  A9 F6            LDA #$F6
0004CCr 3  8F 34 12 02      STA $021234
0004D0r 3  AF 34 12 01      LDA $011234
0004D4r 3  C9 42            CMP #$42
0004D6r 3  D0 21            BNE RamTestFailWide
0004D8r 3  AF 34 12 02      LDA $021234
0004DCr 3  C9 F6            CMP #$F6
0004DEr 3  D0 19            BNE RamTestFailWide
0004E0r 3  A9 55            LDA #$55
0004E2r 3  8F 34 12 03      STA $031234
0004E6r 3  AF 34 12 01      LDA $011234
0004EAr 3  C9 42            CMP #$42
0004ECr 3  D0 0B            BNE RamTestFailWide
0004EEr 3               
0004EEr 3  C2 30            longr
0004F0r 3  F4 rr rr 22      write ok_string
0004F4r 3  rr rr rr 68  
0004F8r 3  60               rts
0004F9r 3               
0004F9r 3               RamTestFailWide:
0004F9r 3  C2 30            longr
0004FBr 3  F4 rr rr 22      write fail_string
0004FFr 3  rr rr rr 68  
000503r 3  60               rts
000504r 3               
000504r 3               .A16
000504r 3               .I16
000504r 3               RamTestWideRegistersRun:
000504r 3               
000504r 3  F4 rr rr 22      write bit16_registers
000508r 3  rr rr rr 68  
00050Cr 3               
00050Cr 3  A9 34 12         LDA #$1234
00050Fr 3  8F 00 04 04      STA $040400
000513r 3  A9 76 98         LDA #$9876
000516r 3  AF 00 04 04      LDA $040400
00051Ar 3  C9 34 12         CMP #$1234
00051Dr 3  D0 DA            BNE RamTestFailWide
00051Fr 3               
00051Fr 3  F4 rr rr 22      write ok_string
000523r 3  rr rr rr 68  
000527r 3               
000527r 3  60               rts
000528r 3               
000528r 2               
000528r 2               .A8
000528r 2               .I8
000528r 2               InitBIOS:
000528r 2  20 rr rr         JSR InitSPI
00052Br 2  20 rr rr         JSR InitRA8875
00052Er 2  20 rr rr         JSR InitKeyboard
000531r 2               
000531r 2               
000531r 2               ; switch out of emulation mode
000531r 2  18               clc
000532r 2  FB               xce
000533r 2               
000533r 2  C2 30            longr
000535r 2                   ;pea test_bios
000535r 2                   ;jsl RA8875_WriteString16
000535r 2                   ;pla
000535r 2               
000535r 2                   ;shortr
000535r 2                   ;LDA #%01101111
000535r 2                   ;jsr RA8875_SetForegroundColor
000535r 2                   ;longr
000535r 2               
000535r 2               
000535r 2               ;    write welcome_logo1
000535r 2               ;    write welcome_logo2
000535r 2               ;    write welcome_logo3
000535r 2               ;    write welcome_logo4
000535r 2               ;    write welcome_logo5
000535r 2               ;    write welcome_logo6
000535r 2               ;    write welcome_logo7
000535r 2               
000535r 2                   ;lda #$0A
000535r 2                   ;jsl RA8875_WriteChar16
000535r 2               
000535r 2                   ;shortr
000535r 2                   ;LDA #%11111111
000535r 2                   ;jsr RA8875_SetForegroundColor
000535r 2                   ;longr
000535r 2               
000535r 2  22 rr rr rr      JSL RamTestRun
000539r 2               
000539r 2               
000539r 2               
000539r 2  20 rr rr         jsr RamTestWideRegistersRun
00053Cr 2  20 rr rr         jsr RamTestWideRun
00053Fr 2               
00053Fr 2                   ;shortr
00053Fr 2                   ;LDA #%00011100
00053Fr 2                   ;jsr RA8875_SetForegroundColor
00053Fr 2  C2 30            longr
000541r 2               
000541r 2  F4 rr rr 22      write bios_init
000545r 2  rr rr rr 68  
000549r 2  F4 rr rr 22      write ok_string
00054Dr 2  rr rr rr 68  
000551r 2               
000551r 2                   ;shortr
000551r 2                   ;LDA #%11111111
000551r 2                   ;jsr RA8875_SetForegroundColor
000551r 2                   ;longr
000551r 2               
000551r 2  F4 rr rr 22      write ansi_string
000555r 2  rr rr rr 68  
000559r 2               
000559r 2  E2 30            shortr
00055Br 2  60               RTS
00055Cr 2               
00055Cr 1               .include "kernel/kernel.asm"
00055Cr 2               
00055Cr 2               .include "tasks.asm"
00055Cr 3               NUMBER_OF_TASKS = 16
00055Cr 3               
00055Cr 3               TASK_STATUS_NONE = 0
00055Cr 3               TASK_STATUS_RUNNING = 1
00055Cr 3               TASK_STATUS_RUNNABLE = 2
00055Cr 3               
00055Cr 3               .include "scheduler.asm"
00055Cr 4               ; IRQ steps
00055Cr 4               ; Push to the stack:
00055Cr 4               ;
00055Cr 4               ;   PB  - Program Bank           - 1 byte
00055Cr 4               ;   PCH - Program Counter High   - 1 byte
00055Cr 4               ;   PCL - Program Counter Low    - 1 byte
00055Cr 4               ;   SR  - Status Register        - 1 byte
00055Cr 4               ;
00055Cr 4               ; PB set to $00
00055Cr 4               
00055Cr 4               
00055Cr 4               ; Stacks and direct page
00055Cr 4               ; 0000-00FF : kernel direct page
00055Cr 4               ; 0100-01FF : kernel stack
00055Cr 4               
00055Cr 4               ; 9000-90FF : task 0  - direct
00055Cr 4               ; A000-A0FF : task 0  - stack
00055Cr 4               ; 9F00-9FFF : task 16 - direct
00055Cr 4               ; AF00-AFFF : task 16 - stack
00055Cr 4               
00055Cr 4               
00055Cr 4               ; NOT USED! THIS IS A TEST:
00055Cr 4               ; 0000-00FF : kernel direct page
00055Cr 4               ; 0100-01FF : kernel stack
00055Cr 4               ; 0200-02FF : task 1 DP
00055Cr 4               ; 0300-03FF : task 1 stack
00055Cr 4               
00055Cr 4               ; B000-C000 : I/O
00055Cr 4               InterruptStackY = 3+1
00055Cr 4               InterruptStackX = InterruptStackY+2
00055Cr 4               InterruptStackA = InterruptStackX+2
00055Cr 4               InterruptDP = InterruptStackA+2
00055Cr 4               InterruptDB = InterruptDP+2
00055Cr 4               InterruptStatusRegister = InterruptDB+1
00055Cr 4               InterruptPC = InterruptStatusRegister+1
00055Cr 4               InterruptPB = InterruptPC+2
00055Cr 4               
00055Cr 4               .SEGMENT "RAM"
000002r 4               
000002r 4  xx           SchedulerCount: .res 1
000003r 4               
000003r 4  xx xx        TimerCounter: .res 2
000005r 4               
000005r 4  xx           TempStackReturnBank: .res 1
000006r 4  xx xx        TempStackReturnPC: .res 2
000008r 4               
000008r 4               .code
00055Cr 4               
00055Cr 4               
00055Cr 4               
00055Cr 4               .A8
00055Cr 4               .I8
00055Cr 4               Scheduler_NextTask:
00055Cr 4  78               sei
00055Dr 4               
00055Dr 4  AE rr rr         ldx ActiveTask
000560r 4               
000560r 4  BD rr rr         lda TaskStatus,x
000563r 4  C9 01            cmp #TASK_STATUS_RUNNING
000565r 4  D0 51            bne @loop
000567r 4               
000567r 4  A9 02            lda #TASK_STATUS_RUNNABLE               ; if running then set to runnable
000569r 4  9D rr rr         sta TaskStatus,x
00056Cr 4               
00056Cr 4               ; save current task stage
00056Cr 4                   ;longr
00056Cr 4                   ;write task_save_old
00056Cr 4                   ;write test_string
00056Cr 4                   ;shortr
00056Cr 4               
00056Cr 4                   ;ldx ActiveTask
00056Cr 4                   ;txa
00056Cr 4                   ;jsl RA8875_WriteHex
00056Cr 4                   ;lda #' '
00056Cr 4                   ;jsl RA8875_WriteChar
00056Cr 4                   ;lda #$A
00056Cr 4                   ;jsl RA8875_WriteChar
00056Cr 4                   ;lda #'o'
00056Cr 4                   ;jsl RA8875_WriteChar
00056Cr 4                   ;longr
00056Cr 4                   ;jsl DumpStack
00056Cr 4                   ;shortr
00056Cr 4  AE rr rr         ldx ActiveTask
00056Fr 4  A3 0C            lda InterruptDB,s
000571r 4  9D rr rr         sta TaskDataBank,x
000574r 4               
000574r 4  A3 10            lda InterruptPB,s
000576r 4  9D rr rr         sta TaskProgramBank,x
000579r 4               
000579r 4  A3 0D            lda InterruptStatusRegister,s
00057Br 4  9D rr rr         sta TaskStatusRegister,x
00057Er 4               
00057Er 4               
00057Er 4               
00057Er 4                   ;ldx ActiveTask
00057Er 4  8A               txa
00057Fr 4  0A               asl
000580r 4  AA               tax
000581r 4               
000581r 4               ; SAVE STACK POINTER
000581r 4  C2 20            longa
000583r 4  3B               tsc                                 ; A = stack pointer
000584r 4  18               clc
000585r 4  69 10 00         adc #InterruptPB                 ; A = stack pointer - ...
000588r 4  9D rr rr         sta TaskStackPointer,x
00058Br 4  E2 20            shorta
00058Dr 4               
00058Dr 4                   ; lda TaskStackPointer+1,x
00058Dr 4                   ; jsl RA8875_WriteHex
00058Dr 4                   ; lda #' '
00058Dr 4                   ; jsl RA8875_WriteChar
00058Dr 4                   ; lda TaskStackPointer,x
00058Dr 4                   ; jsl RA8875_WriteHex
00058Dr 4                   ; lda #' '
00058Dr 4                   ; jsl RA8875_WriteChar
00058Dr 4               
00058Dr 4  A3 08            lda InterruptStackA,s
00058Fr 4  9D rr rr         sta TaskA,x
000592r 4  A3 09            lda InterruptStackA+1,s
000594r 4  9D rr rr         sta TaskA+1,x
000597r 4  A3 06            lda InterruptStackX,s
000599r 4  9D rr rr         sta TaskX,x
00059Cr 4  A3 07            lda InterruptStackX+1,s
00059Er 4  9D rr rr         sta TaskX+1,x
0005A1r 4  A3 04            lda InterruptStackY,s
0005A3r 4  9D rr rr         sta TaskY,x
0005A6r 4  A3 05            lda InterruptStackY+1,s
0005A8r 4  9D rr rr         sta TaskY+1,x
0005ABr 4               
0005ABr 4               
0005ABr 4  A3 0E            lda InterruptPC,s
0005ADr 4  9D rr rr         sta TaskProgramPointer,x
0005B0r 4               
0005B0r 4                   ;jsl RA8875_WriteHex
0005B0r 4                   ;lda #' '
0005B0r 4                   ;jsl RA8875_WriteChar
0005B0r 4               
0005B0r 4  A3 0F            lda InterruptPC+1,s
0005B2r 4  9D rr rr         sta TaskProgramPointer+1,x
0005B5r 4               
0005B5r 4                   ;jsl RA8875_WriteHex
0005B5r 4                   ;lda #$A
0005B5r 4                   ;jsl RA8875_WriteChar
0005B5r 4               
0005B5r 4  AE rr rr         ldx ActiveTask
0005B8r 4               @loop:
0005B8r 4  E8               inx
0005B9r 4  E0 10            cpx #NUMBER_OF_TASKS
0005BBr 4  D0 05            bne @fine
0005BDr 4  A2 FF            ldx #$FF     ; will roll to 0 on inx
0005BFr 4  4C rr rr         jmp @loop
0005C2r 4               @fine:
0005C2r 4               
0005C2r 4  BD rr rr         lda TaskStatus,x
0005C5r 4               
0005C5r 4  F0 F1            beq @loop
0005C7r 4               
0005C7r 4  C9 02            cmp #TASK_STATUS_RUNNABLE
0005C9r 4  F0 1C            beq @task_switch
0005CBr 4  C9 01            cmp #TASK_STATUS_RUNNING
0005CDr 4  F0 15            beq @goreturn
0005CFr 4               
0005CFr 4  22 rr rr rr      jsl RA8875_WriteHex
0005D3r 4  8A               txa
0005D4r 4  22 rr rr rr      jsl RA8875_WriteHex
0005D8r 4  C2 30            longr
0005DAr 4  F4 rr rr 22      write task_unknown_status
0005DEr 4  rr rr rr 68  
0005E2r 4  E2 30            shortr
0005E4r 4               @goreturn:
0005E4r 4  4C rr rr         jmp @return
0005E7r 4               
0005E7r 4               @task_switch:
0005E7r 4               
0005E7r 4               
0005E7r 4               ; SWITCH TO NEW TASK
0005E7r 4               
0005E7r 4  8E rr rr         stx ActiveTask
0005EAr 4               
0005EAr 4                ;   lda #$A
0005EAr 4                ;   jsl RA8875_WriteChar
0005EAr 4                ;   lda #'s'
0005EAr 4               ;    jsl RA8875_WriteChar
0005EAr 4               ;    longr
0005EAr 4               ;    jsl DumpStack
0005EAr 4               ;    shortr
0005EAr 4               
0005EAr 4               
0005EAr 4                   ;longr
0005EAr 4                   ;write task_switching_task
0005EAr 4                   ;shortr
0005EAr 4               
0005EAr 4                   ;ldx ActiveTask
0005EAr 4                   ;txa
0005EAr 4                   ;jsl RA8875_WriteHex
0005EAr 4                   ;lda #' '
0005EAr 4                   ;jsl RA8875_WriteChar
0005EAr 4               
0005EAr 4                   ;ldx ActiveTask
0005EAr 4               
0005EAr 4  A9 01            lda #TASK_STATUS_RUNNING               ; if running then set to runnable
0005ECr 4  9D rr rr         sta TaskStatus,x
0005EFr 4               
0005EFr 4  A3 01            lda 1,s
0005F1r 4  8D rr rr         sta TempStackReturnPC+1
0005F4r 4  A3 02            lda 2,s
0005F6r 4  8D rr rr         sta TempStackReturnPC
0005F9r 4  A3 03            lda 3,s
0005FBr 4  8D rr rr         sta TempStackReturnBank
0005FEr 4               ; Set up stack
0005FEr 4  8A               txa
0005FFr 4  0A               asl
000600r 4  AA               tax
000601r 4  C2 30            longr
000603r 4  BD rr rr         lda TaskStackPointer,x
000606r 4  18               clc
000607r 4  E9 0F 00         sbc #InterruptPB-1
00060Ar 4  1B               tcs
00060Br 4  E2 30            shortr
00060Dr 4               
00060Dr 4  AD rr rr         lda TempStackReturnPC+1
000610r 4  83 01            sta 1,s
000612r 4  AD rr rr         lda TempStackReturnPC
000615r 4  83 02            sta 2,s
000617r 4  AD rr rr         lda TempStackReturnBank
00061Ar 4  83 03            sta 3,s
00061Cr 4               
00061Cr 4  AE rr rr         ldx ActiveTask
00061Fr 4               
00061Fr 4  BD rr rr         lda TaskProgramBank,x
000622r 4  83 10            sta InterruptPB,s
000624r 4               
000624r 4  BD rr rr         lda TaskDataBank,x
000627r 4  83 0C            sta InterruptDB,s
000629r 4               
000629r 4  BD rr rr         lda TaskStatusRegister,x
00062Cr 4  83 0D            sta InterruptStatusRegister,s
00062Er 4               
00062Er 4  8A               txa
00062Fr 4  0A               asl
000630r 4  AA               tax
000631r 4               ; Set Direct Page to $9x00
000631r 4  AD rr rr         lda ActiveTask
000634r 4  18               clc
000635r 4  69 90            adc #$90                                ; A = $9x
000637r 4               
000637r 4  95 0A            sta InterruptDP,x
000639r 4                   ;jsl RA8875_WriteHex
000639r 4               
000639r 4               ; Set registers
000639r 4  BD rr rr         lda TaskA,x
00063Cr 4  83 08            sta InterruptStackA,s
00063Er 4  BD rr rr         lda TaskA+1,x
000641r 4  83 09            sta InterruptStackA+1,s
000643r 4  BD rr rr         lda TaskY,x
000646r 4  83 04            sta InterruptStackY,s
000648r 4  BD rr rr         lda TaskY+1,x
00064Br 4  83 05            sta InterruptStackY+1,s
00064Dr 4  BD rr rr         lda TaskX,x
000650r 4  83 06            sta InterruptStackX,s
000652r 4  BD rr rr         lda TaskX+1,x
000655r 4  83 07            sta InterruptStackX+1,s
000657r 4               
000657r 4               
000657r 4  BD rr rr         lda TaskProgramPointer+1,x
00065Ar 4  83 0F            sta InterruptPC+1,s
00065Cr 4                   ;jsl RA8875_WriteHex
00065Cr 4               
00065Cr 4  BD rr rr         lda TaskProgramPointer,x
00065Fr 4  83 0E            sta InterruptPC,s
000661r 4                   ;jsl RA8875_WriteHex
000661r 4               
000661r 4                   ;lda #$A
000661r 4                   ;jsl RA8875_WriteChar
000661r 4               
000661r 4                   ;lda #'n'
000661r 4                   ;jsl RA8875_WriteChar
000661r 4                   ;longr
000661r 4                   ;jsl DumpStack
000661r 4                   ;shortr
000661r 4                   ;lda #$A
000661r 4                   ;jsl RA8875_WriteChar
000661r 4  4C rr rr         jmp @return
000664r 4               
000664r 4               
000664r 4               @return:
000664r 4               
000664r 4               
000664r 4  58               cli
000665r 4  6B               rtl
000666r 4               
000666r 4               
000666r 4               .A16
000666r 4               .I16
000666r 4               InitScheduler:
000666r 4               
000666r 4  9C rr rr         stz TimerCounter   ; set interrupt timer counter to 0
000669r 4               
000669r 4  A9 FF FF         lda #$FFFF
00066Cr 4  8D rr rr         sta VIA1_T1CL
00066Fr 4               
00066Fr 4  E2 30            shortr
000671r 4  AD rr rr         lda  VIA1_ACR       ; Clear the ACR's bit that
000674r 4  29 7F            AND  #%01111111      ; tells T1 to toggle PB7 upon time-out, and
000676r 4  09 40            ORA  #%01000000      ; set the bit that tells T1 to automatically
000678r 4  8D rr rr         STA  VIA1_ACR       ; produce an interrupt at every time-out and
00067Br 4                                       ; just reload from the latches and keep going.
00067Br 4  A9 C0            LDA  #%11000000
00067Dr 4  8D rr rr         STA  VIA1_IER       ; Enable the T1 interrupt in the VIA.
000680r 4               
000680r 4  C2 30            longr
000682r 4  60               rts
000683r 4               
000683r 3               .include "tasks.inc"
000683r 4               
000683r 4               .RODATA
0003DEr 4               
0003DEr 4  4E 6F 20 66  task_no_free_slot:           .asciiz "No free task slot!\n"
0003E2r 4  72 65 65 20  
0003E6r 4  74 61 73 6B  
0003F2r 4  55 6E 6B 6E  task_unknown_status:           .asciiz "Unknown task status!\n"
0003F6r 4  6F 77 6E 20  
0003FAr 4  74 61 73 6B  
000408r 4  4E 65 77 3A  task_switching_task:           .asciiz "New: "
00040Cr 4  20 00        
00040Er 4  4F 6C 64 3A  task_save_old:               .asciiz "Old: "
000412r 4  20 00        
000414r 4               
000414r 3               
000414r 3               .SEGMENT "RAM"
000008r 3               
000008r 3  xx           KernelSp: .res 1
000009r 3  xx           ActiveTask: .res 1
00000Ar 3  xx xx xx xx  TaskStatus: .res NUMBER_OF_TASKS
00000Er 3  xx xx xx xx  
000012r 3  xx xx xx xx  
00001Ar 3  xx xx xx xx  TaskStackPointer: .res NUMBER_OF_TASKS * 2
00001Er 3  xx xx xx xx  
000022r 3  xx xx xx xx  
00003Ar 3  xx xx xx xx  TaskDataBank: .res NUMBER_OF_TASKS
00003Er 3  xx xx xx xx  
000042r 3  xx xx xx xx  
00004Ar 3  xx xx xx xx  TaskProgramBank: .res NUMBER_OF_TASKS
00004Er 3  xx xx xx xx  
000052r 3  xx xx xx xx  
00005Ar 3  xx xx xx xx  TaskProgramPointer: .res NUMBER_OF_TASKS * 2
00005Er 3  xx xx xx xx  
000062r 3  xx xx xx xx  
00007Ar 3  xx xx xx xx  TaskStatusRegister: .res NUMBER_OF_TASKS
00007Er 3  xx xx xx xx  
000082r 3  xx xx xx xx  
00008Ar 3  xx xx xx xx  TaskA: .res NUMBER_OF_TASKS * 2
00008Er 3  xx xx xx xx  
000092r 3  xx xx xx xx  
0000AAr 3  xx xx xx xx  TaskX: .res NUMBER_OF_TASKS * 2
0000AEr 3  xx xx xx xx  
0000B2r 3  xx xx xx xx  
0000CAr 3  xx xx xx xx  TaskY: .res NUMBER_OF_TASKS * 2
0000CEr 3  xx xx xx xx  
0000D2r 3  xx xx xx xx  
0000EAr 3               
0000EAr 3               .SEGMENT "TASK"
000000r 3               ; marked as used
000000r 3               
000000r 3               
000000r 3               .code
000683r 3               
000683r 3               ; Initialize tasks
000683r 3               .A16
000683r 3               .I16
000683r 3               InitTasks:
000683r 3  E2 30            shortr
000685r 3  A2 10            ldx #NUMBER_OF_TASKS
000687r 3               @clrloop:
000687r 3  CA               dex
000688r 3  9E rr rr         stz TaskStatus,x
00068Br 3  9E rr rr         stz TaskStatusRegister,x
00068Er 3  9E rr rr         stz TaskProgramBank,x
000691r 3  9E rr rr         stz TaskDataBank,x
000694r 3  C2 30            longr
000696r 3  9E rr rr         stz TaskStackPointer, x
000699r 3  9E rr rr         stz TaskProgramPointer, x
00069Cr 3  9E rr rr         stz TaskA, x
00069Fr 3  9E rr rr         stz TaskX, x
0006A2r 3  9E rr rr         stz TaskY, x
0006A5r 3  E2 30            shortr
0006A7r 3  D0 DE        bne @clrloop
0006A9r 3               
0006A9r 3  A9 FF            lda #$FF
0006ABr 3  8D rr rr         sta ActiveTask
0006AEr 3               
0006AEr 3  C2 30            longr
0006B0r 3  60               rts
0006B1r 3               
0006B1r 3               ; Spawn a new task
0006B1r 3               
0006B1r 3               TaskSpawnArg_Addr = 1+3+6      ; jsl 3 bytes return
0006B1r 3               .A16
0006B1r 3               .I16
0006B1r 3               TaskSpawn:
0006B1r 3  48               pha
0006B2r 3  DA               phx
0006B3r 3  5A               phy
0006B4r 3  E2 30            shortr
0006B6r 3  20 rr rr         jsr TaskFindUnusedTask
0006B9r 3  B0 39            bcs @no_unused_tasks
0006BBr 3               
0006BBr 3                   ;txa
0006BBr 3                   ;jsl RA8875_WriteHex
0006BBr 3               
0006BBr 3               
0006BBr 3  A9 02            lda #TASK_STATUS_RUNNABLE
0006BDr 3  9D rr rr         sta TaskStatus,x
0006C0r 3               
0006C0r 3  A3 0C            lda TaskSpawnArg_Addr+2,s
0006C2r 3  9D rr rr         sta TaskProgramBank,x
0006C5r 3               
0006C5r 3  8A               txa
0006C6r 3  A8               tay
0006C7r 3  0A               asl
0006C8r 3  AA               tax
0006C9r 3  98               tya
0006CAr 3  18               clc
0006CBr 3  69 A0            adc #$A0
0006CDr 3  9D rr rr         sta TaskStackPointer+1,x
0006D0r 3  A9 FF            lda #$FF
0006D2r 3  9D rr rr         sta TaskStackPointer,x            ; Stack pointer: $AxFF
0006D5r 3               
0006D5r 3               
0006D5r 3  A3 0A            lda TaskSpawnArg_Addr,s
0006D7r 3  9D rr rr         sta TaskProgramPointer,x
0006DAr 3               
0006DAr 3  A3 0B            lda TaskSpawnArg_Addr+1,s
0006DCr 3  9D rr rr         sta TaskProgramPointer+1,x
0006DFr 3               
0006DFr 3               
0006DFr 3  9E rr rr         stz TaskA,x
0006E2r 3  9E rr rr         stz TaskA+1,x
0006E5r 3  9E rr rr         stz TaskY,x
0006E8r 3  9E rr rr         stz TaskY+1,x
0006EBr 3  9E rr rr         stz TaskX,x
0006EEr 3  9E rr rr         stz TaskX+1,x
0006F1r 3               
0006F1r 3               
0006F1r 3  4C rr rr         jmp @return
0006F4r 3               
0006F4r 3               @no_unused_tasks:
0006F4r 3  C2 30            longr
0006F6r 3  F4 rr rr 22      write task_no_free_slot
0006FAr 3  rr rr rr 68  
0006FEr 3  4C rr rr         jmp @return
000701r 3               @return:
000701r 3  C2 30            longr
000703r 3  7A               ply
000704r 3  FA               plx
000705r 3  68               pla
000706r 3  6B               rtl
000707r 3               
000707r 3               ; Find task slot no used
000707r 3               ; slot returned in x
000707r 3               ; carry set if error
000707r 3               .A8
000707r 3               .I8
000707r 3               TaskFindUnusedTask:
000707r 3  48               pha
000708r 3  A2 00            ldx #0
00070Ar 3               @loop:
00070Ar 3  BD rr rr         lda TaskStatus,x
00070Dr 3  F0 09            beq @found
00070Fr 3  E8               inx
000710r 3  E0 10            cpx #NUMBER_OF_TASKS         ; Reach end of tasks list?
000712r 3  D0 F6        bne @loop
000714r 3  38               sec
000715r 3  4C rr rr         jmp @return
000718r 3               @found:
000718r 3  18               clc
000719r 3               @return:
000719r 3  68               pla
00071Ar 3  60               rts
00071Br 3               
00071Br 2               .include "interrupt.asm"
00071Br 3               .code
00071Br 3               .A16
00071Br 3               .I16
00071Br 3               InterruptVector:
00071Br 3  8B               phb                   ;save DB - data bank
00071Cr 3  0B               phd                   ;save DP - direct page
00071Dr 3  C2 30            longr                 ;select 16 bit registers
00071Fr 3  48               pha                   ;save .C
000720r 3  DA               phx                   ;save .X
000721r 3  5A               phy                   ;save .Y
000722r 3               
000722r 3  E2 30            shortr
000724r 3               
000724r 3  AD rr rr         lda VIA1_IFR
000727r 3  2D rr rr         and VIA1_IER            ; zero those that were not allowed to pull IRQ down.
00072Ar 3  0A               asl ; timer 1
00072Br 3  30 0A            bmi  InterruptTimer1
00072Dr 3  0A               asl ; timer 2
00072Er 3  0A               asl ; cb1
00072Fr 3  0A               asl ; cb2
000730r 3  0A               asl ; shift reg
000731r 3  0A               asl ; ca1
000732r 3               
000732r 3  30 22            bmi InterruptKB
000734r 3               
000734r 3               
000734r 3               
000734r 3  4C rr rr         jmp crti
000737r 3               
000737r 3               InterruptTimer1:
000737r 3  2C rr rr         bit VIA1_T1CL
00073Ar 3  EE rr rr         inc TimerCounter
00073Dr 3  D0 03            BNE @lowcnt    ; Branch to end if the low byte didn't roll over to 00.
00073Fr 3  EE rr rr         inc TimerCounter+1
000742r 3               @lowcnt:
000742r 3  EE rr rr         inc SchedulerCount
000745r 3  AD rr rr         lda SchedulerCount
000748r 3  C9 30            cmp #$30
00074Ar 3  D0 07            bne @noschedule
00074Cr 3  9C rr rr         stz SchedulerCount
00074Fr 3  22 rr rr rr      jsl Scheduler_NextTask
000753r 3               @noschedule:
000753r 3               
000753r 3  4C rr rr         jmp crti
000756r 3               
000756r 3               InterruptKB:
000756r 3  20 rr rr         jsr InterruptKeyboard
000759r 3               
000759r 3               crti:
000759r 3  C2 30            longr
00075Br 3  7A               ply                   ;restore .Y
00075Cr 3  FA               plx                   ;restore .X
00075Dr 3  68               pla                   ;restore .C
00075Er 3  2B               pld                   ;restore DP
00075Fr 3  AB               plb                   ;restore DB
000760r 3  40               rti                   ;resume foreground task
000761r 3               
000761r 2               .include "streams.asm"
000761r 3               
000761r 3               NUMBER_OF_STREAMS = 3           ; Number of streams
000761r 3               SIZE_OF_STREAM = 16             ; Number of bytes per stream
000761r 3               
000761r 3               STREAM_STDIN = 0
000761r 3               
000761r 3               .SEGMENT "RAM"
0000EAr 3               
0000EAr 3               StreamLookupHead:
0000EAr 3  xx xx xx         .res NUMBER_OF_STREAMS
0000EDr 3               StreamLookupTail:
0000EDr 3  xx xx xx         .res NUMBER_OF_STREAMS
0000F0r 3               StreamData:
0000F0r 3  xx xx xx xx      .res SIZE_OF_STREAM * NUMBER_OF_STREAMS
0000F4r 3  xx xx xx xx  
0000F8r 3  xx xx xx xx  
000120r 3               
000120r 3               .code
000761r 3               
000761r 3               ; Initialize streams
000761r 3               ; Zeroes out head, tail, data
000761r 3               .A16
000761r 3               .I16
000761r 3               InitStreams:
000761r 3  E2 30            shortr
000763r 3  A2 03            ldx #NUMBER_OF_STREAMS
000765r 3               @clrloop:
000765r 3  CA               dex
000766r 3  9E rr rr         stz StreamLookupHead, x
000769r 3  9E rr rr         stz StreamLookupTail, x
00076Cr 3               
00076Cr 3  D0 F7            bne @clrloop
00076Er 3  A2 10            ldx #SIZE_OF_STREAM
000770r 3               @clrloop2:
000770r 3  CA               dex
000771r 3  9E rr rr         stz StreamData, x
000774r 3  9E rr rr         stz StreamData+SIZE_OF_STREAM, x
000777r 3  9E rr rr         stz StreamData+SIZE_OF_STREAM+SIZE_OF_STREAM, x
00077Ar 3               
00077Ar 3               
00077Ar 3  D0 F4            bne @clrloop2
00077Cr 3               
00077Cr 3  C2 30            longr
00077Er 3  60               rts
00077Fr 3               
00077Fr 3               ; Put byte to stream
00077Fr 3               ; in:
00077Fr 3               ;   A - byte to put
00077Fr 3               ;   X - stream id
00077Fr 3               ; out:
00077Fr 3               .A8
00077Fr 3               .I8
00077Fr 3               StreamPutC:
00077Fr 3  48               pha
000780r 3  78               sei
000781r 3  BC rr rr         ldy StreamLookupTail,x      ; fetch current tail
000784r 3  5A               phy                         ; stack: [tail]
000785r 3               
000785r 3  BC rr rr         ldy StreamLookupHead,x      ; fetch current head
000788r 3  5A               phy                         ; stack: [tail, head]
000789r 3               
000789r 3  DA               phx                         ; stack: [tail, head, stream id]
00078Ar 3  48               pha                         ; stack: [tail, head, stream id, A-byte]
00078Br 3  8A               txa
00078Cr 3               
00078Cr 3  0A               asl                         ; *  2
00078Dr 3  0A               asl                         ; *  4
00078Er 3  0A               asl                         ; *  8
00078Fr 3  0A               asl                         ; * 16
000790r 3  63 03            adc 3,s                     ; + head_offset
000792r 3  AA               tax                         ; X = X * 16 + head_offset
000793r 3               
000793r 3  68               pla                         ; stack: [tail, head, stream id], a = A-byte
000794r 3               
000794r 3  9D rr rr         sta StreamData,x            ; Store byte in stream
000797r 3               
000797r 3               ; increment head_offset
000797r 3  FA               plx                         ; stack: [tail, head], x=stream id
000798r 3  7A               ply                         ; stack: [tail], y = head
000799r 3  C8               iny                         ; increment head
00079Ar 3  98               tya
00079Br 3               
00079Br 3  C9 10            cmp #SIZE_OF_STREAM         ; head overflow?
00079Dr 3  D0 02            bne @checktail
00079Fr 3  A9 00            lda #0
0007A1r 3               @checktail:
0007A1r 3  9D rr rr         sta StreamLookupHead,x      ; store head
0007A4r 3               
0007A4r 3               ; this is untested.
0007A4r 3               ; if the stream wraps around
0007A4r 3  C3 01            cmp 1,s                     ; is head == stack[1]/tail?
0007A6r 3  D0 09            bne @tailnothead
0007A8r 3  7A               ply                         ; if yes increment tail
0007A9r 3  C8               iny
0007AAr 3  98               tya
0007ABr 3  9D rr rr         sta StreamLookupTail,x
0007AEr 3  4C rr rr         jmp @done
0007B1r 3               
0007B1r 3               
0007B1r 3               @tailnothead:
0007B1r 3  FA               plx ; clear tail from stack. not used pt
0007B2r 3               @done:
0007B2r 3  58               cli
0007B3r 3  68               pla
0007B4r 3  6B               rtl
0007B5r 3               
0007B5r 3               ; Get byte from stream
0007B5r 3               ; in:
0007B5r 3               ;   X - stream id
0007B5r 3               ; out:
0007B5r 3               ;   A: read byte
0007B5r 3               ;       0: nothing
0007B5r 3               ;       x: read byte
0007B5r 3               .A8
0007B5r 3               .I8
0007B5r 3               StreamGetC:
0007B5r 3  78               sei
0007B6r 3  BD rr rr         lda StreamLookupTail,x
0007B9r 3  DD rr rr         cmp StreamLookupHead,x
0007BCr 3  D0 05            bne @readc                  ; tail !== head
0007BEr 3  A9 00            lda #0                      ; set A to 0 (nothing read)
0007C0r 3  4C rr rr         jmp @done
0007C3r 3               @readc:
0007C3r 3               
0007C3r 3  48               pha                         ; s:[tail]
0007C4r 3  18               clc
0007C5r 3  69 01            adc #1                      ; tail = tail + 1
0007C7r 3  C9 10            cmp #SIZE_OF_STREAM         ; tail === 16?
0007C9r 3  D0 02            bne @savetail               ; if not skip next
0007CBr 3  A9 00            lda #0                      ; tail = 0
0007CDr 3               @savetail:
0007CDr 3  9D rr rr         sta StreamLookupTail,x      ; save tail
0007D0r 3               
0007D0r 3  8A               txa
0007D1r 3               
0007D1r 3  0A               asl                         ; *  2
0007D2r 3  0A               asl                         ; *  4
0007D3r 3  0A               asl                         ; *  8
0007D4r 3  0A               asl                         ; * 16
0007D5r 3  63 01            adc 1,s                     ; + tail_offset
0007D7r 3  AA               tax                         ; X = X * 16 + tail_offset
0007D8r 3  7A               ply                         ; s:[]
0007D9r 3               
0007D9r 3  BD rr rr         lda StreamData,x
0007DCr 3               
0007DCr 3               @done:
0007DCr 3  58               cli
0007DDr 3  6B               rtl
0007DEr 3               
0007DEr 2               
0007DEr 2               .A16
0007DEr 2               .I16
0007DEr 2               InitKernel:
0007DEr 2  20 rr rr         jsr InitTasks
0007E1r 2                   ;write init_kernel_tasks_done
0007E1r 2  20 rr rr         jsr InitScheduler
0007E4r 2                   ;write init_kernel_scheduler_done
0007E4r 2  20 rr rr         jsr InitStreams
0007E7r 2                   ;write init_kernel_streams_done
0007E7r 2                   ;write init_kernel_done
0007E7r 2  60               rts
0007E8r 2               ;;;
0007E8r 2               ; Long Delay
0007E8r 2               ;;;
0007E8r 2               
0007E8r 2               .A8
0007E8r 2               .I8
0007E8r 2               LongDelay:
0007E8r 2  A2 FF            ldx #$FF
0007EAr 2               LongDelayLoop1:
0007EAr 2  A0 FF            ldy #$FF
0007ECr 2               LongDelayLoop2:
0007ECr 2  88               dey
0007EDr 2  D0 FD            bne LongDelayLoop2
0007EFr 2  CA               dex
0007F0r 2  D0 F8            bne LongDelayLoop1
0007F2r 2  60               rts
0007F3r 2               
0007F3r 2               ;;;
0007F3r 2               ; Delay
0007F3r 2               ;;;
0007F3r 2               .A8
0007F3r 2               .I8
0007F3r 2               Delay:
0007F3r 2  A2 FF            ldx #$FF
0007F5r 2               DelayLoop1:
0007F5r 2  A0 FF            ldy #$FF
0007F7r 2               DelayLoop2:
0007F7r 2  88               dey
0007F8r 2  D0 FD            bne DelayLoop2
0007FAr 2  CA               dex
0007FBr 2  D0 F8            bne DelayLoop1
0007FDr 2  60               rts
0007FEr 2               
0007FEr 2               ;;;
0007FEr 2               ; Short Delay
0007FEr 2               ;;;
0007FEr 2               .A8
0007FEr 2               .I8
0007FEr 2  A2 AA        DelayShort:	ldx #$aa
000800r 2               DelayShortLoop1:
000800r 2  CA           	dex
000801r 2  D0 FD            bne DelayShortLoop1
000803r 2  60               rts
000804r 2               
000804r 1               
000804r 1               
000804r 1               .include "stdlib/stdlib.asm"
000804r 2               .include "stdlib.inc"
000804r 3               Std_StrLen = 1
000804r 3               Std_ReadNum = 2
000804r 3               
000804r 2               
000804r 2               .SEGMENT "STDLIB"
000000r 2               
000000r 2               StdLib:
000000r 2  C2 30            longr
000002r 2  48               pha
000003r 2  DA               phx
000004r 2  5A               phy
000005r 2               
000005r 2  29 FF 00         and #$00FF
000008r 2  3A               dec a                           ; 0 index function number
000009r 2  0A               asl a                           ; double function number to match words
00000Ar 2               
00000Ar 2  E2 30            shortr
00000Cr 2  AA               tax
00000Dr 2               
00000Dr 2  7C rr rr         jmp (StdLibTable,x)
000010r 2               
000010r 2               
000010r 2               StdLibTable:
000010r 2  rr rr            .word Stdlib_StrLen
000012r 2  rr rr            .word Stdlib_ReadNum
000014r 2               
000014r 2               
000014r 2               .include "strings.asm"
000014r 3               .RODATA
000414r 3  53 74 72 4C  	strlen: .asciiz "StrLen Called\n"
000418r 3  65 6E 20 43  
00041Cr 3  61 6C 6C 65  
000423r 3  52 65 61 64  	readnum: .asciiz "ReadNum Called\n"
000427r 3  4E 75 6D 20  
00042Br 3  43 61 6C 6C  
000433r 3               
000433r 3               .SEGMENT "STDLIB"
000014r 3               
000014r 3               
000014r 3               ;	STRING LENGTH
000014r 3               ; 		Return lenght of zero terminated string in A
000014r 3               Stdlib_StrLen:
000014r 3  18           	clc
000015r 3               
000015r 3  E2 30        	shortr
000017r 3               
000017r 3  A0 00        	ldy #0
000019r 3               @next:
000019r 3  B3 0A        	lda (args_start,s),y
00001Br 3  F0 04        	beq @result
00001Dr 3  C8           	iny
00001Er 3  4C rr rr     	jmp @next
000021r 3               @result:
000021r 3  98           	tya
000022r 3  83 05        	sta reg_a, s
000024r 3               
000024r 3               ;	shortr
000024r 3               ;	write strlen
000024r 3               
000024r 3  C2 30        	longr
000026r 3               
000026r 3  7A           	ply
000027r 3  FA           	plx
000028r 3  68           	pla
000029r 3               
000029r 3  6B           	rtl
00002Ar 3               
00002Ar 3               
00002Ar 3               
00002Ar 3               
00002Ar 3               ;	READ NUMBER
00002Ar 3               ; 		Return the decimal number read from string input
00002Ar 3               Stdlib_ReadNum_StackSize = 6
00002Ar 3               Stdlib_ReadNum_SingleDigit = 1
00002Ar 3               Stdlib_ReadNum_Result = Stdlib_ReadNum_SingleDigit + 2
00002Ar 3               Stdlib_ReadNum_LoopCounter = Stdlib_ReadNum_Result + 2
00002Ar 3               Stdlib_ReadNum:
00002Ar 3               ;	shortr
00002Ar 3               ;	write readnum
00002Ar 3               
00002Ar 3  C2 30        	longr
00002Cr 3  A2 00 00     	ldx #0
00002Fr 3  A0 00 00     	ldy #0
000032r 3  5A           	phy
000033r 3  5A           	phy
000034r 3  5A           	phy
000035r 3               @next:
000035r 3  E2 30        	shortr
000037r 3  B3 10        	lda (args_start+Stdlib_ReadNum_StackSize,s),y
000039r 3  C2 30        	longr
00003Br 3  C9 30 00     	cmp #$30
00003Er 3  90 09        	bcc @numend						; less than $30
000040r 3  C9 40 00     	cmp #$40
000043r 3  B0 04        	bcs @numend						; more than $39
000045r 3  C8           	iny
000046r 3  4C rr rr     	jmp @next
000049r 3               @numend:
000049r 3  98           	tya
00004Ar 3  F0 1F        	beq @done						; did we read 0 numbers? then end
00004Cr 3  88           	dey								; subtract 1 for the last number
00004Dr 3  E2 30        	shortr
00004Fr 3  B3 10        	lda (args_start+Stdlib_ReadNum_StackSize,s),y
000051r 3  C2 30        	longr
000053r 3  18           	clc
000054r 3  E9 2F 00     	sbc #$2F
000057r 3  83 01        	sta Stdlib_ReadNum_SingleDigit,s
000059r 3               
000059r 3  A3 05        	lda Stdlib_ReadNum_LoopCounter,s ; how many times to multiply 10?
00005Br 3  AA           	tax								; save in loop counter X
00005Cr 3               @mulloop:
00005Cr 3  8A           	txa								; look at loop counter X
00005Dr 3  F0 18        	beq @donemul					; if 0 then skip multiply 10
00005Fr 3  A3 01        	lda Stdlib_ReadNum_SingleDigit,s
000061r 3               
000061r 3  22 rr rr rr  	jsl MulTen
000065r 3  83 01        	sta Stdlib_ReadNum_SingleDigit,s
000067r 3               
000067r 3  CA           	dex								; derement loop counter X
000068r 3  4C rr rr     	jmp @mulloop
00006Br 3               
00006Br 3               @done:
00006Br 3  A3 03        	lda Stdlib_ReadNum_Result,s
00006Dr 3  83 0B        	sta reg_a+Stdlib_ReadNum_StackSize, s
00006Fr 3               
00006Fr 3  18           	clc
000070r 3               
000070r 3  7A           	ply ; clear temp stack
000071r 3  7A           	ply ; clear temp stack
000072r 3  7A           	ply ; clear temp stack
000073r 3               
000073r 3  7A           	ply
000074r 3  FA           	plx
000075r 3  68           	pla
000076r 3               
000076r 3               
000076r 3  6B           	rtl
000077r 3               
000077r 3               
000077r 3               @donemul:
000077r 3               
000077r 3  A3 01        	lda Stdlib_ReadNum_SingleDigit,s
000079r 3  18           	clc
00007Ar 3  63 03        	adc Stdlib_ReadNum_Result,s
00007Cr 3  83 03        	sta Stdlib_ReadNum_Result,s
00007Er 3               
00007Er 3  A3 05        	lda Stdlib_ReadNum_LoopCounter,s
000080r 3  18           	clc
000081r 3  69 01 00     	adc #1								; add one time multiply with 10
000084r 3  83 05        	sta Stdlib_ReadNum_LoopCounter,s
000086r 3  4C rr rr     	jmp @numend
000089r 3               
000089r 3               
000089r 3               MulTen:
000089r 3  5A           	phy
00008Ar 3  0A           	asl						;   *  2
00008Br 3  48           	pha
00008Cr 3  0A           	asl						;   *  4
00008Dr 3  0A           	asl		               	;   *  8
00008Er 3  18           	clc
00008Fr 3  63 01        	adc 1,s               	;   + (*2)
000091r 3  7A           	ply
000092r 3  7A           	ply
000093r 3  6B           	rtl
000094r 3               
000094r 2               
000094r 2               
000094r 2               ;    register stack frame...
000094r 2               ;
000094r 2               reg_y       =1                    ;16 bit .Y
000094r 2               reg_x       =reg_y+2              ;16 bit .X
000094r 2               reg_a       =reg_x+2              ;16 bit .A
000094r 2               reg_rtl     =reg_a+2              ;24 bit RTL address
000094r 2               
000094r 2               args_start  =reg_rtl+3
000094r 2               
000094r 2               ; ARGS      $10 args_start
000094r 2               ; RTS___    $07 reg_rts
000094r 2               ; AAAA      $05 reg_a
000094r 2               ; XXXX      $03 reg_x
000094r 2               ; YYYY      $01 reg_y
000094r 2               ;           current StackPointer
000094r 2               
000094r 1               
000094r 1               .include "programs/programs.inc"
000094r 2               
000094r 2               .include "shell.asm"
000094r 3               
000094r 3               
000094r 3               ShellExec:
000094r 3  E2 30            shortr
000096r 3               
000096r 3               
000096r 3  A9 3E            lda #'>'
000098r 3  22 rr rr rr      jsl RA8875_WriteChar
00009Cr 3               
00009Cr 3  A9 20            lda #' '
00009Er 3  22 rr rr rr      jsl RA8875_WriteChar
0000A2r 3               
0000A2r 3               
0000A2r 3               @loop:
0000A2r 3  A6 00            ldx STREAM_STDIN
0000A4r 3  22 rr rr rr      jsl StreamGetC
0000A8r 3  F0 F8            beq @loop                   ; Noting in stream (carry set)
0000AAr 3               
0000AAr 3  22 rr rr rr      jsl RA8875_WriteChar        ; Write to RA8875       - todo: write to stdout
0000AEr 3  4C rr rr         jmp @loop
0000B1r 3               
0000B1r 3  C2 30            longr
0000B3r 3  60               rts
0000B4r 3               
0000B4r 2               .include "clock.asm"
0000B4r 3               
0000B4r 3               .A16
0000B4r 3               .I16
0000B4r 3               ClockExec:
0000B4r 3  E2 30            shortr
0000B6r 3  A9 FF            lda #$FF
0000B8r 3  85 00            sta $0
0000BAr 3               @loop:
0000BAr 3                   ;lda TimerCounter+1
0000BAr 3                   ;cmp $0
0000BAr 3                   ;beq @loop
0000BAr 3               
0000BAr 3                   ;lda TimerCounter+1
0000BAr 3                   ;sta $0
0000BAr 3                   ;jsl RA8875_WriteHex
0000BAr 3                   ;lda TimerCounter
0000BAr 3                   ;jsl RA8875_WriteHex
0000BAr 3               
0000BAr 3  0B               phd
0000BBr 3               
0000BBr 3  A3 02            lda 2,s
0000BDr 3  22 rr rr rr      jsl RA8875_WriteHex
0000C1r 3  A3 01            lda 1,s
0000C3r 3  22 rr rr rr      jsl RA8875_WriteHex
0000C7r 3               
0000C7r 3  68               pla
0000C8r 3  68               pla
0000C9r 3               
0000C9r 3  20 rr rr         jsr LongDelay
0000CCr 3  20 rr rr         jsr LongDelay
0000CFr 3  20 rr rr         jsr LongDelay
0000D2r 3  20 rr rr         jsr LongDelay
0000D5r 3  20 rr rr         jsr LongDelay
0000D8r 3  20 rr rr         jsr LongDelay
0000DBr 3  20 rr rr         jsr LongDelay
0000DEr 3  20 rr rr         jsr LongDelay
0000E1r 3  20 rr rr         jsr LongDelay
0000E4r 3  20 rr rr         jsr LongDelay
0000E7r 3  20 rr rr         jsr LongDelay
0000EAr 3  20 rr rr         jsr LongDelay
0000EDr 3               
0000EDr 3               
0000EDr 3  4C rr rr         jmp @loop
0000F0r 3               
0000F0r 3  C2 30            longr
0000F2r 3  60               rts
0000F3r 3               
0000F3r 2               .include "diodeblink.asm"
0000F3r 3               .RODATA
000433r 3               
000433r 3  0D 28 2A 2D  running_diode_0: .asciiz "\r(*------)"
000437r 3  2D 2D 2D 2D  
00043Br 3  2D 29 00     
00043Er 3  0D 28 2D 2A  running_diode_1: .asciiz "\r(-*-----)"
000442r 3  2D 2D 2D 2D  
000446r 3  2D 29 00     
000449r 3  0D 28 2D 2D  running_diode_2: .asciiz "\r(--*----)"
00044Dr 3  2A 2D 2D 2D  
000451r 3  2D 29 00     
000454r 3  0D 28 2D 2D  running_diode_3: .asciiz "\r(---*---)"
000458r 3  2D 2A 2D 2D  
00045Cr 3  2D 29 00     
00045Fr 3  0D 28 2D 2D  running_diode_4: .asciiz "\r(----*--)"
000463r 3  2D 2D 2A 2D  
000467r 3  2D 29 00     
00046Ar 3  0D 28 2D 2D  running_diode_5: .asciiz "\r(-----*-)"
00046Er 3  2D 2D 2D 2A  
000472r 3  2D 29 00     
000475r 3  0D 28 2D 2D  running_diode_6: .asciiz "\r(------*)"
000479r 3  2D 2D 2D 2D  
00047Dr 3  2A 29 00     
000480r 3               
000480r 3               .code
000804r 3               .A16
000804r 3               .I16
000804r 3               LoaderExec:
000804r 3  A9 0A 00         lda #$0A
000807r 3  22 rr rr rr      jsl RA8875_WriteChar16          ; write new line
00080Br 3               
00080Br 3               LoaderLoop:
00080Br 3               
00080Br 3  F4 rr rr 22      write running_diode_0
00080Fr 3  rr rr rr 68  
000813r 3  20 rr rr         jsr LongDelayLoaderExec
000816r 3  F4 rr rr 22      write running_diode_1
00081Ar 3  rr rr rr 68  
00081Er 3  20 rr rr         jsr LongDelayLoaderExec
000821r 3  F4 rr rr 22      write running_diode_2
000825r 3  rr rr rr 68  
000829r 3  20 rr rr         jsr LongDelayLoaderExec
00082Cr 3  F4 rr rr 22      write running_diode_3
000830r 3  rr rr rr 68  
000834r 3  20 rr rr         jsr LongDelayLoaderExec
000837r 3  F4 rr rr 22      write running_diode_4
00083Br 3  rr rr rr 68  
00083Fr 3  20 rr rr         jsr LongDelayLoaderExec
000842r 3  F4 rr rr 22      write running_diode_5
000846r 3  rr rr rr 68  
00084Ar 3  20 rr rr         jsr LongDelayLoaderExec
00084Dr 3  F4 rr rr 22      write running_diode_6
000851r 3  rr rr rr 68  
000855r 3  20 rr rr         jsr LongDelayLoaderExec
000858r 3  F4 rr rr 22      write running_diode_5
00085Cr 3  rr rr rr 68  
000860r 3  20 rr rr         jsr LongDelayLoaderExec
000863r 3  F4 rr rr 22      write running_diode_4
000867r 3  rr rr rr 68  
00086Br 3  20 rr rr         jsr LongDelayLoaderExec
00086Er 3  F4 rr rr 22      write running_diode_3
000872r 3  rr rr rr 68  
000876r 3  20 rr rr         jsr LongDelayLoaderExec
000879r 3  F4 rr rr 22      write running_diode_2
00087Dr 3  rr rr rr 68  
000881r 3  20 rr rr         jsr LongDelayLoaderExec
000884r 3  F4 rr rr 22      write running_diode_1
000888r 3  rr rr rr 68  
00088Cr 3  20 rr rr         jsr LongDelayLoaderExec
00088Fr 3               
00088Fr 3  5C rr rr rr      JML LoaderLoop
000893r 3               
000893r 3               LongDelayLoaderExec:
000893r 3  E2 30            shortr
000895r 3  20 rr rr         jsr LogDelayLoader
000898r 3  20 rr rr         jsr LogDelayLoader
00089Br 3  20 rr rr         jsr LogDelayLoader
00089Er 3  C2 30            longr
0008A0r 3  60               rts
0008A1r 3               
0008A1r 3               .A8
0008A1r 3               .I8
0008A1r 3               LogDelayLoader:
0008A1r 3  A2 FF            ldx #$FF
0008A3r 3               LogDelayLoaderLoop1:
0008A3r 3  A0 FF            ldy #$FF
0008A5r 3               LogDelayLoaderLoop2:
0008A5r 3  88               dey
0008A6r 3  D0 FD            bne LogDelayLoaderLoop2
0008A8r 3  CA               dex
0008A9r 3  D0 F8            bne LogDelayLoaderLoop1
0008ABr 3  60               rts
0008ACr 3               
0008ACr 2               .include "dump.asm"
0008ACr 3               DumpExec:
0008ACr 3  20 rr rr         jsr RA8875_WriteHex
0008AFr 3  60               rts
0008B0r 3               
0008B0r 2               .include "dumpstack.asm"
0008B0r 3               .I16
0008B0r 3               .A16
0008B0r 3               DumpStack:
0008B0r 3  E2 30            shortr
0008B2r 3                 ;  lda 1,s           ;get mode
0008B2r 3                 ;  jsl RA8875_WriteHex
0008B2r 3                 ;  lda 2,s           ;get mode
0008B2r 3                 ;  jsl RA8875_WriteHex
0008B2r 3               
0008B2r 3                 ;  lda #' '
0008B2r 3                 ;  jsl RA8875_WriteChar
0008B2r 3               
0008B2r 3                   ;lda #$A
0008B2r 3                   ;jsl RA8875_WriteChar
0008B2r 3               
0008B2r 3  C2 30            longr
0008B4r 3  3B               tsc
0008B5r 3  18               clc
0008B6r 3  69 04 00         adc #4
0008B9r 3  22 rr rr rr      jsl RA8875_WriteHex16
0008BDr 3  E2 30            shortr
0008BFr 3  A9 20            lda #' '
0008C1r 3  22 rr rr rr      jsl RA8875_WriteChar
0008C5r 3               
0008C5r 3  C2 30            longr
0008C7r 3  3B               tsc
0008C8r 3  18               clc
0008C9r 3  69 06 00         adc #6
0008CCr 3  22 rr rr rr      jsl RA8875_WriteHex16
0008D0r 3  E2 30            shortr
0008D2r 3  A9 20            lda #' '
0008D4r 3  22 rr rr rr      jsl RA8875_WriteChar
0008D8r 3               
0008D8r 3  C2 30            longr
0008DAr 3  3B               tsc
0008DBr 3  18               clc
0008DCr 3  69 08 00         adc #8
0008DFr 3  22 rr rr rr      jsl RA8875_WriteHex16
0008E3r 3  E2 30            shortr
0008E5r 3  A9 20            lda #' '
0008E7r 3  22 rr rr rr      jsl RA8875_WriteChar
0008EBr 3               
0008EBr 3               
0008EBr 3  C2 30            longr
0008EDr 3  3B               tsc
0008EEr 3  18               clc
0008EFr 3  69 0A 00         adc #10
0008F2r 3  22 rr rr rr      jsl RA8875_WriteHex16
0008F6r 3  E2 30            shortr
0008F8r 3  A9 20            lda #' '
0008FAr 3  22 rr rr rr      jsl RA8875_WriteChar
0008FEr 3               
0008FEr 3               
0008FEr 3               
0008FEr 3  C2 30            longr
000900r 3  3B               tsc
000901r 3  18               clc
000902r 3  69 0C 00         adc #12
000905r 3  22 rr rr rr      jsl RA8875_WriteHex16
000909r 3  E2 30            shortr
00090Br 3  A9 20            lda #' '
00090Dr 3  22 rr rr rr      jsl RA8875_WriteChar
000911r 3  C2 30            longr
000913r 3  3B               tsc
000914r 3  18               clc
000915r 3  69 0E 00         adc #14
000918r 3  22 rr rr rr      jsl RA8875_WriteHex16
00091Cr 3  E2 30            shortr
00091Er 3  A9 20            lda #' '
000920r 3  22 rr rr rr      jsl RA8875_WriteChar
000924r 3               
000924r 3  C2 30            longr
000926r 3  3B               tsc
000927r 3  18               clc
000928r 3  69 10 00         adc #16
00092Br 3  22 rr rr rr      jsl RA8875_WriteHex16
00092Fr 3  E2 30            shortr
000931r 3  A9 20            lda #' '
000933r 3  22 rr rr rr      jsl RA8875_WriteChar
000937r 3               
000937r 3  C2 30            longr
000939r 3  3B               tsc
00093Ar 3  18               clc
00093Br 3  69 12 00         adc #18
00093Er 3  22 rr rr rr      jsl RA8875_WriteHex16
000942r 3  E2 30            shortr
000944r 3  A9 20            lda #' '
000946r 3  22 rr rr rr      jsl RA8875_WriteChar
00094Ar 3               
00094Ar 3  C2 30            longr
00094Cr 3  3B               tsc
00094Dr 3  18               clc
00094Er 3  69 14 00         adc #20
000951r 3  22 rr rr rr      jsl RA8875_WriteHex16
000955r 3  E2 30            shortr
000957r 3  A9 20            lda #' '
000959r 3  22 rr rr rr      jsl RA8875_WriteChar
00095Dr 3               
00095Dr 3  A9 0A            lda #$A
00095Fr 3  22 rr rr rr      jsl RA8875_WriteChar
000963r 3               
000963r 3               ; Skip the first two as they are DumpStack return
000963r 3  A3 04            lda 4,s           ;get mode
000965r 3  22 rr rr rr      jsl RA8875_WriteHex
000969r 3  A3 05            lda 5,s           ;get mode
00096Br 3  22 rr rr rr      jsl RA8875_WriteHex
00096Fr 3               
00096Fr 3  A9 20            lda #' '
000971r 3  22 rr rr rr      jsl RA8875_WriteChar
000975r 3               
000975r 3               
000975r 3  A3 06            lda 6,s           ;get mode
000977r 3  22 rr rr rr      jsl RA8875_WriteHex
00097Br 3  A3 07            lda 7,s           ;get mode
00097Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000981r 3               
000981r 3  A9 20            lda #' '
000983r 3  22 rr rr rr      jsl RA8875_WriteChar
000987r 3               
000987r 3               
000987r 3  A3 08            lda 8,s           ;get mode
000989r 3  22 rr rr rr      jsl RA8875_WriteHex
00098Dr 3  A3 09            lda 9,s           ;get mode
00098Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000993r 3               
000993r 3               
000993r 3  A9 20            lda #' '
000995r 3  22 rr rr rr      jsl RA8875_WriteChar
000999r 3               
000999r 3               
000999r 3  A3 0A            lda 10,s           ;get mode
00099Br 3  22 rr rr rr      jsl RA8875_WriteHex
00099Fr 3  A3 0B            lda 11,s           ;get mode
0009A1r 3  22 rr rr rr      jsl RA8875_WriteHex
0009A5r 3               
0009A5r 3  A9 20            lda #' '
0009A7r 3  22 rr rr rr      jsl RA8875_WriteChar
0009ABr 3               
0009ABr 3               
0009ABr 3  A3 0C            lda 12,s           ;get mode
0009ADr 3  22 rr rr rr      jsl RA8875_WriteHex
0009B1r 3  A3 0D            lda 13,s           ;get mode
0009B3r 3  22 rr rr rr      jsl RA8875_WriteHex
0009B7r 3               
0009B7r 3  A9 20            lda #' '
0009B9r 3  22 rr rr rr      jsl RA8875_WriteChar
0009BDr 3               
0009BDr 3               
0009BDr 3  A3 0E            lda 14,s           ;get mode
0009BFr 3  22 rr rr rr      jsl RA8875_WriteHex
0009C3r 3  A3 0F            lda 15,s           ;get mode
0009C5r 3  22 rr rr rr      jsl RA8875_WriteHex
0009C9r 3               
0009C9r 3  A9 20            lda #' '
0009CBr 3  22 rr rr rr      jsl RA8875_WriteChar
0009CFr 3               
0009CFr 3               
0009CFr 3  A3 10            lda 16,s           ;get mode
0009D1r 3  22 rr rr rr      jsl RA8875_WriteHex
0009D5r 3  A3 11            lda 17,s           ;get mode
0009D7r 3  22 rr rr rr      jsl RA8875_WriteHex
0009DBr 3               
0009DBr 3               
0009DBr 3  A9 20            lda #' '
0009DDr 3  22 rr rr rr      jsl RA8875_WriteChar
0009E1r 3               
0009E1r 3               
0009E1r 3  A3 12            lda 18,s           ;get mode
0009E3r 3  22 rr rr rr      jsl RA8875_WriteHex
0009E7r 3  A3 13            lda 19,s           ;get mode
0009E9r 3  22 rr rr rr      jsl RA8875_WriteHex
0009EDr 3               
0009EDr 3  A9 20            lda #' '
0009EFr 3  22 rr rr rr      jsl RA8875_WriteChar
0009F3r 3               
0009F3r 3               
0009F3r 3  A3 14            lda 20,s           ;get mode
0009F5r 3  22 rr rr rr      jsl RA8875_WriteHex
0009F9r 3  A3 15            lda 21,s           ;get mode
0009FBr 3  22 rr rr rr      jsl RA8875_WriteHex
0009FFr 3               
0009FFr 3  A9 20            lda #' '
000A01r 3  22 rr rr rr      jsl RA8875_WriteChar
000A05r 3               
000A05r 3               
000A05r 3  A3 16            lda 22,s           ;get mode
000A07r 3  22 rr rr rr      jsl RA8875_WriteHex
000A0Br 3  A3 17            lda 23,s           ;get mode
000A0Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000A11r 3               
000A11r 3  A9 20            lda #' '
000A13r 3  22 rr rr rr      jsl RA8875_WriteChar
000A17r 3               
000A17r 3               
000A17r 3  A3 18            lda 24,s           ;get mode
000A19r 3  22 rr rr rr      jsl RA8875_WriteHex
000A1Dr 3  A3 19            lda 25,s           ;get mode
000A1Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000A23r 3               
000A23r 3               
000A23r 3  A9 20            lda #' '
000A25r 3  22 rr rr rr      jsl RA8875_WriteChar
000A29r 3               
000A29r 3               
000A29r 3  A3 1A            lda 26,s           ;get mode
000A2Br 3  22 rr rr rr      jsl RA8875_WriteHex
000A2Fr 3  A3 1B            lda 27,s           ;get mode
000A31r 3  22 rr rr rr      jsl RA8875_WriteHex
000A35r 3               
000A35r 3  A9 0A            lda #$A
000A37r 3  22 rr rr rr      jsl RA8875_WriteChar
000A3Br 3               
000A3Br 3  C2 30            longr
000A3Dr 3  6B               rtl
000A3Er 3               
000A3Er 2               .include "dumpregs.asm"
000A3Er 3               .A8
000A3Er 3               .I8
000A3Er 3               DumpRegs:
000A3Er 3  C2 30            longr
000A40r 3  48               pha
000A41r 3  DA               phx
000A42r 3  5A               phy
000A43r 3               
000A43r 3  E2 30            shortr
000A45r 3               
000A45r 3  A9 41            lda #'A'
000A47r 3  22 rr rr rr      jsl RA8875_WriteChar
000A4Br 3  A9 3A            lda #':'
000A4Dr 3  22 rr rr rr      jsl RA8875_WriteChar
000A51r 3  A9 20            lda #' '
000A53r 3  22 rr rr rr      jsl RA8875_WriteChar
000A57r 3  A3 06            lda 6,s           ;get mode
000A59r 3  22 rr rr rr      jsl RA8875_WriteHex
000A5Dr 3  A3 05            lda 5,s           ;get mode
000A5Fr 3  22 rr rr rr      jsl RA8875_WriteHex
000A63r 3  A9 0A            lda #$0A
000A65r 3  22 rr rr rr      jsl RA8875_WriteChar
000A69r 3               
000A69r 3               
000A69r 3  A9 59            lda #'Y'
000A6Br 3  22 rr rr rr      jsl RA8875_WriteChar
000A6Fr 3  A9 3A            lda #':'
000A71r 3  22 rr rr rr      jsl RA8875_WriteChar
000A75r 3  A9 20            lda #' '
000A77r 3  22 rr rr rr      jsl RA8875_WriteChar
000A7Br 3  A3 02            lda 2,s           ;get mode
000A7Dr 3  22 rr rr rr      jsl RA8875_WriteHex
000A81r 3  A3 01            lda 1,s           ;get mode
000A83r 3  22 rr rr rr      jsl RA8875_WriteHex
000A87r 3  A9 0A            lda #$0A
000A89r 3  22 rr rr rr      jsl RA8875_WriteChar
000A8Dr 3               
000A8Dr 3  A9 58            lda #'X'
000A8Fr 3  22 rr rr rr      jsl RA8875_WriteChar
000A93r 3  A9 3A            lda #':'
000A95r 3  22 rr rr rr      jsl RA8875_WriteChar
000A99r 3  A9 20            lda #' '
000A9Br 3  22 rr rr rr      jsl RA8875_WriteChar
000A9Fr 3  A3 04            lda 4,s           ;get mode
000AA1r 3  22 rr rr rr      jsl RA8875_WriteHex
000AA5r 3  A3 03            lda 3,s           ;get mode
000AA7r 3  22 rr rr rr      jsl RA8875_WriteHex
000AABr 3  A9 0A            lda #$0A
000AADr 3  22 rr rr rr      jsl RA8875_WriteChar
000AB1r 3               
000AB1r 3               
000AB1r 3               
000AB1r 3  C2 30            longr       ;select 16 bit registers
000AB3r 3               
000AB3r 3  7A               ply
000AB4r 3  FA               plx
000AB5r 3  68               pla
000AB6r 3               
000AB6r 3  60               rts
000AB7r 3               
000AB7r 2               
000AB7r 1               .A8
000AB7r 1               .I8
000AB7r 1               ResetVector:
000AB7r 1  A2 FF            ldx #$FF
000AB9r 1  9A               txs
000ABAr 1  D8               cld
000ABBr 1  20 rr rr         jsr InitBIOS                    ; Entry point for boot
000ABEr 1               
000ABEr 1  C2 30            longr
000AC0r 1  20 rr rr         jsr InitKernel                  ; Kernel Init
000AC3r 1               
000AC3r 1                   ;shortr
000AC3r 1                   ;write test_string
000AC3r 1               
000AC3r 1                   ; longr
000AC3r 1                   ; ldx #$1234
000AC3r 1                   ; ldy #$5678
000AC3r 1                   ; lda #$9ABC
000AC3r 1                   ; jsr DumpRegs
000AC3r 1               
000AC3r 1                   ; longr
000AC3r 1                   ; ldx #$EFEF
000AC3r 1                   ; ldy #$4242
000AC3r 1                   ; lda #$ABCD
000AC3r 1                   ; pha
000AC3r 1                   ; lda #$0123
000AC3r 1                   ; pha
000AC3r 1                   ; lda #$CDEF
000AC3r 1               
000AC3r 1                   ; longr
000AC3r 1                   ; pla
000AC3r 1               
000AC3r 1               ; print break
000AC3r 1               
000AC3r 1                   ;write test_string
000AC3r 1               
000AC3r 1               ; StrLen
000AC3r 1               
000AC3r 1               
000AC3r 1                   ; pea testlen_string				; Add parameter to stack
000AC3r 1               
000AC3r 1                   ; lda #Std_StrLen
000AC3r 1                   ; jsl StdLib						; Call stdlib
000AC3r 1               
000AC3r 1               	; plx								; Clean up stack
000AC3r 1               
000AC3r 1                   ; jsl RA8875_WriteHex16			; Debug write result
000AC3r 1               
000AC3r 1               ; print break
000AC3r 1               
000AC3r 1                   ;write test_string
000AC3r 1               
000AC3r 1               
000AC3r 1               
000AC3r 1               
000AC3r 1               ; Readnum
000AC3r 1               
000AC3r 1               
000AC3r 1                   ; pea testlen_string				; Add parameter to stack
000AC3r 1               
000AC3r 1               
000AC3r 1                   ; lda #Std_ReadNum
000AC3r 1                   ; jsl StdLib						; Call stdlib
000AC3r 1               
000AC3r 1               	; plx								; Clean up stack
000AC3r 1               
000AC3r 1                   ; jsl RA8875_WriteHex16			; Debug write result
000AC3r 1               
000AC3r 1               ; print break
000AC3r 1               
000AC3r 1                   ;write test_string
000AC3r 1               
000AC3r 1  E2 30            shortr
000AC5r 1  A9 00            lda #$00            ; push program bank of ShellExec
000AC7r 1  48               pha
000AC8r 1  C2 30            longr
000ACAr 1  F4 rr rr         pea ShellExec       ; push 2byte addr of ShellExec
000ACDr 1               
000ACDr 1  22 rr rr rr      jsl TaskSpawn
000AD1r 1  68               pla
000AD2r 1  E2 30            shortr
000AD4r 1  68               pla
000AD5r 1               
000AD5r 1               
000AD5r 1                   ;longr
000AD5r 1                   ;write test_string
000AD5r 1                   ;shortr
000AD5r 1                   ;lda TaskStatus
000AD5r 1                   ;jsl RA8875_WriteHex
000AD5r 1               
000AD5r 1               
000AD5r 1                   ;longr
000AD5r 1                   ;write test_string
000AD5r 1                   ;shortr
000AD5r 1               
000AD5r 1  AD rr rr         lda TaskProgramBank
000AD8r 1  22 rr rr rr      jsl RA8875_WriteHex
000ADCr 1  AD rr rr         lda TaskProgramPointer
000ADFr 1  22 rr rr rr      jsl RA8875_WriteHex
000AE3r 1  AD rr rr         lda TaskProgramPointer+1
000AE6r 1  22 rr rr rr      jsl RA8875_WriteHex
000AEAr 1               
000AEAr 1                   ;longr
000AEAr 1                   ;write test_string
000AEAr 1                   ;shortr
000AEAr 1               
000AEAr 1  A9 00            lda #$00            ; push program bank of ShellExec
000AECr 1  48               pha
000AEDr 1  C2 30            longr
000AEFr 1  F4 rr rr         pea ClockExec       ; push 2byte addr of ShellExec
000AF2r 1               
000AF2r 1  22 rr rr rr      jsl TaskSpawn
000AF6r 1               
000AF6r 1  68               pla ; elean up 16bits
000AF7r 1               
000AF7r 1                   ;write test_string
000AF7r 1  E2 30            shortr
000AF9r 1  68               pla ; clean up
000AFAr 1  AD rr rr         lda TaskProgramBank+1
000AFDr 1  22 rr rr rr      jsl RA8875_WriteHex
000B01r 1  AD rr rr         lda TaskProgramPointer+2
000B04r 1  22 rr rr rr      jsl RA8875_WriteHex
000B08r 1  AD rr rr         lda TaskProgramPointer+3
000B0Br 1  22 rr rr rr      jsl RA8875_WriteHex
000B0Fr 1               
000B0Fr 1               
000B0Fr 1  58               cli
000B10r 1               
000B10r 1                   ;jsl Scheduler_NextTask
000B10r 1                   ;jsr ShellExec                   ; Run shell program
000B10r 1               
000B10r 1               ; Blink Diode
000B10r 1                   ;jsl LoaderExec
000B10r 1               
000B10r 1               Loop:
000B10r 1  4C rr rr         jmp Loop
000B13r 1               
000B13r 1               .SEGMENT "NATIVE_VECTORS"
000000r 1  00 00            .word $0000                 ; COP
000002r 1  00 00            .word $0000                 ; BRK
000004r 1  00 00            .word $0000                 ; ABORTB
000006r 1  00 00            .word $0000                 ; NMIB
000008r 1  00 00            .word $0000                 ; RES
00000Ar 1  rr rr            .word InterruptVector       ; IRQB
00000Cr 1               .SEGMENT "VECTORS"
000000r 1  rr rr            .word ResetVector
000002r 1               
000002r 1               
